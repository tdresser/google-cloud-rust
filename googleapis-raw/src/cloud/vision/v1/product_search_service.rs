// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/vision/v1/product_search_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Product {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub product_category: ::std::string::String,
    pub product_labels: ::protobuf::RepeatedField<Product_KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Product {
    fn default() -> &'a Product {
        <Product as ::protobuf::Message>::default_instance()
    }
}

impl Product {
    pub fn new() -> Product {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string product_category = 4;


    pub fn get_product_category(&self) -> &str {
        &self.product_category
    }
    pub fn clear_product_category(&mut self) {
        self.product_category.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_category(&mut self, v: ::std::string::String) {
        self.product_category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_category(&mut self) -> &mut ::std::string::String {
        &mut self.product_category
    }

    // Take field
    pub fn take_product_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_category, ::std::string::String::new())
    }

    // repeated .google.cloud.vision.v1.Product.KeyValue product_labels = 5;


    pub fn get_product_labels(&self) -> &[Product_KeyValue] {
        &self.product_labels
    }
    pub fn clear_product_labels(&mut self) {
        self.product_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_labels(&mut self, v: ::protobuf::RepeatedField<Product_KeyValue>) {
        self.product_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_product_labels(&mut self) -> &mut ::protobuf::RepeatedField<Product_KeyValue> {
        &mut self.product_labels
    }

    // Take field
    pub fn take_product_labels(&mut self) -> ::protobuf::RepeatedField<Product_KeyValue> {
        ::std::mem::replace(&mut self.product_labels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Product {
    fn is_initialized(&self) -> bool {
        for v in &self.product_labels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_category)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.product_labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.product_category.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.product_category);
        }
        for value in &self.product_labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.product_category.is_empty() {
            os.write_string(4, &self.product_category)?;
        }
        for v in &self.product_labels {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Product {
        Product::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Product| { &m.name },
                |m: &mut Product| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &Product| { &m.display_name },
                |m: &mut Product| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Product| { &m.description },
                |m: &mut Product| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_category",
                |m: &Product| { &m.product_category },
                |m: &mut Product| { &mut m.product_category },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Product_KeyValue>>(
                "product_labels",
                |m: &Product| { &m.product_labels },
                |m: &mut Product| { &mut m.product_labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Product>(
                "Product",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Product {
        static instance: ::protobuf::rt::LazyV2<Product> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Product::new)
    }
}

impl ::protobuf::Clear for Product {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.product_category.clear();
        self.product_labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Product {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Product {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Product_KeyValue {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Product_KeyValue {
    fn default() -> &'a Product_KeyValue {
        <Product_KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl Product_KeyValue {
    pub fn new() -> Product_KeyValue {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Product_KeyValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Product_KeyValue {
        Product_KeyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Product_KeyValue| { &m.key },
                |m: &mut Product_KeyValue| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Product_KeyValue| { &m.value },
                |m: &mut Product_KeyValue| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Product_KeyValue>(
                "Product.KeyValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Product_KeyValue {
        static instance: ::protobuf::rt::LazyV2<Product_KeyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Product_KeyValue::new)
    }
}

impl ::protobuf::Clear for Product_KeyValue {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Product_KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Product_KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProductSet {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub index_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub index_error: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductSet {
    fn default() -> &'a ProductSet {
        <ProductSet as ::protobuf::Message>::default_instance()
    }
}

impl ProductSet {
    pub fn new() -> ProductSet {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp index_time = 3;


    pub fn get_index_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.index_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_time(&mut self) {
        self.index_time.clear();
    }

    pub fn has_index_time(&self) -> bool {
        self.index_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.index_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.index_time.is_none() {
            self.index_time.set_default();
        }
        self.index_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.index_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.rpc.Status index_error = 4;


    pub fn get_index_error(&self) -> &super::status::Status {
        self.index_error.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_error(&mut self) {
        self.index_error.clear();
    }

    pub fn has_index_error(&self) -> bool {
        self.index_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_error(&mut self, v: super::status::Status) {
        self.index_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_error(&mut self) -> &mut super::status::Status {
        if self.index_error.is_none() {
            self.index_error.set_default();
        }
        self.index_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_error(&mut self) -> super::status::Status {
        self.index_error.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for ProductSet {
    fn is_initialized(&self) -> bool {
        for v in &self.index_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if let Some(ref v) = self.index_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.index_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if let Some(ref v) = self.index_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.index_error.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductSet {
        ProductSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ProductSet| { &m.name },
                |m: &mut ProductSet| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &ProductSet| { &m.display_name },
                |m: &mut ProductSet| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "index_time",
                |m: &ProductSet| { &m.index_time },
                |m: &mut ProductSet| { &mut m.index_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "index_error",
                |m: &ProductSet| { &m.index_error },
                |m: &mut ProductSet| { &mut m.index_error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductSet>(
                "ProductSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductSet {
        static instance: ::protobuf::rt::LazyV2<ProductSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductSet::new)
    }
}

impl ::protobuf::Clear for ProductSet {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.index_time.clear();
        self.index_error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferenceImage {
    // message fields
    pub name: ::std::string::String,
    pub uri: ::std::string::String,
    pub bounding_polys: ::protobuf::RepeatedField<super::geometry::BoundingPoly>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReferenceImage {
    fn default() -> &'a ReferenceImage {
        <ReferenceImage as ::protobuf::Message>::default_instance()
    }
}

impl ReferenceImage {
    pub fn new() -> ReferenceImage {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string uri = 2;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // repeated .google.cloud.vision.v1.BoundingPoly bounding_polys = 3;


    pub fn get_bounding_polys(&self) -> &[super::geometry::BoundingPoly] {
        &self.bounding_polys
    }
    pub fn clear_bounding_polys(&mut self) {
        self.bounding_polys.clear();
    }

    // Param is passed by value, moved
    pub fn set_bounding_polys(&mut self, v: ::protobuf::RepeatedField<super::geometry::BoundingPoly>) {
        self.bounding_polys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bounding_polys(&mut self) -> &mut ::protobuf::RepeatedField<super::geometry::BoundingPoly> {
        &mut self.bounding_polys
    }

    // Take field
    pub fn take_bounding_polys(&mut self) -> ::protobuf::RepeatedField<super::geometry::BoundingPoly> {
        ::std::mem::replace(&mut self.bounding_polys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReferenceImage {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_polys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bounding_polys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uri);
        }
        for value in &self.bounding_polys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.uri.is_empty() {
            os.write_string(2, &self.uri)?;
        }
        for v in &self.bounding_polys {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferenceImage {
        ReferenceImage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ReferenceImage| { &m.name },
                |m: &mut ReferenceImage| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &ReferenceImage| { &m.uri },
                |m: &mut ReferenceImage| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "bounding_polys",
                |m: &ReferenceImage| { &m.bounding_polys },
                |m: &mut ReferenceImage| { &mut m.bounding_polys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReferenceImage>(
                "ReferenceImage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReferenceImage {
        static instance: ::protobuf::rt::LazyV2<ReferenceImage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReferenceImage::new)
    }
}

impl ::protobuf::Clear for ReferenceImage {
    fn clear(&mut self) {
        self.name.clear();
        self.uri.clear();
        self.bounding_polys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferenceImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceImage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateProductRequest {
    // message fields
    pub parent: ::std::string::String,
    pub product: ::protobuf::SingularPtrField<Product>,
    pub product_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateProductRequest {
    fn default() -> &'a CreateProductRequest {
        <CreateProductRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateProductRequest {
    pub fn new() -> CreateProductRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.vision.v1.Product product = 2;


    pub fn get_product(&self) -> &Product {
        self.product.as_ref().unwrap_or_else(|| <Product as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: Product) {
        self.product = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut Product {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> Product {
        self.product.take().unwrap_or_else(|| Product::new())
    }

    // string product_id = 3;


    pub fn get_product_id(&self) -> &str {
        &self.product_id
    }
    pub fn clear_product_id(&mut self) {
        self.product_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_id(&mut self, v: ::std::string::String) {
        self.product_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_id(&mut self) -> &mut ::std::string::String {
        &mut self.product_id
    }

    // Take field
    pub fn take_product_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateProductRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.product {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.product_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.product_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.product.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.product_id.is_empty() {
            os.write_string(3, &self.product_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateProductRequest {
        CreateProductRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateProductRequest| { &m.parent },
                |m: &mut CreateProductRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Product>>(
                "product",
                |m: &CreateProductRequest| { &m.product },
                |m: &mut CreateProductRequest| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_id",
                |m: &CreateProductRequest| { &m.product_id },
                |m: &mut CreateProductRequest| { &mut m.product_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateProductRequest>(
                "CreateProductRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateProductRequest {
        static instance: ::protobuf::rt::LazyV2<CreateProductRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateProductRequest::new)
    }
}

impl ::protobuf::Clear for CreateProductRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.product.clear();
        self.product_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateProductRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateProductRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductsRequest {
    fn default() -> &'a ListProductsRequest {
        <ListProductsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProductsRequest {
    pub fn new() -> ListProductsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductsRequest {
        ListProductsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListProductsRequest| { &m.parent },
                |m: &mut ListProductsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListProductsRequest| { &m.page_size },
                |m: &mut ListProductsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListProductsRequest| { &m.page_token },
                |m: &mut ListProductsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductsRequest>(
                "ListProductsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductsRequest {
        static instance: ::protobuf::rt::LazyV2<ListProductsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductsRequest::new)
    }
}

impl ::protobuf::Clear for ListProductsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductsResponse {
    // message fields
    pub products: ::protobuf::RepeatedField<Product>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductsResponse {
    fn default() -> &'a ListProductsResponse {
        <ListProductsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProductsResponse {
    pub fn new() -> ListProductsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.Product products = 1;


    pub fn get_products(&self) -> &[Product] {
        &self.products
    }
    pub fn clear_products(&mut self) {
        self.products.clear();
    }

    // Param is passed by value, moved
    pub fn set_products(&mut self, v: ::protobuf::RepeatedField<Product>) {
        self.products = v;
    }

    // Mutable pointer to the field.
    pub fn mut_products(&mut self) -> &mut ::protobuf::RepeatedField<Product> {
        &mut self.products
    }

    // Take field
    pub fn take_products(&mut self) -> ::protobuf::RepeatedField<Product> {
        ::std::mem::replace(&mut self.products, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.products {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.products)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.products {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.products {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductsResponse {
        ListProductsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Product>>(
                "products",
                |m: &ListProductsResponse| { &m.products },
                |m: &mut ListProductsResponse| { &mut m.products },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListProductsResponse| { &m.next_page_token },
                |m: &mut ListProductsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductsResponse>(
                "ListProductsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductsResponse {
        static instance: ::protobuf::rt::LazyV2<ListProductsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductsResponse::new)
    }
}

impl ::protobuf::Clear for ListProductsResponse {
    fn clear(&mut self) {
        self.products.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetProductRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProductRequest {
    fn default() -> &'a GetProductRequest {
        <GetProductRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProductRequest {
    pub fn new() -> GetProductRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetProductRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProductRequest {
        GetProductRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetProductRequest| { &m.name },
                |m: &mut GetProductRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetProductRequest>(
                "GetProductRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetProductRequest {
        static instance: ::protobuf::rt::LazyV2<GetProductRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetProductRequest::new)
    }
}

impl ::protobuf::Clear for GetProductRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProductRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProductRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateProductRequest {
    // message fields
    pub product: ::protobuf::SingularPtrField<Product>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateProductRequest {
    fn default() -> &'a UpdateProductRequest {
        <UpdateProductRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateProductRequest {
    pub fn new() -> UpdateProductRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.Product product = 1;


    pub fn get_product(&self) -> &Product {
        self.product.as_ref().unwrap_or_else(|| <Product as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: Product) {
        self.product = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut Product {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> Product {
        self.product.take().unwrap_or_else(|| Product::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateProductRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.product {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.product.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateProductRequest {
        UpdateProductRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Product>>(
                "product",
                |m: &UpdateProductRequest| { &m.product },
                |m: &mut UpdateProductRequest| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateProductRequest| { &m.update_mask },
                |m: &mut UpdateProductRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateProductRequest>(
                "UpdateProductRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateProductRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateProductRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateProductRequest::new)
    }
}

impl ::protobuf::Clear for UpdateProductRequest {
    fn clear(&mut self) {
        self.product.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateProductRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateProductRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteProductRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteProductRequest {
    fn default() -> &'a DeleteProductRequest {
        <DeleteProductRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteProductRequest {
    pub fn new() -> DeleteProductRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteProductRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteProductRequest {
        DeleteProductRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteProductRequest| { &m.name },
                |m: &mut DeleteProductRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteProductRequest>(
                "DeleteProductRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteProductRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteProductRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteProductRequest::new)
    }
}

impl ::protobuf::Clear for DeleteProductRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteProductRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteProductRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateProductSetRequest {
    // message fields
    pub parent: ::std::string::String,
    pub product_set: ::protobuf::SingularPtrField<ProductSet>,
    pub product_set_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateProductSetRequest {
    fn default() -> &'a CreateProductSetRequest {
        <CreateProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateProductSetRequest {
    pub fn new() -> CreateProductSetRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.vision.v1.ProductSet product_set = 2;


    pub fn get_product_set(&self) -> &ProductSet {
        self.product_set.as_ref().unwrap_or_else(|| <ProductSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product_set(&mut self) {
        self.product_set.clear();
    }

    pub fn has_product_set(&self) -> bool {
        self.product_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_set(&mut self, v: ProductSet) {
        self.product_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_set(&mut self) -> &mut ProductSet {
        if self.product_set.is_none() {
            self.product_set.set_default();
        }
        self.product_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_set(&mut self) -> ProductSet {
        self.product_set.take().unwrap_or_else(|| ProductSet::new())
    }

    // string product_set_id = 3;


    pub fn get_product_set_id(&self) -> &str {
        &self.product_set_id
    }
    pub fn clear_product_set_id(&mut self) {
        self.product_set_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_set_id(&mut self, v: ::std::string::String) {
        self.product_set_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_set_id(&mut self) -> &mut ::std::string::String {
        &mut self.product_set_id
    }

    // Take field
    pub fn take_product_set_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_set_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateProductSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.product_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product_set)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_set_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.product_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.product_set_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.product_set_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.product_set.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.product_set_id.is_empty() {
            os.write_string(3, &self.product_set_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateProductSetRequest {
        CreateProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateProductSetRequest| { &m.parent },
                |m: &mut CreateProductSetRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductSet>>(
                "product_set",
                |m: &CreateProductSetRequest| { &m.product_set },
                |m: &mut CreateProductSetRequest| { &mut m.product_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_set_id",
                |m: &CreateProductSetRequest| { &m.product_set_id },
                |m: &mut CreateProductSetRequest| { &mut m.product_set_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateProductSetRequest>(
                "CreateProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<CreateProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateProductSetRequest::new)
    }
}

impl ::protobuf::Clear for CreateProductSetRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.product_set.clear();
        self.product_set_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductSetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductSetsRequest {
    fn default() -> &'a ListProductSetsRequest {
        <ListProductSetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProductSetsRequest {
    pub fn new() -> ListProductSetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductSetsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductSetsRequest {
        ListProductSetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListProductSetsRequest| { &m.parent },
                |m: &mut ListProductSetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListProductSetsRequest| { &m.page_size },
                |m: &mut ListProductSetsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListProductSetsRequest| { &m.page_token },
                |m: &mut ListProductSetsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductSetsRequest>(
                "ListProductSetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductSetsRequest {
        static instance: ::protobuf::rt::LazyV2<ListProductSetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductSetsRequest::new)
    }
}

impl ::protobuf::Clear for ListProductSetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductSetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductSetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductSetsResponse {
    // message fields
    pub product_sets: ::protobuf::RepeatedField<ProductSet>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductSetsResponse {
    fn default() -> &'a ListProductSetsResponse {
        <ListProductSetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProductSetsResponse {
    pub fn new() -> ListProductSetsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.ProductSet product_sets = 1;


    pub fn get_product_sets(&self) -> &[ProductSet] {
        &self.product_sets
    }
    pub fn clear_product_sets(&mut self) {
        self.product_sets.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_sets(&mut self, v: ::protobuf::RepeatedField<ProductSet>) {
        self.product_sets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_product_sets(&mut self) -> &mut ::protobuf::RepeatedField<ProductSet> {
        &mut self.product_sets
    }

    // Take field
    pub fn take_product_sets(&mut self) -> ::protobuf::RepeatedField<ProductSet> {
        ::std::mem::replace(&mut self.product_sets, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductSetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.product_sets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.product_sets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.product_sets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.product_sets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductSetsResponse {
        ListProductSetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductSet>>(
                "product_sets",
                |m: &ListProductSetsResponse| { &m.product_sets },
                |m: &mut ListProductSetsResponse| { &mut m.product_sets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListProductSetsResponse| { &m.next_page_token },
                |m: &mut ListProductSetsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductSetsResponse>(
                "ListProductSetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductSetsResponse {
        static instance: ::protobuf::rt::LazyV2<ListProductSetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductSetsResponse::new)
    }
}

impl ::protobuf::Clear for ListProductSetsResponse {
    fn clear(&mut self) {
        self.product_sets.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductSetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductSetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetProductSetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProductSetRequest {
    fn default() -> &'a GetProductSetRequest {
        <GetProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProductSetRequest {
    pub fn new() -> GetProductSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetProductSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProductSetRequest {
        GetProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetProductSetRequest| { &m.name },
                |m: &mut GetProductSetRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetProductSetRequest>(
                "GetProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<GetProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetProductSetRequest::new)
    }
}

impl ::protobuf::Clear for GetProductSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateProductSetRequest {
    // message fields
    pub product_set: ::protobuf::SingularPtrField<ProductSet>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateProductSetRequest {
    fn default() -> &'a UpdateProductSetRequest {
        <UpdateProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateProductSetRequest {
    pub fn new() -> UpdateProductSetRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.ProductSet product_set = 1;


    pub fn get_product_set(&self) -> &ProductSet {
        self.product_set.as_ref().unwrap_or_else(|| <ProductSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product_set(&mut self) {
        self.product_set.clear();
    }

    pub fn has_product_set(&self) -> bool {
        self.product_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_set(&mut self, v: ProductSet) {
        self.product_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_set(&mut self) -> &mut ProductSet {
        if self.product_set.is_none() {
            self.product_set.set_default();
        }
        self.product_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_set(&mut self) -> ProductSet {
        self.product_set.take().unwrap_or_else(|| ProductSet::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateProductSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.product_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product_set)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.product_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.product_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateProductSetRequest {
        UpdateProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductSet>>(
                "product_set",
                |m: &UpdateProductSetRequest| { &m.product_set },
                |m: &mut UpdateProductSetRequest| { &mut m.product_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateProductSetRequest| { &m.update_mask },
                |m: &mut UpdateProductSetRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateProductSetRequest>(
                "UpdateProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateProductSetRequest::new)
    }
}

impl ::protobuf::Clear for UpdateProductSetRequest {
    fn clear(&mut self) {
        self.product_set.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteProductSetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteProductSetRequest {
    fn default() -> &'a DeleteProductSetRequest {
        <DeleteProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteProductSetRequest {
    pub fn new() -> DeleteProductSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteProductSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteProductSetRequest {
        DeleteProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteProductSetRequest| { &m.name },
                |m: &mut DeleteProductSetRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteProductSetRequest>(
                "DeleteProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteProductSetRequest::new)
    }
}

impl ::protobuf::Clear for DeleteProductSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateReferenceImageRequest {
    // message fields
    pub parent: ::std::string::String,
    pub reference_image: ::protobuf::SingularPtrField<ReferenceImage>,
    pub reference_image_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateReferenceImageRequest {
    fn default() -> &'a CreateReferenceImageRequest {
        <CreateReferenceImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateReferenceImageRequest {
    pub fn new() -> CreateReferenceImageRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.vision.v1.ReferenceImage reference_image = 2;


    pub fn get_reference_image(&self) -> &ReferenceImage {
        self.reference_image.as_ref().unwrap_or_else(|| <ReferenceImage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reference_image(&mut self) {
        self.reference_image.clear();
    }

    pub fn has_reference_image(&self) -> bool {
        self.reference_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_image(&mut self, v: ReferenceImage) {
        self.reference_image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference_image(&mut self) -> &mut ReferenceImage {
        if self.reference_image.is_none() {
            self.reference_image.set_default();
        }
        self.reference_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_reference_image(&mut self) -> ReferenceImage {
        self.reference_image.take().unwrap_or_else(|| ReferenceImage::new())
    }

    // string reference_image_id = 3;


    pub fn get_reference_image_id(&self) -> &str {
        &self.reference_image_id
    }
    pub fn clear_reference_image_id(&mut self) {
        self.reference_image_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_image_id(&mut self, v: ::std::string::String) {
        self.reference_image_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference_image_id(&mut self) -> &mut ::std::string::String {
        &mut self.reference_image_id
    }

    // Take field
    pub fn take_reference_image_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reference_image_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateReferenceImageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.reference_image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reference_image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reference_image_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.reference_image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.reference_image_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.reference_image_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.reference_image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.reference_image_id.is_empty() {
            os.write_string(3, &self.reference_image_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateReferenceImageRequest {
        CreateReferenceImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateReferenceImageRequest| { &m.parent },
                |m: &mut CreateReferenceImageRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReferenceImage>>(
                "reference_image",
                |m: &CreateReferenceImageRequest| { &m.reference_image },
                |m: &mut CreateReferenceImageRequest| { &mut m.reference_image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reference_image_id",
                |m: &CreateReferenceImageRequest| { &m.reference_image_id },
                |m: &mut CreateReferenceImageRequest| { &mut m.reference_image_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateReferenceImageRequest>(
                "CreateReferenceImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateReferenceImageRequest {
        static instance: ::protobuf::rt::LazyV2<CreateReferenceImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateReferenceImageRequest::new)
    }
}

impl ::protobuf::Clear for CreateReferenceImageRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.reference_image.clear();
        self.reference_image_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateReferenceImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateReferenceImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListReferenceImagesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListReferenceImagesRequest {
    fn default() -> &'a ListReferenceImagesRequest {
        <ListReferenceImagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListReferenceImagesRequest {
    pub fn new() -> ListReferenceImagesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListReferenceImagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListReferenceImagesRequest {
        ListReferenceImagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListReferenceImagesRequest| { &m.parent },
                |m: &mut ListReferenceImagesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListReferenceImagesRequest| { &m.page_size },
                |m: &mut ListReferenceImagesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListReferenceImagesRequest| { &m.page_token },
                |m: &mut ListReferenceImagesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListReferenceImagesRequest>(
                "ListReferenceImagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListReferenceImagesRequest {
        static instance: ::protobuf::rt::LazyV2<ListReferenceImagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListReferenceImagesRequest::new)
    }
}

impl ::protobuf::Clear for ListReferenceImagesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListReferenceImagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListReferenceImagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListReferenceImagesResponse {
    // message fields
    pub reference_images: ::protobuf::RepeatedField<ReferenceImage>,
    pub page_size: i32,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListReferenceImagesResponse {
    fn default() -> &'a ListReferenceImagesResponse {
        <ListReferenceImagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListReferenceImagesResponse {
    pub fn new() -> ListReferenceImagesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.ReferenceImage reference_images = 1;


    pub fn get_reference_images(&self) -> &[ReferenceImage] {
        &self.reference_images
    }
    pub fn clear_reference_images(&mut self) {
        self.reference_images.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_images(&mut self, v: ::protobuf::RepeatedField<ReferenceImage>) {
        self.reference_images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reference_images(&mut self) -> &mut ::protobuf::RepeatedField<ReferenceImage> {
        &mut self.reference_images
    }

    // Take field
    pub fn take_reference_images(&mut self) -> ::protobuf::RepeatedField<ReferenceImage> {
        ::std::mem::replace(&mut self.reference_images, ::protobuf::RepeatedField::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListReferenceImagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reference_images {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reference_images)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reference_images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reference_images {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListReferenceImagesResponse {
        ListReferenceImagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReferenceImage>>(
                "reference_images",
                |m: &ListReferenceImagesResponse| { &m.reference_images },
                |m: &mut ListReferenceImagesResponse| { &mut m.reference_images },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListReferenceImagesResponse| { &m.page_size },
                |m: &mut ListReferenceImagesResponse| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListReferenceImagesResponse| { &m.next_page_token },
                |m: &mut ListReferenceImagesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListReferenceImagesResponse>(
                "ListReferenceImagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListReferenceImagesResponse {
        static instance: ::protobuf::rt::LazyV2<ListReferenceImagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListReferenceImagesResponse::new)
    }
}

impl ::protobuf::Clear for ListReferenceImagesResponse {
    fn clear(&mut self) {
        self.reference_images.clear();
        self.page_size = 0;
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListReferenceImagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListReferenceImagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetReferenceImageRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetReferenceImageRequest {
    fn default() -> &'a GetReferenceImageRequest {
        <GetReferenceImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetReferenceImageRequest {
    pub fn new() -> GetReferenceImageRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetReferenceImageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReferenceImageRequest {
        GetReferenceImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetReferenceImageRequest| { &m.name },
                |m: &mut GetReferenceImageRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetReferenceImageRequest>(
                "GetReferenceImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetReferenceImageRequest {
        static instance: ::protobuf::rt::LazyV2<GetReferenceImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetReferenceImageRequest::new)
    }
}

impl ::protobuf::Clear for GetReferenceImageRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReferenceImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReferenceImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteReferenceImageRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteReferenceImageRequest {
    fn default() -> &'a DeleteReferenceImageRequest {
        <DeleteReferenceImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteReferenceImageRequest {
    pub fn new() -> DeleteReferenceImageRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteReferenceImageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteReferenceImageRequest {
        DeleteReferenceImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteReferenceImageRequest| { &m.name },
                |m: &mut DeleteReferenceImageRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteReferenceImageRequest>(
                "DeleteReferenceImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteReferenceImageRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteReferenceImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteReferenceImageRequest::new)
    }
}

impl ::protobuf::Clear for DeleteReferenceImageRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteReferenceImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteReferenceImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddProductToProductSetRequest {
    // message fields
    pub name: ::std::string::String,
    pub product: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddProductToProductSetRequest {
    fn default() -> &'a AddProductToProductSetRequest {
        <AddProductToProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddProductToProductSetRequest {
    pub fn new() -> AddProductToProductSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string product = 2;


    pub fn get_product(&self) -> &str {
        &self.product
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        &mut self.product
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddProductToProductSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.product.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.product);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.product.is_empty() {
            os.write_string(2, &self.product)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddProductToProductSetRequest {
        AddProductToProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AddProductToProductSetRequest| { &m.name },
                |m: &mut AddProductToProductSetRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &AddProductToProductSetRequest| { &m.product },
                |m: &mut AddProductToProductSetRequest| { &mut m.product },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddProductToProductSetRequest>(
                "AddProductToProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddProductToProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<AddProductToProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddProductToProductSetRequest::new)
    }
}

impl ::protobuf::Clear for AddProductToProductSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.product.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddProductToProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddProductToProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveProductFromProductSetRequest {
    // message fields
    pub name: ::std::string::String,
    pub product: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveProductFromProductSetRequest {
    fn default() -> &'a RemoveProductFromProductSetRequest {
        <RemoveProductFromProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveProductFromProductSetRequest {
    pub fn new() -> RemoveProductFromProductSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string product = 2;


    pub fn get_product(&self) -> &str {
        &self.product
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        &mut self.product
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveProductFromProductSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.product.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.product);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.product.is_empty() {
            os.write_string(2, &self.product)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveProductFromProductSetRequest {
        RemoveProductFromProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RemoveProductFromProductSetRequest| { &m.name },
                |m: &mut RemoveProductFromProductSetRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &RemoveProductFromProductSetRequest| { &m.product },
                |m: &mut RemoveProductFromProductSetRequest| { &mut m.product },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveProductFromProductSetRequest>(
                "RemoveProductFromProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveProductFromProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveProductFromProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveProductFromProductSetRequest::new)
    }
}

impl ::protobuf::Clear for RemoveProductFromProductSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.product.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveProductFromProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveProductFromProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductsInProductSetRequest {
    // message fields
    pub name: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductsInProductSetRequest {
    fn default() -> &'a ListProductsInProductSetRequest {
        <ListProductsInProductSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProductsInProductSetRequest {
    pub fn new() -> ListProductsInProductSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductsInProductSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductsInProductSetRequest {
        ListProductsInProductSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListProductsInProductSetRequest| { &m.name },
                |m: &mut ListProductsInProductSetRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListProductsInProductSetRequest| { &m.page_size },
                |m: &mut ListProductsInProductSetRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListProductsInProductSetRequest| { &m.page_token },
                |m: &mut ListProductsInProductSetRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductsInProductSetRequest>(
                "ListProductsInProductSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductsInProductSetRequest {
        static instance: ::protobuf::rt::LazyV2<ListProductsInProductSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductsInProductSetRequest::new)
    }
}

impl ::protobuf::Clear for ListProductsInProductSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductsInProductSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductsInProductSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProductsInProductSetResponse {
    // message fields
    pub products: ::protobuf::RepeatedField<Product>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListProductsInProductSetResponse {
    fn default() -> &'a ListProductsInProductSetResponse {
        <ListProductsInProductSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProductsInProductSetResponse {
    pub fn new() -> ListProductsInProductSetResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.Product products = 1;


    pub fn get_products(&self) -> &[Product] {
        &self.products
    }
    pub fn clear_products(&mut self) {
        self.products.clear();
    }

    // Param is passed by value, moved
    pub fn set_products(&mut self, v: ::protobuf::RepeatedField<Product>) {
        self.products = v;
    }

    // Mutable pointer to the field.
    pub fn mut_products(&mut self) -> &mut ::protobuf::RepeatedField<Product> {
        &mut self.products
    }

    // Take field
    pub fn take_products(&mut self) -> ::protobuf::RepeatedField<Product> {
        ::std::mem::replace(&mut self.products, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListProductsInProductSetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.products {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.products)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.products {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.products {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProductsInProductSetResponse {
        ListProductsInProductSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Product>>(
                "products",
                |m: &ListProductsInProductSetResponse| { &m.products },
                |m: &mut ListProductsInProductSetResponse| { &mut m.products },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListProductsInProductSetResponse| { &m.next_page_token },
                |m: &mut ListProductsInProductSetResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListProductsInProductSetResponse>(
                "ListProductsInProductSetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListProductsInProductSetResponse {
        static instance: ::protobuf::rt::LazyV2<ListProductsInProductSetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListProductsInProductSetResponse::new)
    }
}

impl ::protobuf::Clear for ListProductsInProductSetResponse {
    fn clear(&mut self) {
        self.products.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProductsInProductSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProductsInProductSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportProductSetsGcsSource {
    // message fields
    pub csv_file_uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportProductSetsGcsSource {
    fn default() -> &'a ImportProductSetsGcsSource {
        <ImportProductSetsGcsSource as ::protobuf::Message>::default_instance()
    }
}

impl ImportProductSetsGcsSource {
    pub fn new() -> ImportProductSetsGcsSource {
        ::std::default::Default::default()
    }

    // string csv_file_uri = 1;


    pub fn get_csv_file_uri(&self) -> &str {
        &self.csv_file_uri
    }
    pub fn clear_csv_file_uri(&mut self) {
        self.csv_file_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_csv_file_uri(&mut self, v: ::std::string::String) {
        self.csv_file_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csv_file_uri(&mut self) -> &mut ::std::string::String {
        &mut self.csv_file_uri
    }

    // Take field
    pub fn take_csv_file_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.csv_file_uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImportProductSetsGcsSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.csv_file_uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.csv_file_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.csv_file_uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.csv_file_uri.is_empty() {
            os.write_string(1, &self.csv_file_uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportProductSetsGcsSource {
        ImportProductSetsGcsSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "csv_file_uri",
                |m: &ImportProductSetsGcsSource| { &m.csv_file_uri },
                |m: &mut ImportProductSetsGcsSource| { &mut m.csv_file_uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportProductSetsGcsSource>(
                "ImportProductSetsGcsSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportProductSetsGcsSource {
        static instance: ::protobuf::rt::LazyV2<ImportProductSetsGcsSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportProductSetsGcsSource::new)
    }
}

impl ::protobuf::Clear for ImportProductSetsGcsSource {
    fn clear(&mut self) {
        self.csv_file_uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportProductSetsGcsSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportProductSetsGcsSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportProductSetsInputConfig {
    // message oneof groups
    pub source: ::std::option::Option<ImportProductSetsInputConfig_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportProductSetsInputConfig {
    fn default() -> &'a ImportProductSetsInputConfig {
        <ImportProductSetsInputConfig as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ImportProductSetsInputConfig_oneof_source {
    gcs_source(ImportProductSetsGcsSource),
}

impl ImportProductSetsInputConfig {
    pub fn new() -> ImportProductSetsInputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.ImportProductSetsGcsSource gcs_source = 1;


    pub fn get_gcs_source(&self) -> &ImportProductSetsGcsSource {
        match self.source {
            ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(ref v)) => v,
            _ => <ImportProductSetsGcsSource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_gcs_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_gcs_source(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_source(&mut self, v: ImportProductSetsGcsSource) {
        self.source = ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_source(&mut self) -> &mut ImportProductSetsGcsSource {
        if let ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(ImportProductSetsGcsSource::new()));
        }
        match self.source {
            ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_source(&mut self) -> ImportProductSetsGcsSource {
        if self.has_gcs_source() {
            match self.source.take() {
                ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(v)) => v,
                _ => panic!(),
            }
        } else {
            ImportProductSetsGcsSource::new()
        }
    }
}

impl ::protobuf::Message for ImportProductSetsInputConfig {
    fn is_initialized(&self) -> bool {
        if let Some(ImportProductSetsInputConfig_oneof_source::gcs_source(ref v)) = self.source {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(ImportProductSetsInputConfig_oneof_source::gcs_source(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &ImportProductSetsInputConfig_oneof_source::gcs_source(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &ImportProductSetsInputConfig_oneof_source::gcs_source(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportProductSetsInputConfig {
        ImportProductSetsInputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImportProductSetsGcsSource>(
                "gcs_source",
                ImportProductSetsInputConfig::has_gcs_source,
                ImportProductSetsInputConfig::get_gcs_source,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportProductSetsInputConfig>(
                "ImportProductSetsInputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportProductSetsInputConfig {
        static instance: ::protobuf::rt::LazyV2<ImportProductSetsInputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportProductSetsInputConfig::new)
    }
}

impl ::protobuf::Clear for ImportProductSetsInputConfig {
    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportProductSetsInputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportProductSetsInputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportProductSetsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub input_config: ::protobuf::SingularPtrField<ImportProductSetsInputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportProductSetsRequest {
    fn default() -> &'a ImportProductSetsRequest {
        <ImportProductSetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImportProductSetsRequest {
    pub fn new() -> ImportProductSetsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.cloud.vision.v1.ImportProductSetsInputConfig input_config = 2;


    pub fn get_input_config(&self) -> &ImportProductSetsInputConfig {
        self.input_config.as_ref().unwrap_or_else(|| <ImportProductSetsInputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_config(&mut self) {
        self.input_config.clear();
    }

    pub fn has_input_config(&self) -> bool {
        self.input_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_config(&mut self, v: ImportProductSetsInputConfig) {
        self.input_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_config(&mut self) -> &mut ImportProductSetsInputConfig {
        if self.input_config.is_none() {
            self.input_config.set_default();
        }
        self.input_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_config(&mut self) -> ImportProductSetsInputConfig {
        self.input_config.take().unwrap_or_else(|| ImportProductSetsInputConfig::new())
    }
}

impl ::protobuf::Message for ImportProductSetsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.input_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.input_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.input_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportProductSetsRequest {
        ImportProductSetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ImportProductSetsRequest| { &m.parent },
                |m: &mut ImportProductSetsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImportProductSetsInputConfig>>(
                "input_config",
                |m: &ImportProductSetsRequest| { &m.input_config },
                |m: &mut ImportProductSetsRequest| { &mut m.input_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportProductSetsRequest>(
                "ImportProductSetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportProductSetsRequest {
        static instance: ::protobuf::rt::LazyV2<ImportProductSetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportProductSetsRequest::new)
    }
}

impl ::protobuf::Clear for ImportProductSetsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.input_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportProductSetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportProductSetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportProductSetsResponse {
    // message fields
    pub reference_images: ::protobuf::RepeatedField<ReferenceImage>,
    pub statuses: ::protobuf::RepeatedField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportProductSetsResponse {
    fn default() -> &'a ImportProductSetsResponse {
        <ImportProductSetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImportProductSetsResponse {
    pub fn new() -> ImportProductSetsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.ReferenceImage reference_images = 1;


    pub fn get_reference_images(&self) -> &[ReferenceImage] {
        &self.reference_images
    }
    pub fn clear_reference_images(&mut self) {
        self.reference_images.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_images(&mut self, v: ::protobuf::RepeatedField<ReferenceImage>) {
        self.reference_images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reference_images(&mut self) -> &mut ::protobuf::RepeatedField<ReferenceImage> {
        &mut self.reference_images
    }

    // Take field
    pub fn take_reference_images(&mut self) -> ::protobuf::RepeatedField<ReferenceImage> {
        ::std::mem::replace(&mut self.reference_images, ::protobuf::RepeatedField::new())
    }

    // repeated .google.rpc.Status statuses = 2;


    pub fn get_statuses(&self) -> &[super::status::Status] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<super::status::Status>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::status::Status> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<super::status::Status> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ImportProductSetsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reference_images {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reference_images)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reference_images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reference_images {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.statuses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportProductSetsResponse {
        ImportProductSetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReferenceImage>>(
                "reference_images",
                |m: &ImportProductSetsResponse| { &m.reference_images },
                |m: &mut ImportProductSetsResponse| { &mut m.reference_images },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "statuses",
                |m: &ImportProductSetsResponse| { &m.statuses },
                |m: &mut ImportProductSetsResponse| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportProductSetsResponse>(
                "ImportProductSetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportProductSetsResponse {
        static instance: ::protobuf::rt::LazyV2<ImportProductSetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportProductSetsResponse::new)
    }
}

impl ::protobuf::Clear for ImportProductSetsResponse {
    fn clear(&mut self) {
        self.reference_images.clear();
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportProductSetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportProductSetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchOperationMetadata {
    // message fields
    pub state: BatchOperationMetadata_State,
    pub submit_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchOperationMetadata {
    fn default() -> &'a BatchOperationMetadata {
        <BatchOperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl BatchOperationMetadata {
    pub fn new() -> BatchOperationMetadata {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.BatchOperationMetadata.State state = 1;


    pub fn get_state(&self) -> BatchOperationMetadata_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = BatchOperationMetadata_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: BatchOperationMetadata_State) {
        self.state = v;
    }

    // .google.protobuf.Timestamp submit_time = 2;


    pub fn get_submit_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.submit_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_submit_time(&mut self) {
        self.submit_time.clear();
    }

    pub fn has_submit_time(&self) -> bool {
        self.submit_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_submit_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.submit_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_submit_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.submit_time.is_none() {
            self.submit_time.set_default();
        }
        self.submit_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_submit_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.submit_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 3;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for BatchOperationMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.submit_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.submit_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != BatchOperationMetadata_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if let Some(ref v) = self.submit_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != BatchOperationMetadata_State::STATE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let Some(ref v) = self.submit_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchOperationMetadata {
        BatchOperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BatchOperationMetadata_State>>(
                "state",
                |m: &BatchOperationMetadata| { &m.state },
                |m: &mut BatchOperationMetadata| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "submit_time",
                |m: &BatchOperationMetadata| { &m.submit_time },
                |m: &mut BatchOperationMetadata| { &mut m.submit_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &BatchOperationMetadata| { &m.end_time },
                |m: &mut BatchOperationMetadata| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchOperationMetadata>(
                "BatchOperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchOperationMetadata {
        static instance: ::protobuf::rt::LazyV2<BatchOperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchOperationMetadata::new)
    }
}

impl ::protobuf::Clear for BatchOperationMetadata {
    fn clear(&mut self) {
        self.state = BatchOperationMetadata_State::STATE_UNSPECIFIED;
        self.submit_time.clear();
        self.end_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchOperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchOperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BatchOperationMetadata_State {
    STATE_UNSPECIFIED = 0,
    PROCESSING = 1,
    SUCCESSFUL = 2,
    FAILED = 3,
    CANCELLED = 4,
}

impl ::protobuf::ProtobufEnum for BatchOperationMetadata_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BatchOperationMetadata_State> {
        match value {
            0 => ::std::option::Option::Some(BatchOperationMetadata_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(BatchOperationMetadata_State::PROCESSING),
            2 => ::std::option::Option::Some(BatchOperationMetadata_State::SUCCESSFUL),
            3 => ::std::option::Option::Some(BatchOperationMetadata_State::FAILED),
            4 => ::std::option::Option::Some(BatchOperationMetadata_State::CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BatchOperationMetadata_State] = &[
            BatchOperationMetadata_State::STATE_UNSPECIFIED,
            BatchOperationMetadata_State::PROCESSING,
            BatchOperationMetadata_State::SUCCESSFUL,
            BatchOperationMetadata_State::FAILED,
            BatchOperationMetadata_State::CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BatchOperationMetadata_State>("BatchOperationMetadata.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BatchOperationMetadata_State {
}

impl ::std::default::Default for BatchOperationMetadata_State {
    fn default() -> Self {
        BatchOperationMetadata_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchOperationMetadata_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProductSetPurgeConfig {
    // message fields
    pub product_set_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductSetPurgeConfig {
    fn default() -> &'a ProductSetPurgeConfig {
        <ProductSetPurgeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ProductSetPurgeConfig {
    pub fn new() -> ProductSetPurgeConfig {
        ::std::default::Default::default()
    }

    // string product_set_id = 1;


    pub fn get_product_set_id(&self) -> &str {
        &self.product_set_id
    }
    pub fn clear_product_set_id(&mut self) {
        self.product_set_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_set_id(&mut self, v: ::std::string::String) {
        self.product_set_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_set_id(&mut self) -> &mut ::std::string::String {
        &mut self.product_set_id
    }

    // Take field
    pub fn take_product_set_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_set_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ProductSetPurgeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_set_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.product_set_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.product_set_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.product_set_id.is_empty() {
            os.write_string(1, &self.product_set_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductSetPurgeConfig {
        ProductSetPurgeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_set_id",
                |m: &ProductSetPurgeConfig| { &m.product_set_id },
                |m: &mut ProductSetPurgeConfig| { &mut m.product_set_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductSetPurgeConfig>(
                "ProductSetPurgeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductSetPurgeConfig {
        static instance: ::protobuf::rt::LazyV2<ProductSetPurgeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductSetPurgeConfig::new)
    }
}

impl ::protobuf::Clear for ProductSetPurgeConfig {
    fn clear(&mut self) {
        self.product_set_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductSetPurgeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSetPurgeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PurgeProductsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub force: bool,
    // message oneof groups
    pub target: ::std::option::Option<PurgeProductsRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurgeProductsRequest {
    fn default() -> &'a PurgeProductsRequest {
        <PurgeProductsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PurgeProductsRequest_oneof_target {
    product_set_purge_config(ProductSetPurgeConfig),
    delete_orphan_products(bool),
}

impl PurgeProductsRequest {
    pub fn new() -> PurgeProductsRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.ProductSetPurgeConfig product_set_purge_config = 2;


    pub fn get_product_set_purge_config(&self) -> &ProductSetPurgeConfig {
        match self.target {
            ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(ref v)) => v,
            _ => <ProductSetPurgeConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_product_set_purge_config(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_product_set_purge_config(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_product_set_purge_config(&mut self, v: ProductSetPurgeConfig) {
        self.target = ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_product_set_purge_config(&mut self) -> &mut ProductSetPurgeConfig {
        if let ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(ProductSetPurgeConfig::new()));
        }
        match self.target {
            ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_product_set_purge_config(&mut self) -> ProductSetPurgeConfig {
        if self.has_product_set_purge_config() {
            match self.target.take() {
                ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ProductSetPurgeConfig::new()
        }
    }

    // bool delete_orphan_products = 3;


    pub fn get_delete_orphan_products(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(PurgeProductsRequest_oneof_target::delete_orphan_products(v)) => v,
            _ => false,
        }
    }
    pub fn clear_delete_orphan_products(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_delete_orphan_products(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(PurgeProductsRequest_oneof_target::delete_orphan_products(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_orphan_products(&mut self, v: bool) {
        self.target = ::std::option::Option::Some(PurgeProductsRequest_oneof_target::delete_orphan_products(v))
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // bool force = 4;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }
}

impl ::protobuf::Message for PurgeProductsRequest {
    fn is_initialized(&self) -> bool {
        if let Some(PurgeProductsRequest_oneof_target::product_set_purge_config(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(PurgeProductsRequest_oneof_target::product_set_purge_config(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(PurgeProductsRequest_oneof_target::delete_orphan_products(is.read_bool()?));
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.force != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &PurgeProductsRequest_oneof_target::product_set_purge_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PurgeProductsRequest_oneof_target::delete_orphan_products(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.force != false {
            os.write_bool(4, self.force)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &PurgeProductsRequest_oneof_target::product_set_purge_config(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PurgeProductsRequest_oneof_target::delete_orphan_products(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurgeProductsRequest {
        PurgeProductsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProductSetPurgeConfig>(
                "product_set_purge_config",
                PurgeProductsRequest::has_product_set_purge_config,
                PurgeProductsRequest::get_product_set_purge_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "delete_orphan_products",
                PurgeProductsRequest::has_delete_orphan_products,
                PurgeProductsRequest::get_delete_orphan_products,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &PurgeProductsRequest| { &m.parent },
                |m: &mut PurgeProductsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &PurgeProductsRequest| { &m.force },
                |m: &mut PurgeProductsRequest| { &mut m.force },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurgeProductsRequest>(
                "PurgeProductsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurgeProductsRequest {
        static instance: ::protobuf::rt::LazyV2<PurgeProductsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurgeProductsRequest::new)
    }
}

impl ::protobuf::Clear for PurgeProductsRequest {
    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.parent.clear();
        self.force = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurgeProductsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurgeProductsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n3google/cloud/vision/v1/product_search_service.proto\x12\x16google.clo\
    ud.vision.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/clien\
    t.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resourc\
    e.proto\x1a%google/cloud/vision/v1/geometry.proto\x1a#google/longrunning\
    /operations.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x20google/proto\
    buf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x17googl\
    e/rpc/status.proto\"\xf7\x02\n\x07Product\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdisplayNa\
    me\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12.\n\
    \x10product_category\x18\x04\x20\x01(\tR\x0fproductCategoryB\x03\xe0A\
    \x05\x12O\n\x0eproduct_labels\x18\x05\x20\x03(\x0b2(.google.cloud.vision\
    .v1.Product.KeyValueR\rproductLabels\x1a2\n\x08KeyValue\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:^\xeaA[\n\x1dvision.googleapis.com/Product\x12:projects/{project}/lo\
    cations/{location}/products/{product}\"\xa7\x02\n\nProductSet\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\x02\x20\
    \x01(\tR\x0bdisplayName\x12>\n\nindex_time\x18\x03\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\tindexTimeB\x03\xe0A\x03\x128\n\x0bindex_error\
    \x18\x04\x20\x01(\x0b2\x12.google.rpc.StatusR\nindexErrorB\x03\xe0A\x03:\
    h\xeaAe\n\x20vision.googleapis.com/ProductSet\x12Aprojects/{project}/loc\
    ations/{location}/productSets/{product_set}\"\x98\x02\n\x0eReferenceImag\
    e\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x15\n\x03uri\x18\x02\
    \x20\x01(\tR\x03uriB\x03\xe0A\x02\x12P\n\x0ebounding_polys\x18\x03\x20\
    \x03(\x0b2$.google.cloud.vision.v1.BoundingPolyR\rboundingPolysB\x03\xe0\
    A\x01:\x88\x01\xeaA\x84\x01\n$vision.googleapis.com/ReferenceImage\x12\\\
    projects/{project}/locations/{location}/products/{product}/referenceImag\
    es/{reference_image}\"\xb8\x01\n\x14CreateProductRequest\x12A\n\x06paren\
    t\x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.googleapis.com/Locat\
    ion\xe0A\x02\x12>\n\x07product\x18\x02\x20\x01(\x0b2\x1f.google.cloud.vi\
    sion.v1.ProductR\x07productB\x03\xe0A\x02\x12\x1d\n\nproduct_id\x18\x03\
    \x20\x01(\tR\tproductId\"\x94\x01\n\x13ListProductsRequest\x12A\n\x06par\
    ent\x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.googleapis.com/Loc\
    ation\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\
    \x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"{\n\x14ListProduc\
    tsResponse\x12;\n\x08products\x18\x01\x20\x03(\x0b2\x1f.google.cloud.vis\
    ion.v1.ProductR\x08products\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\t\
    R\rnextPageToken\"N\n\x11GetProductRequest\x129\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB%\xfaA\x1f\n\x1dvision.googleapis.com/Product\xe0A\x02\
    \"\x93\x01\n\x14UpdateProductRequest\x12>\n\x07product\x18\x01\x20\x01(\
    \x0b2\x1f.google.cloud.vision.v1.ProductR\x07productB\x03\xe0A\x02\x12;\
    \n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\n\
    updateMask\"Q\n\x14DeleteProductRequest\x129\n\x04name\x18\x01\x20\x01(\
    \tR\x04nameB%\xfaA\x1f\n\x1dvision.googleapis.com/Product\xe0A\x02\"\xcc\
    \x01\n\x17CreateProductSetRequest\x12A\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parentB)\xfaA#\n!locations.googleapis.com/Location\xe0A\x02\x12H\n\
    \x0bproduct_set\x18\x02\x20\x01(\x0b2\".google.cloud.vision.v1.ProductSe\
    tR\nproductSetB\x03\xe0A\x02\x12$\n\x0eproduct_set_id\x18\x03\x20\x01(\t\
    R\x0cproductSetId\"\x97\x01\n\x16ListProductSetsRequest\x12A\n\x06parent\
    \x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.googleapis.com/Locati\
    on\xe0A\x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\x88\x01\n\x17ListPro\
    ductSetsResponse\x12E\n\x0cproduct_sets\x18\x01\x20\x03(\x0b2\".google.c\
    loud.vision.v1.ProductSetR\x0bproductSets\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"T\n\x14GetProductSetRequest\x12<\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04nameB(\xfaA\"\n\x20vision.googleapis.com/Prod\
    uctSet\xe0A\x02\"\xa0\x01\n\x17UpdateProductSetRequest\x12H\n\x0bproduct\
    _set\x18\x01\x20\x01(\x0b2\".google.cloud.vision.v1.ProductSetR\nproduct\
    SetB\x03\xe0A\x02\x12;\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google\
    .protobuf.FieldMaskR\nupdateMask\"W\n\x17DeleteProductSetRequest\x12<\n\
    \x04name\x18\x01\x20\x01(\tR\x04nameB(\xfaA\"\n\x20vision.googleapis.com\
    /ProductSet\xe0A\x02\"\xe0\x01\n\x1bCreateReferenceImageRequest\x12=\n\
    \x06parent\x18\x01\x20\x01(\tR\x06parentB%\xfaA\x1f\n\x1dvision.googleap\
    is.com/Product\xe0A\x02\x12T\n\x0freference_image\x18\x02\x20\x01(\x0b2&\
    .google.cloud.vision.v1.ReferenceImageR\x0ereferenceImageB\x03\xe0A\x02\
    \x12,\n\x12reference_image_id\x18\x03\x20\x01(\tR\x10referenceImageId\"\
    \x97\x01\n\x1aListReferenceImagesRequest\x12=\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parentB%\xfaA\x1f\n\x1dvision.googleapis.com/Product\xe0A\
    \x02\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\np\
    age_token\x18\x03\x20\x01(\tR\tpageToken\"\xb5\x01\n\x1bListReferenceIma\
    gesResponse\x12Q\n\x10reference_images\x18\x01\x20\x03(\x0b2&.google.clo\
    ud.vision.v1.ReferenceImageR\x0freferenceImages\x12\x1b\n\tpage_size\x18\
    \x02\x20\x01(\x05R\x08pageSize\x12&\n\x0fnext_page_token\x18\x03\x20\x01\
    (\tR\rnextPageToken\"\\\n\x18GetReferenceImageRequest\x12@\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB,\xfaA&\n$vision.googleapis.com/ReferenceImage\
    \xe0A\x02\"_\n\x1bDeleteReferenceImageRequest\x12@\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB,\xfaA&\n$vision.googleapis.com/ReferenceImage\xe0A\x02\
    \"\x9e\x01\n\x1dAddProductToProductSetRequest\x12<\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB(\xfaA\"\n\x20vision.googleapis.com/ProductSet\xe0A\x02\
    \x12?\n\x07product\x18\x02\x20\x01(\tR\x07productB%\xfaA\x1f\n\x1dvision\
    .googleapis.com/Product\xe0A\x02\"\xa3\x01\n\"RemoveProductFromProductSe\
    tRequest\x12<\n\x04name\x18\x01\x20\x01(\tR\x04nameB(\xfaA\"\n\x20vision\
    .googleapis.com/ProductSet\xe0A\x02\x12?\n\x07product\x18\x02\x20\x01(\t\
    R\x07productB%\xfaA\x1f\n\x1dvision.googleapis.com/Product\xe0A\x02\"\
    \x9b\x01\n\x1fListProductsInProductSetRequest\x12<\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB(\xfaA\"\n\x20vision.googleapis.com/ProductSet\xe0A\x02\
    \x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_\
    token\x18\x03\x20\x01(\tR\tpageToken\"\x87\x01\n\x20ListProductsInProduc\
    tSetResponse\x12;\n\x08products\x18\x01\x20\x03(\x0b2\x1f.google.cloud.v\
    ision.v1.ProductR\x08products\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\
    \tR\rnextPageToken\">\n\x1aImportProductSetsGcsSource\x12\x20\n\x0ccsv_f\
    ile_uri\x18\x01\x20\x01(\tR\ncsvFileUri\"}\n\x1cImportProductSetsInputCo\
    nfig\x12S\n\ngcs_source\x18\x01\x20\x01(\x0b22.google.cloud.vision.v1.Im\
    portProductSetsGcsSourceH\0R\tgcsSourceB\x08\n\x06source\"\xbb\x01\n\x18\
    ImportProductSetsRequest\x12A\n\x06parent\x18\x01\x20\x01(\tR\x06parentB\
    )\xfaA#\n!locations.googleapis.com/Location\xe0A\x02\x12\\\n\x0cinput_co\
    nfig\x18\x02\x20\x01(\x0b24.google.cloud.vision.v1.ImportProductSetsInpu\
    tConfigR\x0binputConfigB\x03\xe0A\x02\"\x9e\x01\n\x19ImportProductSetsRe\
    sponse\x12Q\n\x10reference_images\x18\x01\x20\x03(\x0b2&.google.cloud.vi\
    sion.v1.ReferenceImageR\x0freferenceImages\x12.\n\x08statuses\x18\x02\
    \x20\x03(\x0b2\x12.google.rpc.StatusR\x08statuses\"\xb3\x02\n\x16BatchOp\
    erationMetadata\x12J\n\x05state\x18\x01\x20\x01(\x0e24.google.cloud.visi\
    on.v1.BatchOperationMetadata.StateR\x05state\x12;\n\x0bsubmit_time\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nsubmitTime\x125\n\x08\
    end_time\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\
    \"Y\n\x05State\x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\x0e\n\nPROCESSIN\
    G\x10\x01\x12\x0e\n\nSUCCESSFUL\x10\x02\x12\n\n\x06FAILED\x10\x03\x12\r\
    \n\tCANCELLED\x10\x04\"=\n\x15ProductSetPurgeConfig\x12$\n\x0eproduct_se\
    t_id\x18\x01\x20\x01(\tR\x0cproductSetId\"\x9b\x02\n\x14PurgeProductsReq\
    uest\x12h\n\x18product_set_purge_config\x18\x02\x20\x01(\x0b2-.google.cl\
    oud.vision.v1.ProductSetPurgeConfigH\0R\x15productSetPurgeConfig\x126\n\
    \x16delete_orphan_products\x18\x03\x20\x01(\x08H\0R\x14deleteOrphanProdu\
    cts\x12A\n\x06parent\x18\x01\x20\x01(\tR\x06parentB)\xfaA#\n!locations.g\
    oogleapis.com/Location\xe0A\x02\x12\x14\n\x05force\x18\x04\x20\x01(\x08R\
    \x05forceB\x08\n\x06target2\xf4\x1d\n\rProductSearch\x12\xd1\x01\n\x10Cr\
    eateProductSet\x12/.google.cloud.vision.v1.CreateProductSetRequest\x1a\"\
    .google.cloud.vision.v1.ProductSet\"h\x82\xd3\xe4\x93\x02>\"//v1/{parent\
    =projects/*/locations/*}/productSets:\x0bproduct_set\xdaA!parent,product\
    _set,product_set_id\x12\xb4\x01\n\x0fListProductSets\x12..google.cloud.v\
    ision.v1.ListProductSetsRequest\x1a/.google.cloud.vision.v1.ListProductS\
    etsResponse\"@\x82\xd3\xe4\x93\x021\x12//v1/{parent=projects/*/locations\
    /*}/productSets\xdaA\x06parent\x12\xa1\x01\n\rGetProductSet\x12,.google.\
    cloud.vision.v1.GetProductSetRequest\x1a\".google.cloud.vision.v1.Produc\
    tSet\">\x82\xd3\xe4\x93\x021\x12//v1/{name=projects/*/locations/*/produc\
    tSets/*}\xdaA\x04name\x12\xd3\x01\n\x10UpdateProductSet\x12/.google.clou\
    d.vision.v1.UpdateProductSetRequest\x1a\".google.cloud.vision.v1.Product\
    Set\"j\x82\xd3\xe4\x93\x02J2;/v1/{product_set.name=projects/*/locations/\
    */productSets/*}:\x0bproduct_set\xdaA\x17product_set,update_mask\x12\x9b\
    \x01\n\x10DeleteProductSet\x12/.google.cloud.vision.v1.DeleteProductSetR\
    equest\x1a\x16.google.protobuf.Empty\">\x82\xd3\xe4\x93\x021*//v1/{name=\
    projects/*/locations/*/productSets/*}\xdaA\x04name\x12\xb9\x01\n\rCreate\
    Product\x12,.google.cloud.vision.v1.CreateProductRequest\x1a\x1f.google.\
    cloud.vision.v1.Product\"Y\x82\xd3\xe4\x93\x027\",/v1/{parent=projects/*\
    /locations/*}/products:\x07product\xdaA\x19parent,product,product_id\x12\
    \xa8\x01\n\x0cListProducts\x12+.google.cloud.vision.v1.ListProductsReque\
    st\x1a,.google.cloud.vision.v1.ListProductsResponse\"=\x82\xd3\xe4\x93\
    \x02.\x12,/v1/{parent=projects/*/locations/*}/products\xdaA\x06parent\
    \x12\x95\x01\n\nGetProduct\x12).google.cloud.vision.v1.GetProductRequest\
    \x1a\x1f.google.cloud.vision.v1.Product\";\x82\xd3\xe4\x93\x02.\x12,/v1/\
    {name=projects/*/locations/*/products/*}\xdaA\x04name\x12\xbb\x01\n\rUpd\
    ateProduct\x12,.google.cloud.vision.v1.UpdateProductRequest\x1a\x1f.goog\
    le.cloud.vision.v1.Product\"[\x82\xd3\xe4\x93\x02?24/v1/{product.name=pr\
    ojects/*/locations/*/products/*}:\x07product\xdaA\x13product,update_mask\
    \x12\x92\x01\n\rDeleteProduct\x12,.google.cloud.vision.v1.DeleteProductR\
    equest\x1a\x16.google.protobuf.Empty\";\x82\xd3\xe4\x93\x02.*,/v1/{name=\
    projects/*/locations/*/products/*}\xdaA\x04name\x12\xf9\x01\n\x14CreateR\
    eferenceImage\x123.google.cloud.vision.v1.CreateReferenceImageRequest\
    \x1a&.google.cloud.vision.v1.ReferenceImage\"\x83\x01\x82\xd3\xe4\x93\
    \x02Q\">/v1/{parent=projects/*/locations/*/products/*}/referenceImages:\
    \x0freference_image\xdaA)parent,reference_image,reference_image_id\x12\
    \xb2\x01\n\x14DeleteReferenceImage\x123.google.cloud.vision.v1.DeleteRef\
    erenceImageRequest\x1a\x16.google.protobuf.Empty\"M\x82\xd3\xe4\x93\x02@\
    *>/v1/{name=projects/*/locations/*/products/*/referenceImages/*}\xdaA\
    \x04name\x12\xcf\x01\n\x13ListReferenceImages\x122.google.cloud.vision.v\
    1.ListReferenceImagesRequest\x1a3.google.cloud.vision.v1.ListReferenceIm\
    agesResponse\"O\x82\xd3\xe4\x93\x02@\x12>/v1/{parent=projects/*/location\
    s/*/products/*}/referenceImages\xdaA\x06parent\x12\xbc\x01\n\x11GetRefer\
    enceImage\x120.google.cloud.vision.v1.GetReferenceImageRequest\x1a&.goog\
    le.cloud.vision.v1.ReferenceImage\"M\x82\xd3\xe4\x93\x02@\x12>/v1/{name=\
    projects/*/locations/*/products/*/referenceImages/*}\xdaA\x04name\x12\
    \xbd\x01\n\x16AddProductToProductSet\x125.google.cloud.vision.v1.AddProd\
    uctToProductSetRequest\x1a\x16.google.protobuf.Empty\"T\x82\xd3\xe4\x93\
    \x02?\":/v1/{name=projects/*/locations/*/productSets/*}:addProduct:\x01*\
    \xdaA\x0cname,product\x12\xca\x01\n\x1bRemoveProductFromProductSet\x12:.\
    google.cloud.vision.v1.RemoveProductFromProductSetRequest\x1a\x16.google\
    .protobuf.Empty\"W\x82\xd3\xe4\x93\x02B\"=/v1/{name=projects/*/locations\
    /*/productSets/*}:removeProduct:\x01*\xdaA\x0cname,product\x12\xd6\x01\n\
    \x18ListProductsInProductSet\x127.google.cloud.vision.v1.ListProductsInP\
    roductSetRequest\x1a8.google.cloud.vision.v1.ListProductsInProductSetRes\
    ponse\"G\x82\xd3\xe4\x93\x02:\x128/v1/{name=projects/*/locations/*/produ\
    ctSets/*}/products\xdaA\x04name\x12\xf4\x01\n\x11ImportProductSets\x120.\
    google.cloud.vision.v1.ImportProductSetsRequest\x1a\x1d.google.longrunni\
    ng.Operation\"\x8d\x01\xcaA3\n\x19ImportProductSetsResponse\x12\x16Batch\
    OperationMetadata\x82\xd3\xe4\x93\x02;\"6/v1/{parent=projects/*/location\
    s/*}/productSets:import:\x01*\xdaA\x13parent,input_config\x12\xd6\x01\n\
    \rPurgeProducts\x12,.google.cloud.vision.v1.PurgeProductsRequest\x1a\x1d\
    .google.longrunning.Operation\"x\xcaA/\n\x15google.protobuf.Empty\x12\
    \x16BatchOperationMetadata\x82\xd3\xe4\x93\x027\"2/v1/{parent=projects/*\
    /locations/*}/products:purge:\x01*\xdaA\x06parent\x1av\xd2A[https://www.\
    googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/cloud\
    -vision\xcaA\x15vision.googleapis.comB\x81\x01\n\x1acom.google.cloud.vis\
    ion.v1B\x19ProductSearchServiceProtoP\x01Z<google.golang.org/genproto/go\
    ogleapis/cloud/vision/v1;vision\xf8\x01\x01\xa2\x02\x04GCVNJ\x8e\xfe\x01\
    \n\x07\x12\x05\x0f\0\x81\x08\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\
    \xb3\x04\x20Copyright\x202019\x20Google\x20LLC.\n\n\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compli\
    ance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\
    \x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.\
    org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\
    \x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distrib\
    uted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\
    \x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\n\x08\n\
    \x01\x02\x12\x03\x11\0\x1f\n\t\n\x02\x03\0\x12\x03\x13\0&\n\t\n\x02\x03\
    \x01\x12\x03\x14\0!\n\t\n\x02\x03\x02\x12\x03\x15\0)\n\t\n\x02\x03\x03\
    \x12\x03\x16\0#\n\t\n\x02\x03\x04\x12\x03\x17\0/\n\t\n\x02\x03\x05\x12\
    \x03\x18\0-\n\t\n\x02\x03\x06\x12\x03\x19\0%\n\t\n\x02\x03\x07\x12\x03\
    \x1a\0*\n\t\n\x02\x03\x08\x12\x03\x1b\0)\n\t\n\x02\x03\t\x12\x03\x1c\0!\
    \n\x08\n\x01\x08\x12\x03\x1e\0\x1f\n\t\n\x02\x08\x1f\x12\x03\x1e\0\x1f\n\
    \x08\n\x01\x08\x12\x03\x1f\0S\n\t\n\x02\x08\x0b\x12\x03\x1f\0S\n\x08\n\
    \x01\x08\x12\x03\x20\0\"\n\t\n\x02\x08\n\x12\x03\x20\0\"\n\x08\n\x01\x08\
    \x12\x03!\0:\n\t\n\x02\x08\x08\x12\x03!\0:\n\x08\n\x01\x08\x12\x03\"\03\
    \n\t\n\x02\x08\x01\x12\x03\"\03\n\x08\n\x01\x08\x12\x03#\0\"\n\t\n\x02\
    \x08$\x12\x03#\0\"\n\xbe\x05\n\x02\x06\0\x12\x053\0\xea\x02\x01\x1a\xb0\
    \x05\x20Manages\x20Products\x20and\x20ProductSets\x20of\x20reference\x20\
    images\x20for\x20use\x20in\x20product\n\x20search.\x20It\x20uses\x20the\
    \x20following\x20resource\x20model:\n\n\x20-\x20The\x20API\x20has\x20a\
    \x20collection\x20of\x20[ProductSet][google.cloud.vision.v1.ProductSet]\
    \x20resources,\x20named\n\x20`projects/*/locations/*/productSets/*`,\x20\
    which\x20acts\x20as\x20a\x20way\x20to\x20put\x20different\n\x20products\
    \x20into\x20groups\x20to\x20limit\x20identification.\n\n\x20In\x20parall\
    el,\n\n\x20-\x20The\x20API\x20has\x20a\x20collection\x20of\x20[Product][\
    google.cloud.vision.v1.Product]\x20resources,\x20named\n\x20\x20\x20`pro\
    jects/*/locations/*/products/*`\n\n\x20-\x20Each\x20[Product][google.clo\
    ud.vision.v1.Product]\x20has\x20a\x20collection\x20of\x20[ReferenceImage\
    ][google.cloud.vision.v1.ReferenceImage]\x20resources,\x20named\n\x20\
    \x20\x20`projects/*/locations/*/products/*/referenceImages/*`\n\n\n\n\
    \x03\x06\0\x01\x12\x033\x08\x15\n\n\n\x03\x06\0\x03\x12\x034\x02=\n\x0c\
    \n\x05\x06\0\x03\x99\x08\x12\x034\x02=\n\x0b\n\x03\x06\0\x03\x12\x045\
    \x0275\n\r\n\x05\x06\0\x03\x9a\x08\x12\x045\x0275\n\xb1\x01\n\x04\x06\0\
    \x02\0\x12\x04?\x02E\x03\x1a\xa2\x01\x20Creates\x20and\x20returns\x20a\
    \x20new\x20ProductSet\x20resource.\n\n\x20Possible\x20errors:\n\n\x20*\
    \x20Returns\x20INVALID_ARGUMENT\x20if\x20display_name\x20is\x20missing,\
    \x20or\x20is\x20longer\x20than\n\x20\x20\x204096\x20characters.\n\n\x0c\
    \n\x05\x06\0\x02\0\x01\x12\x03?\x06\x16\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x03?\x17.\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03?9C\n\r\n\x05\x06\0\x02\0\
    \x04\x12\x04@\x04C\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04@\
    \x04C\x06\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03D\x04O\n\x0f\n\x08\x06\0\
    \x02\0\x04\x9b\x08\0\x12\x03D\x04O\n\xa0\x01\n\x04\x06\0\x02\x01\x12\x04\
    M\x02R\x03\x1a\x91\x01\x20Lists\x20ProductSets\x20in\x20an\x20unspecifie\
    d\x20order.\n\n\x20Possible\x20errors:\n\n\x20*\x20Returns\x20INVALID_AR\
    GUMENT\x20if\x20page_size\x20is\x20greater\x20than\x20100,\x20or\x20less\
    \n\x20\x20\x20than\x201.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03M\x06\
    \x15\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03M\x16,\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03M7N\n\r\n\x05\x06\0\x02\x01\x04\x12\x04N\x04P\x06\n\x11\
    \n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04N\x04P\x06\n\x0c\n\x05\x06\0\
    \x02\x01\x04\x12\x03Q\x044\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\
    \x03Q\x044\n\x89\x01\n\x04\x06\0\x02\x02\x12\x04Y\x02^\x03\x1a{\x20Gets\
    \x20information\x20associated\x20with\x20a\x20ProductSet.\n\n\x20Possibl\
    e\x20errors:\n\n\x20*\x20Returns\x20NOT_FOUND\x20if\x20the\x20ProductSet\
    \x20does\x20not\x20exist.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03Y\x06\
    \x13\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03Y\x14(\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03Y3=\n\r\n\x05\x06\0\x02\x02\x04\x12\x04Z\x04\\\x06\n\x11\
    \n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04Z\x04\\\x06\n\x0c\n\x05\x06\
    \0\x02\x02\x04\x12\x03]\x042\n\x0f\n\x08\x06\0\x02\x02\x04\x9b\x08\0\x12\
    \x03]\x042\n\xb6\x02\n\x04\x06\0\x02\x03\x12\x04h\x02n\x03\x1a\xa7\x02\
    \x20Makes\x20changes\x20to\x20a\x20ProductSet\x20resource.\n\x20Only\x20\
    display_name\x20can\x20be\x20updated\x20currently.\n\n\x20Possible\x20er\
    rors:\n\n\x20*\x20Returns\x20NOT_FOUND\x20if\x20the\x20ProductSet\x20doe\
    s\x20not\x20exist.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20displa\
    y_name\x20is\x20present\x20in\x20update_mask\x20but\n\x20\x20\x20missing\
    \x20from\x20the\x20request\x20or\x20longer\x20than\x204096\x20characters\
    .\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03h\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x03\x02\x12\x03h\x17.\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03h9C\n\r\n\
    \x05\x06\0\x02\x03\x04\x12\x04i\x04l\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\
    \xca\xbc\"\x12\x04i\x04l\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03m\x04E\
    \n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03m\x04E\n\xb7\x01\n\x04\
    \x06\0\x02\x04\x12\x04t\x02y\x03\x1a\xa8\x01\x20Permanently\x20deletes\
    \x20a\x20ProductSet.\x20Products\x20and\x20ReferenceImages\x20in\x20the\
    \n\x20ProductSet\x20are\x20not\x20deleted.\n\n\x20The\x20actual\x20image\
    \x20files\x20are\x20not\x20deleted\x20from\x20Google\x20Cloud\x20Storage\
    .\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03t\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x04\x02\x12\x03t\x17.\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03t9N\n\r\n\
    \x05\x06\0\x02\x04\x04\x12\x04u\x04w\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\
    \xca\xbc\"\x12\x04u\x04w\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03x\x042\
    \n\x0f\n\x08\x06\0\x02\x04\x04\x9b\x08\0\x12\x03x\x042\n\xbe\x02\n\x04\
    \x06\0\x02\x05\x12\x06\x83\x01\x02\x89\x01\x03\x1a\xad\x02\x20Creates\
    \x20and\x20returns\x20a\x20new\x20product\x20resource.\n\n\x20Possible\
    \x20errors:\n\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20display_nam\
    e\x20is\x20missing\x20or\x20longer\x20than\x204096\n\x20\x20\x20characte\
    rs.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20description\x20is\x20\
    longer\x20than\x204096\x20characters.\n\x20*\x20Returns\x20INVALID_ARGUM\
    ENT\x20if\x20product_category\x20is\x20missing\x20or\x20invalid.\n\n\r\n\
    \x05\x06\0\x02\x05\x01\x12\x04\x83\x01\x06\x13\n\r\n\x05\x06\0\x02\x05\
    \x02\x12\x04\x83\x01\x14(\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x83\x013:\
    \n\x0f\n\x05\x06\0\x02\x05\x04\x12\x06\x84\x01\x04\x87\x01\x06\n\x13\n\t\
    \x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x06\x84\x01\x04\x87\x01\x06\n\r\n\
    \x05\x06\0\x02\x05\x04\x12\x04\x88\x01\x04G\n\x10\n\x08\x06\0\x02\x05\
    \x04\x9b\x08\0\x12\x04\x88\x01\x04G\n\x9b\x01\n\x04\x06\0\x02\x06\x12\
    \x06\x90\x01\x02\x95\x01\x03\x1a\x8a\x01\x20Lists\x20products\x20in\x20a\
    n\x20unspecified\x20order.\n\n\x20Possible\x20errors:\n\n\x20*\x20Return\
    s\x20INVALID_ARGUMENT\x20if\x20page_size\x20is\x20greater\x20than\x20100\
    \x20or\x20less\x20than\x201.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x90\
    \x01\x06\x12\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x90\x01\x13&\n\r\n\x05\
    \x06\0\x02\x06\x03\x12\x04\x90\x011E\n\x0f\n\x05\x06\0\x02\x06\x04\x12\
    \x06\x91\x01\x04\x93\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\
    \x12\x06\x91\x01\x04\x93\x01\x06\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x94\
    \x01\x044\n\x10\n\x08\x06\0\x02\x06\x04\x9b\x08\0\x12\x04\x94\x01\x044\n\
    \x85\x01\n\x04\x06\0\x02\x07\x12\x06\x9c\x01\x02\xa1\x01\x03\x1au\x20Get\
    s\x20information\x20associated\x20with\x20a\x20Product.\n\n\x20Possible\
    \x20errors:\n\n\x20*\x20Returns\x20NOT_FOUND\x20if\x20the\x20Product\x20\
    does\x20not\x20exist.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x9c\x01\x06\
    \x10\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x9c\x01\x11\"\n\r\n\x05\x06\0\
    \x02\x07\x03\x12\x04\x9c\x01-4\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x9d\
    \x01\x04\x9f\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\
    \x9d\x01\x04\x9f\x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa0\x01\x04\
    2\n\x10\n\x08\x06\0\x02\x07\x04\x9b\x08\0\x12\x04\xa0\x01\x042\n\xf8\x04\
    \n\x04\x06\0\x02\x08\x12\x06\xb2\x01\x02\xb8\x01\x03\x1a\xe7\x04\x20Make\
    s\x20changes\x20to\x20a\x20Product\x20resource.\n\x20Only\x20the\x20`dis\
    play_name`,\x20`description`,\x20and\x20`labels`\x20fields\x20can\x20be\
    \x20updated\n\x20right\x20now.\n\n\x20If\x20labels\x20are\x20updated,\
    \x20the\x20change\x20will\x20not\x20be\x20reflected\x20in\x20queries\x20\
    until\n\x20the\x20next\x20index\x20time.\n\n\x20Possible\x20errors:\n\n\
    \x20*\x20Returns\x20NOT_FOUND\x20if\x20the\x20Product\x20does\x20not\x20\
    exist.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20display_name\x20is\
    \x20present\x20in\x20update_mask\x20but\x20is\n\x20\x20\x20missing\x20fr\
    om\x20the\x20request\x20or\x20longer\x20than\x204096\x20characters.\n\
    \x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20description\x20is\x20prese\
    nt\x20in\x20update_mask\x20but\x20is\n\x20\x20\x20longer\x20than\x204096\
    \x20characters.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20product_c\
    ategory\x20is\x20present\x20in\x20update_mask.\n\n\r\n\x05\x06\0\x02\x08\
    \x01\x12\x04\xb2\x01\x06\x13\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\xb2\x01\
    \x14(\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\xb2\x013:\n\x0f\n\x05\x06\0\
    \x02\x08\x04\x12\x06\xb3\x01\x04\xb6\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\
    \xb0\xca\xbc\"\x12\x06\xb3\x01\x04\xb6\x01\x06\n\r\n\x05\x06\0\x02\x08\
    \x04\x12\x04\xb7\x01\x04A\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\
    \x04\xb7\x01\x04A\n\x8a\x02\n\x04\x06\0\x02\t\x12\x06\xbf\x01\x02\xc4\
    \x01\x03\x1a\xf9\x01\x20Permanently\x20deletes\x20a\x20product\x20and\
    \x20its\x20reference\x20images.\n\n\x20Metadata\x20of\x20the\x20product\
    \x20and\x20all\x20its\x20images\x20will\x20be\x20deleted\x20right\x20awa\
    y,\x20but\n\x20search\x20queries\x20against\x20ProductSets\x20containing\
    \x20the\x20product\x20may\x20still\x20work\n\x20until\x20all\x20related\
    \x20caches\x20are\x20refreshed.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xbf\
    \x01\x06\x13\n\r\n\x05\x06\0\x02\t\x02\x12\x04\xbf\x01\x14(\n\r\n\x05\
    \x06\0\x02\t\x03\x12\x04\xbf\x013H\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\
    \xc0\x01\x04\xc2\x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\
    \xc0\x01\x04\xc2\x01\x06\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc3\x01\x042\
    \n\x10\n\x08\x06\0\x02\t\x04\x9b\x08\0\x12\x04\xc3\x01\x042\n\xfb\x06\n\
    \x04\x06\0\x02\n\x12\x06\xd9\x01\x02\xdf\x01\x03\x1a\xea\x06\x20Creates\
    \x20and\x20returns\x20a\x20new\x20ReferenceImage\x20resource.\n\n\x20The\
    \x20`bounding_poly`\x20field\x20is\x20optional.\x20If\x20`bounding_poly`\
    \x20is\x20not\x20specified,\n\x20the\x20system\x20will\x20try\x20to\x20d\
    etect\x20regions\x20of\x20interest\x20in\x20the\x20image\x20that\x20are\
    \n\x20compatible\x20with\x20the\x20product_category\x20on\x20the\x20pare\
    nt\x20product.\x20If\x20it\x20is\n\x20specified,\x20detection\x20is\x20A\
    LWAYS\x20skipped.\x20The\x20system\x20converts\x20polygons\x20into\n\x20\
    non-rotated\x20rectangles.\n\n\x20Note\x20that\x20the\x20pipeline\x20wil\
    l\x20resize\x20the\x20image\x20if\x20the\x20image\x20resolution\x20is\
    \x20too\n\x20large\x20to\x20process\x20(above\x2050MP).\n\n\x20Possible\
    \x20errors:\n\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20the\x20imag\
    e_uri\x20is\x20missing\x20or\x20longer\x20than\x204096\n\x20\x20\x20char\
    acters.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20the\x20product\
    \x20does\x20not\x20exist.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\
    \x20bounding_poly\x20is\x20not\x20provided,\x20and\x20nothing\n\x20\x20\
    \x20compatible\x20with\x20the\x20parent\x20product's\x20product_category\
    \x20is\x20detected.\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20bound\
    ing_poly\x20contains\x20more\x20than\x2010\x20polygons.\n\n\r\n\x05\x06\
    \0\x02\n\x01\x12\x04\xd9\x01\x06\x1a\n\r\n\x05\x06\0\x02\n\x02\x12\x04\
    \xd9\x01\x1b6\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xd9\x01AO\n\x0f\n\x05\
    \x06\0\x02\n\x04\x12\x06\xda\x01\x04\xdd\x01\x06\n\x13\n\t\x06\0\x02\n\
    \x04\xb0\xca\xbc\"\x12\x06\xda\x01\x04\xdd\x01\x06\n\r\n\x05\x06\0\x02\n\
    \x04\x12\x04\xde\x01\x04W\n\x10\n\x08\x06\0\x02\n\x04\x9b\x08\0\x12\x04\
    \xde\x01\x04W\n\xa3\x02\n\x04\x06\0\x02\x0b\x12\x06\xe8\x01\x02\xed\x01\
    \x03\x1a\x92\x02\x20Permanently\x20deletes\x20a\x20reference\x20image.\n\
    \n\x20The\x20image\x20metadata\x20will\x20be\x20deleted\x20right\x20away\
    ,\x20but\x20search\x20queries\n\x20against\x20ProductSets\x20containing\
    \x20the\x20image\x20may\x20still\x20work\x20until\x20all\x20related\n\
    \x20caches\x20are\x20refreshed.\n\n\x20The\x20actual\x20image\x20files\
    \x20are\x20not\x20deleted\x20from\x20Google\x20Cloud\x20Storage.\n\n\r\n\
    \x05\x06\0\x02\x0b\x01\x12\x04\xe8\x01\x06\x1a\n\r\n\x05\x06\0\x02\x0b\
    \x02\x12\x04\xe8\x01\x1b6\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xe8\x01AV\
    \n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xe9\x01\x04\xeb\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xe9\x01\x04\xeb\x01\x06\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xec\x01\x042\n\x10\n\x08\x06\0\x02\x0b\
    \x04\x9b\x08\0\x12\x04\xec\x01\x042\n\xce\x01\n\x04\x06\0\x02\x0c\x12\
    \x06\xf6\x01\x02\xfb\x01\x03\x1a\xbd\x01\x20Lists\x20reference\x20images\
    .\n\n\x20Possible\x20errors:\n\n\x20*\x20Returns\x20NOT_FOUND\x20if\x20t\
    he\x20parent\x20product\x20does\x20not\x20exist.\n\x20*\x20Returns\x20IN\
    VALID_ARGUMENT\x20if\x20the\x20page_size\x20is\x20greater\x20than\x20100\
    ,\x20or\x20less\n\x20\x20\x20than\x201.\n\n\r\n\x05\x06\0\x02\x0c\x01\
    \x12\x04\xf6\x01\x06\x19\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xf6\x01\x1a\
    4\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\xf6\x01?Z\n\x0f\n\x05\x06\0\x02\
    \x0c\x04\x12\x06\xf7\x01\x04\xf9\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\
    \xca\xbc\"\x12\x06\xf7\x01\x04\xf9\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\
    \x12\x04\xfa\x01\x044\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\x04\
    \xfa\x01\x044\n\x95\x01\n\x04\x06\0\x02\r\x12\x06\x82\x02\x02\x87\x02\
    \x03\x1a\x84\x01\x20Gets\x20information\x20associated\x20with\x20a\x20Re\
    ferenceImage.\n\n\x20Possible\x20errors:\n\n\x20*\x20Returns\x20NOT_FOUN\
    D\x20if\x20the\x20specified\x20image\x20does\x20not\x20exist.\n\n\r\n\
    \x05\x06\0\x02\r\x01\x12\x04\x82\x02\x06\x17\n\r\n\x05\x06\0\x02\r\x02\
    \x12\x04\x82\x02\x180\n\r\n\x05\x06\0\x02\r\x03\x12\x04\x82\x02;I\n\x0f\
    \n\x05\x06\0\x02\r\x04\x12\x06\x83\x02\x04\x85\x02\x06\n\x13\n\t\x06\0\
    \x02\r\x04\xb0\xca\xbc\"\x12\x06\x83\x02\x04\x85\x02\x06\n\r\n\x05\x06\0\
    \x02\r\x04\x12\x04\x86\x02\x042\n\x10\n\x08\x06\0\x02\r\x04\x9b\x08\0\
    \x12\x04\x86\x02\x042\n\x85\x02\n\x04\x06\0\x02\x0e\x12\x06\x91\x02\x02\
    \x97\x02\x03\x1a\xf4\x01\x20Adds\x20a\x20Product\x20to\x20the\x20specifi\
    ed\x20ProductSet.\x20If\x20the\x20Product\x20is\x20already\n\x20present,\
    \x20no\x20change\x20is\x20made.\n\n\x20One\x20Product\x20can\x20be\x20ad\
    ded\x20to\x20at\x20most\x20100\x20ProductSets.\n\n\x20Possible\x20errors\
    :\n\n\x20*\x20Returns\x20NOT_FOUND\x20if\x20the\x20Product\x20or\x20the\
    \x20ProductSet\x20doesn't\x20exist.\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\
    \x04\x91\x02\x06\x1c\n\r\n\x05\x06\0\x02\x0e\x02\x12\x04\x91\x02\x1d:\n\
    \r\n\x05\x06\0\x02\x0e\x03\x12\x04\x91\x02EZ\n\x0f\n\x05\x06\0\x02\x0e\
    \x04\x12\x06\x92\x02\x04\x95\x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\
    \xbc\"\x12\x06\x92\x02\x04\x95\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\
    \x04\x96\x02\x04:\n\x10\n\x08\x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\x96\
    \x02\x04:\nB\n\x04\x06\0\x02\x0f\x12\x06\x9a\x02\x02\xa0\x02\x03\x1a2\
    \x20Removes\x20a\x20Product\x20from\x20the\x20specified\x20ProductSet.\n\
    \n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\x9a\x02\x06!\n\r\n\x05\x06\0\x02\
    \x0f\x02\x12\x04\x9a\x02\"D\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x9a\x02O\
    d\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\x9b\x02\x04\x9e\x02\x06\n\x13\n\
    \t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\x9b\x02\x04\x9e\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\x9f\x02\x04:\n\x10\n\x08\x06\0\x02\x0f\
    \x04\x9b\x08\0\x12\x04\x9f\x02\x04:\n\x86\x02\n\x04\x06\0\x02\x10\x12\
    \x06\xa9\x02\x02\xae\x02\x03\x1a\xf5\x01\x20Lists\x20the\x20Products\x20\
    in\x20a\x20ProductSet,\x20in\x20an\x20unspecified\x20order.\x20If\x20the\
    \n\x20ProductSet\x20does\x20not\x20exist,\x20the\x20products\x20field\
    \x20of\x20the\x20response\x20will\x20be\n\x20empty.\n\n\x20Possible\x20e\
    rrors:\n\n\x20*\x20Returns\x20INVALID_ARGUMENT\x20if\x20page_size\x20is\
    \x20greater\x20than\x20100\x20or\x20less\x20than\x201.\n\n\r\n\x05\x06\0\
    \x02\x10\x01\x12\x04\xa9\x02\x06\x1e\n\r\n\x05\x06\0\x02\x10\x02\x12\x04\
    \xa9\x02\x1f>\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xa9\x02Ii\n\x0f\n\x05\
    \x06\0\x02\x10\x04\x12\x06\xaa\x02\x04\xac\x02\x06\n\x13\n\t\x06\0\x02\
    \x10\x04\xb0\xca\xbc\"\x12\x06\xaa\x02\x04\xac\x02\x06\n\r\n\x05\x06\0\
    \x02\x10\x04\x12\x04\xad\x02\x042\n\x10\n\x08\x06\0\x02\x10\x04\x9b\x08\
    \0\x12\x04\xad\x02\x042\n\x84\x05\n\x04\x06\0\x02\x11\x12\x06\xbb\x02\
    \x02\xc5\x02\x03\x1a\xf3\x04\x20Asynchronous\x20API\x20that\x20imports\
    \x20a\x20list\x20of\x20reference\x20images\x20to\x20specified\n\x20produ\
    ct\x20sets\x20based\x20on\x20a\x20list\x20of\x20image\x20information.\n\
    \n\x20The\x20[google.longrunning.Operation][google.longrunning.Operation\
    ]\x20API\x20can\x20be\x20used\x20to\x20keep\x20track\x20of\x20the\n\x20p\
    rogress\x20and\x20results\x20of\x20the\x20request.\n\x20`Operation.metad\
    ata`\x20contains\x20`BatchOperationMetadata`.\x20(progress)\n\x20`Operat\
    ion.response`\x20contains\x20`ImportProductSetsResponse`.\x20(results)\n\
    \n\x20The\x20input\x20source\x20of\x20this\x20method\x20is\x20a\x20csv\
    \x20file\x20on\x20Google\x20Cloud\x20Storage.\n\x20For\x20the\x20format\
    \x20of\x20the\x20csv\x20file\x20please\x20see\n\x20[ImportProductSetsGcs\
    Source.csv_file_uri][google.cloud.vision.v1.ImportProductSetsGcsSource.c\
    sv_file_uri].\n\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xbb\x02\x06\x17\n\r\
    \n\x05\x06\0\x02\x11\x02\x12\x04\xbb\x02\x180\n\r\n\x05\x06\0\x02\x11\
    \x03\x12\x04\xbb\x02;W\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\xbc\x02\x04\
    \xbf\x02\x06\n\x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xbc\x02\
    \x04\xbf\x02\x06\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc0\x02\x04A\n\x10\
    \n\x08\x06\0\x02\x11\x04\x9b\x08\0\x12\x04\xc0\x02\x04A\n\x0f\n\x05\x06\
    \0\x02\x11\x04\x12\x06\xc1\x02\x04\xc4\x02\x06\n\x11\n\x07\x06\0\x02\x11\
    \x04\x99\x08\x12\x06\xc1\x02\x04\xc4\x02\x06\n\xea\t\n\x04\x06\0\x02\x12\
    \x12\x06\xdf\x02\x02\xe9\x02\x03\x1a\xd9\t\x20Asynchronous\x20API\x20to\
    \x20delete\x20all\x20Products\x20in\x20a\x20ProductSet\x20or\x20all\x20P\
    roducts\n\x20that\x20are\x20in\x20no\x20ProductSet.\n\n\x20If\x20a\x20Pr\
    oduct\x20is\x20a\x20member\x20of\x20the\x20specified\x20ProductSet\x20in\
    \x20addition\x20to\x20other\n\x20ProductSets,\x20the\x20Product\x20will\
    \x20still\x20be\x20deleted.\n\n\x20It\x20is\x20recommended\x20to\x20not\
    \x20delete\x20the\x20specified\x20ProductSet\x20until\x20after\x20this\n\
    \x20operation\x20has\x20completed.\x20It\x20is\x20also\x20recommended\
    \x20to\x20not\x20add\x20any\x20of\x20the\n\x20Products\x20involved\x20in\
    \x20the\x20batch\x20delete\x20to\x20a\x20new\x20ProductSet\x20while\x20t\
    his\n\x20operation\x20is\x20running\x20because\x20those\x20Products\x20m\
    ay\x20still\x20end\x20up\x20deleted.\n\n\x20It's\x20not\x20possible\x20t\
    o\x20undo\x20the\x20PurgeProducts\x20operation.\x20Therefore,\x20it\x20i\
    s\n\x20recommended\x20to\x20keep\x20the\x20csv\x20files\x20used\x20in\
    \x20ImportProductSets\x20(if\x20that\x20was\n\x20how\x20you\x20originall\
    y\x20built\x20the\x20Product\x20Set)\x20before\x20starting\x20PurgeProdu\
    cts,\x20in\n\x20case\x20you\x20need\x20to\x20re-import\x20the\x20data\
    \x20after\x20deletion.\n\n\x20If\x20the\x20plan\x20is\x20to\x20purge\x20\
    all\x20of\x20the\x20Products\x20from\x20a\x20ProductSet\x20and\x20then\n\
    \x20re-use\x20the\x20empty\x20ProductSet\x20to\x20re-import\x20new\x20Pr\
    oducts\x20into\x20the\x20empty\n\x20ProductSet,\x20you\x20must\x20wait\
    \x20until\x20the\x20PurgeProducts\x20operation\x20has\x20finished\n\x20f\
    or\x20that\x20ProductSet.\n\n\x20The\x20[google.longrunning.Operation][g\
    oogle.longrunning.Operation]\x20API\x20can\x20be\x20used\x20to\x20keep\
    \x20track\x20of\x20the\n\x20progress\x20and\x20results\x20of\x20the\x20r\
    equest.\n\x20`Operation.metadata`\x20contains\x20`BatchOperationMetadata\
    `.\x20(progress)\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xdf\x02\x06\x13\n\
    \r\n\x05\x06\0\x02\x12\x02\x12\x04\xdf\x02\x14(\n\r\n\x05\x06\0\x02\x12\
    \x03\x12\x04\xdf\x023O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xe0\x02\x04\
    \xe3\x02\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\xe0\x02\
    \x04\xe3\x02\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xe4\x02\x044\n\x10\
    \n\x08\x06\0\x02\x12\x04\x9b\x08\0\x12\x04\xe4\x02\x044\n\x0f\n\x05\x06\
    \0\x02\x12\x04\x12\x06\xe5\x02\x04\xe8\x02\x06\n\x11\n\x07\x06\0\x02\x12\
    \x04\x99\x08\x12\x06\xe5\x02\x04\xe8\x02\x06\n3\n\x02\x04\0\x12\x06\xed\
    \x02\0\xa2\x03\x01\x1a%\x20A\x20Product\x20contains\x20ReferenceImages.\
    \n\n\x0b\n\x03\x04\0\x01\x12\x04\xed\x02\x08\x0f\n\r\n\x03\x04\0\x07\x12\
    \x06\xee\x02\x02\xf1\x02\x04\n\x0f\n\x05\x04\0\x07\x9d\x08\x12\x06\xee\
    \x02\x02\xf1\x02\x04\nB\n\x04\x04\0\x03\0\x12\x06\xf4\x02\x02\xfc\x02\
    \x03\x1a2\x20A\x20product\x20label\x20represented\x20as\x20a\x20key-valu\
    e\x20pair.\n\n\r\n\x05\x04\0\x03\0\x01\x12\x04\xf4\x02\n\x12\nm\n\x06\
    \x04\0\x03\0\x02\0\x12\x04\xf7\x02\x04\x13\x1a]\x20The\x20key\x20of\x20t\
    he\x20label\x20attached\x20to\x20the\x20product.\x20Cannot\x20be\x20empt\
    y\x20and\x20cannot\n\x20exceed\x20128\x20bytes.\n\n\x0f\n\x07\x04\0\x03\
    \0\x02\0\x05\x12\x04\xf7\x02\x04\n\n\x0f\n\x07\x04\0\x03\0\x02\0\x01\x12\
    \x04\xf7\x02\x0b\x0e\n\x0f\n\x07\x04\0\x03\0\x02\0\x03\x12\x04\xf7\x02\
    \x11\x12\no\n\x06\x04\0\x03\0\x02\x01\x12\x04\xfb\x02\x04\x15\x1a_\x20Th\
    e\x20value\x20of\x20the\x20label\x20attached\x20to\x20the\x20product.\
    \x20Cannot\x20be\x20empty\x20and\n\x20cannot\x20exceed\x20128\x20bytes.\
    \n\n\x0f\n\x07\x04\0\x03\0\x02\x01\x05\x12\x04\xfb\x02\x04\n\n\x0f\n\x07\
    \x04\0\x03\0\x02\x01\x01\x12\x04\xfb\x02\x0b\x10\n\x0f\n\x07\x04\0\x03\0\
    \x02\x01\x03\x12\x04\xfb\x02\x13\x14\n\xad\x01\n\x04\x04\0\x02\0\x12\x04\
    \x84\x03\x02\x12\x1a\x9e\x01\x20The\x20resource\x20name\x20of\x20the\x20\
    product.\n\n\x20Format\x20is:\n\x20`projects/PROJECT_ID/locations/LOC_ID\
    /products/PRODUCT_ID`.\n\n\x20This\x20field\x20is\x20ignored\x20when\x20\
    creating\x20a\x20product.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x84\x03\
    \x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x84\x03\t\r\n\r\n\x05\x04\0\
    \x02\0\x03\x12\x04\x84\x03\x10\x11\nr\n\x04\x04\0\x02\x01\x12\x04\x88\
    \x03\x02\x1a\x1ad\x20The\x20user-provided\x20name\x20for\x20this\x20Prod\
    uct.\x20Must\x20not\x20be\x20empty.\x20Must\x20be\x20at\x20most\n\x20409\
    6\x20characters\x20long.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x88\x03\
    \x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x88\x03\t\x15\n\r\n\x05\x04\
    \0\x02\x01\x03\x12\x04\x88\x03\x18\x19\nm\n\x04\x04\0\x02\x02\x12\x04\
    \x8c\x03\x02\x19\x1a_\x20User-provided\x20metadata\x20to\x20be\x20stored\
    \x20with\x20this\x20product.\x20Must\x20be\x20at\x20most\x204096\n\x20ch\
    aracters\x20long.\n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\x8c\x03\x02\x08\
    \n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x8c\x03\t\x14\n\r\n\x05\x04\0\x02\
    \x02\x03\x12\x04\x8c\x03\x17\x18\n\x9d\x02\n\x04\x04\0\x02\x03\x12\x04\
    \x92\x03\x02H\x1a\x8e\x02\x20Immutable.\x20The\x20category\x20for\x20the\
    \x20product\x20identified\x20by\x20the\x20reference\x20image.\x20This\
    \x20should\n\x20be\x20either\x20\"homegoods-v2\",\x20\"apparel-v2\",\x20\
    or\x20\"toys-v2\".\x20The\x20legacy\x20categories\n\x20\"homegoods\",\
    \x20\"apparel\",\x20and\x20\"toys\"\x20are\x20still\x20supported,\x20but\
    \x20these\x20should\n\x20not\x20be\x20used\x20for\x20new\x20products.\n\
    \n\r\n\x05\x04\0\x02\x03\x05\x12\x04\x92\x03\x02\x08\n\r\n\x05\x04\0\x02\
    \x03\x01\x12\x04\x92\x03\t\x19\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\x92\
    \x03\x1c\x1d\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\x92\x03\x1eG\n\x10\n\
    \x08\x04\0\x02\x03\x08\x9c\x08\0\x12\x04\x92\x03\x1fF\n\xdb\x04\n\x04\
    \x04\0\x02\x04\x12\x04\xa1\x03\x02'\x1a\xcc\x04\x20Key-value\x20pairs\
    \x20that\x20can\x20be\x20attached\x20to\x20a\x20product.\x20At\x20query\
    \x20time,\n\x20constraints\x20can\x20be\x20specified\x20based\x20on\x20t\
    he\x20product_labels.\n\n\x20Note\x20that\x20integer\x20values\x20can\
    \x20be\x20provided\x20as\x20strings,\x20e.g.\x20\"1199\".\x20Only\n\x20s\
    trings\x20with\x20integer\x20values\x20can\x20match\x20a\x20range-based\
    \x20restriction\x20which\x20is\n\x20to\x20be\x20supported\x20soon.\n\n\
    \x20Multiple\x20values\x20can\x20be\x20assigned\x20to\x20the\x20same\x20\
    key.\x20One\x20product\x20may\x20have\x20up\x20to\n\x20500\x20product_la\
    bels.\n\n\x20Notice\x20that\x20the\x20total\x20number\x20of\x20distinct\
    \x20product_labels\x20over\x20all\x20products\n\x20in\x20one\x20ProductS\
    et\x20cannot\x20exceed\x201M,\x20otherwise\x20the\x20product\x20search\
    \x20pipeline\n\x20will\x20refuse\x20to\x20work\x20for\x20that\x20Product\
    Set.\n\n\r\n\x05\x04\0\x02\x04\x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\0\
    \x02\x04\x06\x12\x04\xa1\x03\x0b\x13\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\
    \xa1\x03\x14\"\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xa1\x03%&\n\xab\x01\n\
    \x02\x04\x01\x12\x06\xa7\x03\0\xc6\x03\x01\x1a\x9c\x01\x20A\x20ProductSe\
    t\x20contains\x20Products.\x20A\x20ProductSet\x20can\x20contain\x20a\x20\
    maximum\x20of\x201\n\x20million\x20reference\x20images.\x20If\x20the\x20\
    limit\x20is\x20exceeded,\x20periodic\x20indexing\x20will\n\x20fail.\n\n\
    \x0b\n\x03\x04\x01\x01\x12\x04\xa7\x03\x08\x12\n\r\n\x03\x04\x01\x07\x12\
    \x06\xa8\x03\x02\xab\x03\x04\n\x0f\n\x05\x04\x01\x07\x9d\x08\x12\x06\xa8\
    \x03\x02\xab\x03\x04\n\xba\x01\n\x04\x04\x01\x02\0\x12\x04\xb3\x03\x02\
    \x12\x1a\xab\x01\x20The\x20resource\x20name\x20of\x20the\x20ProductSet.\
    \n\n\x20Format\x20is:\n\x20`projects/PROJECT_ID/locations/LOC_ID/product\
    Sets/PRODUCT_SET_ID`.\n\n\x20This\x20field\x20is\x20ignored\x20when\x20c\
    reating\x20a\x20ProductSet.\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xb3\
    \x03\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xb3\x03\t\r\n\r\n\x05\
    \x04\x01\x02\0\x03\x12\x04\xb3\x03\x10\x11\nu\n\x04\x04\x01\x02\x01\x12\
    \x04\xb7\x03\x02\x1a\x1ag\x20The\x20user-provided\x20name\x20for\x20this\
    \x20ProductSet.\x20Must\x20not\x20be\x20empty.\x20Must\x20be\x20at\n\x20\
    most\x204096\x20characters\x20long.\n\n\r\n\x05\x04\x01\x02\x01\x05\x12\
    \x04\xb7\x03\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xb7\x03\t\x15\
    \n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xb7\x03\x18\x19\n\xa8\x02\n\x04\
    \x04\x01\x02\x02\x12\x04\xbf\x03\x02W\x1a\x99\x02\x20Output\x20only.\x20\
    The\x20time\x20at\x20which\x20this\x20ProductSet\x20was\x20last\x20index\
    ed.\x20Query\n\x20results\x20will\x20reflect\x20all\x20updates\x20before\
    \x20this\x20time.\x20If\x20this\x20ProductSet\x20has\n\x20never\x20been\
    \x20indexed,\x20this\x20timestamp\x20is\x20the\x20default\x20value\n\x20\
    \"1970-01-01T00:00:00Z\".\n\n\x20This\x20field\x20is\x20ignored\x20when\
    \x20creating\x20a\x20ProductSet.\n\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\
    \xbf\x03\x02\x1b\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xbf\x03\x1c&\n\r\
    \n\x05\x04\x01\x02\x02\x03\x12\x04\xbf\x03)*\n\r\n\x05\x04\x01\x02\x02\
    \x08\x12\x04\xbf\x03+V\n\x10\n\x08\x04\x01\x02\x02\x08\x9c\x08\0\x12\x04\
    \xbf\x03,U\n\x9f\x01\n\x04\x04\x01\x02\x03\x12\x04\xc5\x03\x02P\x1a\x90\
    \x01\x20Output\x20only.\x20If\x20there\x20was\x20an\x20error\x20with\x20\
    indexing\x20the\x20product\x20set,\x20the\x20field\n\x20is\x20populated.\
    \n\n\x20This\x20field\x20is\x20ignored\x20when\x20creating\x20a\x20Produ\
    ctSet.\n\n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\xc5\x03\x02\x13\n\r\n\x05\
    \x04\x01\x02\x03\x01\x12\x04\xc5\x03\x14\x1f\n\r\n\x05\x04\x01\x02\x03\
    \x03\x12\x04\xc5\x03\"#\n\r\n\x05\x04\x01\x02\x03\x08\x12\x04\xc5\x03$O\
    \n\x10\n\x08\x04\x01\x02\x03\x08\x9c\x08\0\x12\x04\xc5\x03%N\ns\n\x02\
    \x04\x02\x12\x06\xca\x03\0\xe7\x03\x01\x1ae\x20A\x20`ReferenceImage`\x20\
    represents\x20a\x20product\x20image\x20and\x20its\x20associated\x20metad\
    ata,\n\x20such\x20as\x20bounding\x20boxes.\n\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\xca\x03\x08\x16\n\r\n\x03\x04\x02\x07\x12\x06\xcb\x03\x02\xce\x03\
    \x04\n\x0f\n\x05\x04\x02\x07\x9d\x08\x12\x06\xcb\x03\x02\xce\x03\x04\n\
    \xd7\x01\n\x04\x04\x02\x02\0\x12\x04\xd7\x03\x02\x12\x1a\xc8\x01\x20The\
    \x20resource\x20name\x20of\x20the\x20reference\x20image.\n\n\x20Format\
    \x20is:\n\n\x20`projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID\
    /referenceImages/IMAGE_ID`.\n\n\x20This\x20field\x20is\x20ignored\x20whe\
    n\x20creating\x20a\x20reference\x20image.\n\n\r\n\x05\x04\x02\x02\0\x05\
    \x12\x04\xd7\x03\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xd7\x03\t\r\
    \n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xd7\x03\x10\x11\nq\n\x04\x04\x02\
    \x02\x01\x12\x04\xdc\x03\x02:\x1ac\x20Required.\x20The\x20Google\x20Clou\
    d\x20Storage\x20URI\x20of\x20the\x20reference\x20image.\n\n\x20The\x20UR\
    I\x20must\x20start\x20with\x20`gs://`.\n\n\r\n\x05\x04\x02\x02\x01\x05\
    \x12\x04\xdc\x03\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xdc\x03\t\
    \x0c\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xdc\x03\x0f\x10\n\r\n\x05\x04\
    \x02\x02\x01\x08\x12\x04\xdc\x03\x119\n\x10\n\x08\x04\x02\x02\x01\x08\
    \x9c\x08\0\x12\x04\xdc\x03\x128\n\xbc\x03\n\x04\x04\x02\x02\x02\x12\x04\
    \xe6\x03\x02T\x1a\xad\x03\x20Optional.\x20Bounding\x20polygons\x20around\
    \x20the\x20areas\x20of\x20interest\x20in\x20the\x20reference\x20image.\n\
    \x20If\x20this\x20field\x20is\x20empty,\x20the\x20system\x20will\x20try\
    \x20to\x20detect\x20regions\x20of\n\x20interest.\x20At\x20most\x2010\x20\
    bounding\x20polygons\x20will\x20be\x20used.\n\n\x20The\x20provided\x20sh\
    ape\x20is\x20converted\x20into\x20a\x20non-rotated\x20rectangle.\x20Once\
    \n\x20converted,\x20the\x20small\x20edge\x20of\x20the\x20rectangle\x20mu\
    st\x20be\x20greater\x20than\x20or\x20equal\n\x20to\x20300\x20pixels.\x20\
    The\x20aspect\x20ratio\x20must\x20be\x201:4\x20or\x20less\x20(i.e.\x201:\
    3\x20is\x20ok;\x201:5\n\x20is\x20not).\n\n\r\n\x05\x04\x02\x02\x02\x04\
    \x12\x04\xe6\x03\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xe6\x03\x0b\
    \x17\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xe6\x03\x18&\n\r\n\x05\x04\
    \x02\x02\x02\x03\x12\x04\xe6\x03)*\n\r\n\x05\x04\x02\x02\x02\x08\x12\x04\
    \xe6\x03+S\n\x10\n\x08\x04\x02\x02\x02\x08\x9c\x08\0\x12\x04\xe6\x03,R\n\
    ?\n\x02\x04\x03\x12\x06\xea\x03\0\xfe\x03\x01\x1a1\x20Request\x20message\
    \x20for\x20the\x20`CreateProduct`\x20method.\n\n\x0b\n\x03\x04\x03\x01\
    \x12\x04\xea\x03\x08\x1c\n\x84\x01\n\x04\x04\x03\x02\0\x12\x06\xef\x03\
    \x02\xf4\x03\x04\x1at\x20Required.\x20The\x20project\x20in\x20which\x20t\
    he\x20Product\x20should\x20be\x20created.\n\n\x20Format\x20is\n\x20`proj\
    ects/PROJECT_ID/locations/LOC_ID`.\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\
    \xef\x03\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xef\x03\t\x0f\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\xef\x03\x12\x13\n\x0f\n\x05\x04\x03\x02\0\
    \x08\x12\x06\xef\x03\x14\xf4\x03\x03\n\x10\n\x08\x04\x03\x02\0\x08\x9c\
    \x08\0\x12\x04\xf0\x03\x04*\n\x11\n\x07\x04\x03\x02\0\x08\x9f\x08\x12\
    \x06\xf1\x03\x04\xf3\x03\x05\n0\n\x04\x04\x03\x02\x01\x12\x04\xf7\x03\
    \x02?\x1a\"\x20Required.\x20The\x20product\x20to\x20create.\n\n\r\n\x05\
    \x04\x03\x02\x01\x06\x12\x04\xf7\x03\x02\t\n\r\n\x05\x04\x03\x02\x01\x01\
    \x12\x04\xf7\x03\n\x11\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xf7\x03\x14\
    \x15\n\r\n\x05\x04\x03\x02\x01\x08\x12\x04\xf7\x03\x16>\n\x10\n\x08\x04\
    \x03\x02\x01\x08\x9c\x08\0\x12\x04\xf7\x03\x17=\n\x99\x02\n\x04\x04\x03\
    \x02\x02\x12\x04\xfd\x03\x02\x18\x1a\x8a\x02\x20A\x20user-supplied\x20re\
    source\x20id\x20for\x20this\x20Product.\x20If\x20set,\x20the\x20server\
    \x20will\n\x20attempt\x20to\x20use\x20this\x20value\x20as\x20the\x20reso\
    urce\x20id.\x20If\x20it\x20is\x20already\x20in\x20use,\x20an\n\x20error\
    \x20is\x20returned\x20with\x20code\x20ALREADY_EXISTS.\x20Must\x20be\x20a\
    t\x20most\x20128\x20characters\n\x20long.\x20It\x20cannot\x20contain\x20\
    the\x20character\x20`/`.\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xfd\x03\
    \x02\x08\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xfd\x03\t\x13\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\xfd\x03\x16\x17\n>\n\x02\x04\x04\x12\x06\
    \x81\x04\0\x92\x04\x01\x1a0\x20Request\x20message\x20for\x20the\x20`List\
    Products`\x20method.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x81\x04\x08\x1b\n\
    \x8d\x01\n\x04\x04\x04\x02\0\x12\x06\x86\x04\x02\x8b\x04\x04\x1a}\x20Req\
    uired.\x20The\x20project\x20OR\x20ProductSet\x20from\x20which\x20Product\
    s\x20should\x20be\x20listed.\n\n\x20Format:\n\x20`projects/PROJECT_ID/lo\
    cations/LOC_ID`\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x86\x04\x02\x08\n\
    \r\n\x05\x04\x04\x02\0\x01\x12\x04\x86\x04\t\x0f\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x86\x04\x12\x13\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\x86\
    \x04\x14\x8b\x04\x03\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\x87\
    \x04\x04*\n\x11\n\x07\x04\x04\x02\0\x08\x9f\x08\x12\x06\x88\x04\x04\x8a\
    \x04\x05\nO\n\x04\x04\x04\x02\x01\x12\x04\x8e\x04\x02\x16\x1aA\x20The\
    \x20maximum\x20number\x20of\x20items\x20to\x20return.\x20Default\x2010,\
    \x20maximum\x20100.\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x8e\x04\x02\
    \x07\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x8e\x04\x08\x11\n\r\n\x05\x04\
    \x04\x02\x01\x03\x12\x04\x8e\x04\x14\x15\nR\n\x04\x04\x04\x02\x02\x12\
    \x04\x91\x04\x02\x18\x1aD\x20The\x20next_page_token\x20returned\x20from\
    \x20a\x20previous\x20List\x20request,\x20if\x20any.\n\n\r\n\x05\x04\x04\
    \x02\x02\x05\x12\x04\x91\x04\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\x91\x04\t\x13\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x91\x04\x16\x17\
    \n?\n\x02\x04\x05\x12\x06\x95\x04\0\x9c\x04\x01\x1a1\x20Response\x20mess\
    age\x20for\x20the\x20`ListProducts`\x20method.\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\x95\x04\x08\x1c\n!\n\x04\x04\x05\x02\0\x12\x04\x97\x04\x02\x20\
    \x1a\x13\x20List\x20of\x20products.\n\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04\x97\x04\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x97\x04\x0b\x12\n\
    \r\n\x05\x04\x05\x02\0\x01\x12\x04\x97\x04\x13\x1b\n\r\n\x05\x04\x05\x02\
    \0\x03\x12\x04\x97\x04\x1e\x1f\no\n\x04\x04\x05\x02\x01\x12\x04\x9b\x04\
    \x02\x1d\x1aa\x20Token\x20to\x20retrieve\x20the\x20next\x20page\x20of\
    \x20results,\x20or\x20empty\x20if\x20there\x20are\x20no\x20more\n\x20res\
    ults\x20in\x20the\x20list.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x9b\
    \x04\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x9b\x04\t\x18\n\r\n\
    \x05\x04\x05\x02\x01\x03\x12\x04\x9b\x04\x1b\x1c\n<\n\x02\x04\x06\x12\
    \x06\x9f\x04\0\xaa\x04\x01\x1a.\x20Request\x20message\x20for\x20the\x20`\
    GetProduct`\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x9f\x04\x08\x19\
    \n\x89\x01\n\x04\x04\x06\x02\0\x12\x06\xa4\x04\x02\xa9\x04\x04\x1ay\x20R\
    equired.\x20Resource\x20name\x20of\x20the\x20Product\x20to\x20get.\n\n\
    \x20Format\x20is:\n\x20`projects/PROJECT_ID/locations/LOC_ID/products/PR\
    ODUCT_ID`\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa4\x04\x02\x08\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xa4\x04\t\r\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\xa4\x04\x10\x11\n\x0f\n\x05\x04\x06\x02\0\x08\x12\x06\xa4\x04\
    \x12\xa9\x04\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\x08\0\x12\x04\xa5\x04\
    \x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\x06\xa6\x04\x04\xa8\x04\
    \x05\n?\n\x02\x04\x07\x12\x06\xad\x04\0\xb8\x04\x01\x1a1\x20Request\x20m\
    essage\x20for\x20the\x20`UpdateProduct`\x20method.\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xad\x04\x08\x1c\np\n\x04\x04\x07\x02\0\x12\x04\xb0\x04\x02?\
    \x1ab\x20Required.\x20The\x20Product\x20resource\x20which\x20replaces\
    \x20the\x20one\x20on\x20the\x20server.\n\x20product.name\x20is\x20immuta\
    ble.\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xb0\x04\x02\t\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xb0\x04\n\x11\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \xb0\x04\x14\x15\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\xb0\x04\x16>\n\x10\
    \n\x08\x04\x07\x02\0\x08\x9c\x08\0\x12\x04\xb0\x04\x17=\n\xfa\x01\n\x04\
    \x04\x07\x02\x01\x12\x04\xb7\x04\x02,\x1a\xeb\x01\x20The\x20[FieldMask][\
    google.protobuf.FieldMask]\x20that\x20specifies\x20which\x20fields\n\x20\
    to\x20update.\n\x20If\x20update_mask\x20isn't\x20specified,\x20all\x20mu\
    table\x20fields\x20are\x20to\x20be\x20updated.\n\x20Valid\x20mask\x20pat\
    hs\x20include\x20`product_labels`,\x20`display_name`,\x20and\n\x20`descr\
    iption`.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xb7\x04\x02\x1b\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\xb7\x04\x1c'\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\xb7\x04*+\n?\n\x02\x04\x08\x12\x06\xbb\x04\0\xc6\x04\x01\
    \x1a1\x20Request\x20message\x20for\x20the\x20`DeleteProduct`\x20method.\
    \n\n\x0b\n\x03\x04\x08\x01\x12\x04\xbb\x04\x08\x1c\n\x88\x01\n\x04\x04\
    \x08\x02\0\x12\x06\xc0\x04\x02\xc5\x04\x04\x1ax\x20Required.\x20Resource\
    \x20name\x20of\x20product\x20to\x20delete.\n\n\x20Format\x20is:\n\x20`pr\
    ojects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`\n\n\r\n\x05\x04\
    \x08\x02\0\x05\x12\x04\xc0\x04\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\
    \x04\xc0\x04\t\r\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc0\x04\x10\x11\n\
    \x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xc0\x04\x12\xc5\x04\x03\n\x10\n\x08\
    \x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xc1\x04\x04*\n\x11\n\x07\x04\x08\
    \x02\0\x08\x9f\x08\x12\x06\xc2\x04\x04\xc4\x04\x05\nB\n\x02\x04\t\x12\
    \x06\xc9\x04\0\xdc\x04\x01\x1a4\x20Request\x20message\x20for\x20the\x20`\
    CreateProductSet`\x20method.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xc9\x04\x08\
    \x1f\n\x86\x01\n\x04\x04\t\x02\0\x12\x06\xcd\x04\x02\xd2\x04\x04\x1av\
    \x20Required.\x20The\x20project\x20in\x20which\x20the\x20ProductSet\x20s\
    hould\x20be\x20created.\n\n\x20Format\x20is\x20`projects/PROJECT_ID/loca\
    tions/LOC_ID`.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xcd\x04\x02\x08\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xcd\x04\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\xcd\x04\x12\x13\n\x0f\n\x05\x04\t\x02\0\x08\x12\x06\xcd\x04\x14\xd2\
    \x04\x03\n\x10\n\x08\x04\t\x02\0\x08\x9c\x08\0\x12\x04\xce\x04\x04*\n\
    \x11\n\x07\x04\t\x02\0\x08\x9f\x08\x12\x06\xcf\x04\x04\xd1\x04\x05\n3\n\
    \x04\x04\t\x02\x01\x12\x04\xd5\x04\x02F\x1a%\x20Required.\x20The\x20Prod\
    uctSet\x20to\x20create.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xd5\x04\
    \x02\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xd5\x04\r\x18\n\r\n\x05\x04\
    \t\x02\x01\x03\x12\x04\xd5\x04\x1b\x1c\n\r\n\x05\x04\t\x02\x01\x08\x12\
    \x04\xd5\x04\x1dE\n\x10\n\x08\x04\t\x02\x01\x08\x9c\x08\0\x12\x04\xd5\
    \x04\x1eD\n\x9c\x02\n\x04\x04\t\x02\x02\x12\x04\xdb\x04\x02\x1c\x1a\x8d\
    \x02\x20A\x20user-supplied\x20resource\x20id\x20for\x20this\x20ProductSe\
    t.\x20If\x20set,\x20the\x20server\x20will\n\x20attempt\x20to\x20use\x20t\
    his\x20value\x20as\x20the\x20resource\x20id.\x20If\x20it\x20is\x20alread\
    y\x20in\x20use,\x20an\n\x20error\x20is\x20returned\x20with\x20code\x20AL\
    READY_EXISTS.\x20Must\x20be\x20at\x20most\x20128\x20characters\n\x20long\
    .\x20It\x20cannot\x20contain\x20the\x20character\x20`/`.\n\n\r\n\x05\x04\
    \t\x02\x02\x05\x12\x04\xdb\x04\x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\
    \x04\xdb\x04\t\x17\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xdb\x04\x1a\x1b\n\
    A\n\x02\x04\n\x12\x06\xdf\x04\0\xef\x04\x01\x1a3\x20Request\x20message\
    \x20for\x20the\x20`ListProductSets`\x20method.\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xdf\x04\x08\x1e\n\x84\x01\n\x04\x04\n\x02\0\x12\x06\xe3\x04\x02\
    \xe8\x04\x04\x1at\x20Required.\x20The\x20project\x20from\x20which\x20Pro\
    ductSets\x20should\x20be\x20listed.\n\n\x20Format\x20is\x20`projects/PRO\
    JECT_ID/locations/LOC_ID`.\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xe3\x04\
    \x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xe3\x04\t\x0f\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xe3\x04\x12\x13\n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\
    \xe3\x04\x14\xe8\x04\x03\n\x10\n\x08\x04\n\x02\0\x08\x9c\x08\0\x12\x04\
    \xe4\x04\x04*\n\x11\n\x07\x04\n\x02\0\x08\x9f\x08\x12\x06\xe5\x04\x04\
    \xe7\x04\x05\nO\n\x04\x04\n\x02\x01\x12\x04\xeb\x04\x02\x16\x1aA\x20The\
    \x20maximum\x20number\x20of\x20items\x20to\x20return.\x20Default\x2010,\
    \x20maximum\x20100.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xeb\x04\x02\
    \x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xeb\x04\x08\x11\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xeb\x04\x14\x15\nR\n\x04\x04\n\x02\x02\x12\x04\xee\
    \x04\x02\x18\x1aD\x20The\x20next_page_token\x20returned\x20from\x20a\x20\
    previous\x20List\x20request,\x20if\x20any.\n\n\r\n\x05\x04\n\x02\x02\x05\
    \x12\x04\xee\x04\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xee\x04\t\
    \x13\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xee\x04\x16\x17\nB\n\x02\x04\
    \x0b\x12\x06\xf2\x04\0\xf9\x04\x01\x1a4\x20Response\x20message\x20for\
    \x20the\x20`ListProductSets`\x20method.\n\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xf2\x04\x08\x1f\n$\n\x04\x04\x0b\x02\0\x12\x04\xf4\x04\x02'\x1a\x16\
    \x20List\x20of\x20ProductSets.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xf4\
    \x04\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xf4\x04\x0b\x15\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xf4\x04\x16\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xf4\x04%&\no\n\x04\x04\x0b\x02\x01\x12\x04\xf8\x04\x02\x1d\x1aa\x20\
    Token\x20to\x20retrieve\x20the\x20next\x20page\x20of\x20results,\x20or\
    \x20empty\x20if\x20there\x20are\x20no\x20more\n\x20results\x20in\x20the\
    \x20list.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xf8\x04\x02\x08\n\r\n\
    \x05\x04\x0b\x02\x01\x01\x12\x04\xf8\x04\t\x18\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\xf8\x04\x1b\x1c\n?\n\x02\x04\x0c\x12\x06\xfc\x04\0\x87\x05\
    \x01\x1a1\x20Request\x20message\x20for\x20the\x20`GetProductSet`\x20meth\
    od.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xfc\x04\x08\x1c\n\x94\x01\n\x04\
    \x04\x0c\x02\0\x12\x06\x81\x05\x02\x86\x05\x04\x1a\x83\x01\x20Required.\
    \x20Resource\x20name\x20of\x20the\x20ProductSet\x20to\x20get.\n\n\x20For\
    mat\x20is:\n\x20`projects/PROJECT_ID/locations/LOG_ID/productSets/PRODUC\
    T_SET_ID`\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x81\x05\x02\x08\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\x81\x05\t\r\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\x81\x05\x10\x11\n\x0f\n\x05\x04\x0c\x02\0\x08\x12\x06\x81\x05\
    \x12\x86\x05\x03\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\x82\x05\
    \x04*\n\x11\n\x07\x04\x0c\x02\0\x08\x9f\x08\x12\x06\x83\x05\x04\x85\x05\
    \x05\nB\n\x02\x04\r\x12\x06\x8a\x05\0\x93\x05\x01\x1a4\x20Request\x20mes\
    sage\x20for\x20the\x20`UpdateProductSet`\x20method.\n\n\x0b\n\x03\x04\r\
    \x01\x12\x04\x8a\x05\x08\x1f\nW\n\x04\x04\r\x02\0\x12\x04\x8c\x05\x02F\
    \x1aI\x20Required.\x20The\x20ProductSet\x20resource\x20which\x20replaces\
    \x20the\x20one\x20on\x20the\x20server.\n\n\r\n\x05\x04\r\x02\0\x06\x12\
    \x04\x8c\x05\x02\x0c\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x8c\x05\r\x18\n\r\
    \n\x05\x04\r\x02\0\x03\x12\x04\x8c\x05\x1b\x1c\n\r\n\x05\x04\r\x02\0\x08\
    \x12\x04\x8c\x05\x1dE\n\x10\n\x08\x04\r\x02\0\x08\x9c\x08\0\x12\x04\x8c\
    \x05\x1eD\n\xce\x01\n\x04\x04\r\x02\x01\x12\x04\x92\x05\x02,\x1a\xbf\x01\
    \x20The\x20[FieldMask][google.protobuf.FieldMask]\x20that\x20specifies\
    \x20which\x20fields\x20to\n\x20update.\n\x20If\x20update_mask\x20isn't\
    \x20specified,\x20all\x20mutable\x20fields\x20are\x20to\x20be\x20updated\
    .\n\x20Valid\x20mask\x20path\x20is\x20`display_name`.\n\n\r\n\x05\x04\r\
    \x02\x01\x06\x12\x04\x92\x05\x02\x1b\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \x92\x05\x1c'\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x92\x05*+\nB\n\x02\x04\
    \x0e\x12\x06\x96\x05\0\xa1\x05\x01\x1a4\x20Request\x20message\x20for\x20\
    the\x20`DeleteProductSet`\x20method.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \x96\x05\x08\x1f\n\x97\x01\n\x04\x04\x0e\x02\0\x12\x06\x9b\x05\x02\xa0\
    \x05\x04\x1a\x86\x01\x20Required.\x20Resource\x20name\x20of\x20the\x20Pr\
    oductSet\x20to\x20delete.\n\n\x20Format\x20is:\n\x20`projects/PROJECT_ID\
    /locations/LOC_ID/productSets/PRODUCT_SET_ID`\n\n\r\n\x05\x04\x0e\x02\0\
    \x05\x12\x04\x9b\x05\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x9b\x05\
    \t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9b\x05\x10\x11\n\x0f\n\x05\x04\
    \x0e\x02\0\x08\x12\x06\x9b\x05\x12\xa0\x05\x03\n\x10\n\x08\x04\x0e\x02\0\
    \x08\x9c\x08\0\x12\x04\x9c\x05\x04*\n\x11\n\x07\x04\x0e\x02\0\x08\x9f\
    \x08\x12\x06\x9d\x05\x04\x9f\x05\x05\nF\n\x02\x04\x0f\x12\x06\xa4\x05\0\
    \xb9\x05\x01\x1a8\x20Request\x20message\x20for\x20the\x20`CreateReferenc\
    eImage`\x20method.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa4\x05\x08#\n\xaa\
    \x01\n\x04\x04\x0f\x02\0\x12\x06\xa9\x05\x02\xae\x05\x04\x1a\x99\x01\x20\
    Required.\x20Resource\x20name\x20of\x20the\x20product\x20in\x20which\x20\
    to\x20create\x20the\x20reference\x20image.\n\n\x20Format\x20is\n\x20`pro\
    jects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.\n\n\r\n\x05\x04\
    \x0f\x02\0\x05\x12\x04\xa9\x05\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\
    \x04\xa9\x05\t\x0f\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa9\x05\x12\x13\n\
    \x0f\n\x05\x04\x0f\x02\0\x08\x12\x06\xa9\x05\x14\xae\x05\x03\n\x10\n\x08\
    \x04\x0f\x02\0\x08\x9c\x08\0\x12\x04\xaa\x05\x04*\n\x11\n\x07\x04\x0f\
    \x02\0\x08\x9f\x08\x12\x06\xab\x05\x04\xad\x05\x05\ne\n\x04\x04\x0f\x02\
    \x01\x12\x04\xb2\x05\x02N\x1aW\x20Required.\x20The\x20reference\x20image\
    \x20to\x20create.\n\x20If\x20an\x20image\x20ID\x20is\x20specified,\x20it\
    \x20is\x20ignored.\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xb2\x05\x02\
    \x10\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xb2\x05\x11\x20\n\r\n\x05\x04\
    \x0f\x02\x01\x03\x12\x04\xb2\x05#$\n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\
    \xb2\x05%M\n\x10\n\x08\x04\x0f\x02\x01\x08\x9c\x08\0\x12\x04\xb2\x05&L\n\
    \xab\x02\n\x04\x04\x0f\x02\x02\x12\x04\xb8\x05\x02\x20\x1a\x9c\x02\x20A\
    \x20user-supplied\x20resource\x20id\x20for\x20the\x20ReferenceImage\x20t\
    o\x20be\x20added.\x20If\x20set,\n\x20the\x20server\x20will\x20attempt\
    \x20to\x20use\x20this\x20value\x20as\x20the\x20resource\x20id.\x20If\x20\
    it\x20is\n\x20already\x20in\x20use,\x20an\x20error\x20is\x20returned\x20\
    with\x20code\x20ALREADY_EXISTS.\x20Must\x20be\x20at\n\x20most\x20128\x20\
    characters\x20long.\x20It\x20cannot\x20contain\x20the\x20character\x20`/\
    `.\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xb8\x05\x02\x08\n\r\n\x05\x04\
    \x0f\x02\x02\x01\x12\x04\xb8\x05\t\x1b\n\r\n\x05\x04\x0f\x02\x02\x03\x12\
    \x04\xb8\x05\x1e\x1f\nE\n\x02\x04\x10\x12\x06\xbc\x05\0\xd0\x05\x01\x1a7\
    \x20Request\x20message\x20for\x20the\x20`ListReferenceImages`\x20method.\
    \n\n\x0b\n\x03\x04\x10\x01\x12\x04\xbc\x05\x08\"\n\xa3\x01\n\x04\x04\x10\
    \x02\0\x12\x06\xc1\x05\x02\xc6\x05\x04\x1a\x92\x01\x20Required.\x20Resou\
    rce\x20name\x20of\x20the\x20product\x20containing\x20the\x20reference\
    \x20images.\n\n\x20Format\x20is\n\x20`projects/PROJECT_ID/locations/LOC_\
    ID/products/PRODUCT_ID`.\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xc1\x05\
    \x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xc1\x05\t\x0f\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\xc1\x05\x12\x13\n\x0f\n\x05\x04\x10\x02\0\x08\x12\
    \x06\xc1\x05\x14\xc6\x05\x03\n\x10\n\x08\x04\x10\x02\0\x08\x9c\x08\0\x12\
    \x04\xc2\x05\x04*\n\x11\n\x07\x04\x10\x02\0\x08\x9f\x08\x12\x06\xc3\x05\
    \x04\xc5\x05\x05\nO\n\x04\x04\x10\x02\x01\x12\x04\xc9\x05\x02\x16\x1aA\
    \x20The\x20maximum\x20number\x20of\x20items\x20to\x20return.\x20Default\
    \x2010,\x20maximum\x20100.\n\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xc9\
    \x05\x02\x07\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xc9\x05\x08\x11\n\r\n\
    \x05\x04\x10\x02\x01\x03\x12\x04\xc9\x05\x14\x15\n\xd0\x01\n\x04\x04\x10\
    \x02\x02\x12\x04\xcf\x05\x02\x18\x1a\xc1\x01\x20A\x20token\x20identifyin\
    g\x20a\x20page\x20of\x20results\x20to\x20be\x20returned.\x20This\x20is\
    \x20the\x20value\n\x20of\x20`nextPageToken`\x20returned\x20in\x20a\x20pr\
    evious\x20reference\x20image\x20list\x20request.\n\n\x20Defaults\x20to\
    \x20the\x20first\x20page\x20if\x20not\x20specified.\n\n\r\n\x05\x04\x10\
    \x02\x02\x05\x12\x04\xcf\x05\x02\x08\n\r\n\x05\x04\x10\x02\x02\x01\x12\
    \x04\xcf\x05\t\x13\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xcf\x05\x16\x17\
    \nF\n\x02\x04\x11\x12\x06\xd3\x05\0\xdc\x05\x01\x1a8\x20Response\x20mess\
    age\x20for\x20the\x20`ListReferenceImages`\x20method.\n\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\xd3\x05\x08#\n-\n\x04\x04\x11\x02\0\x12\x04\xd5\x05\x02\
    /\x1a\x1f\x20The\x20list\x20of\x20reference\x20images.\n\n\r\n\x05\x04\
    \x11\x02\0\x04\x12\x04\xd5\x05\x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\
    \xd5\x05\x0b\x19\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xd5\x05\x1a*\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xd5\x05-.\nO\n\x04\x04\x11\x02\x01\x12\
    \x04\xd8\x05\x02\x16\x1aA\x20The\x20maximum\x20number\x20of\x20items\x20\
    to\x20return.\x20Default\x2010,\x20maximum\x20100.\n\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xd8\x05\x02\x07\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xd8\x05\x08\x11\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xd8\x05\x14\
    \x15\nR\n\x04\x04\x11\x02\x02\x12\x04\xdb\x05\x02\x1d\x1aD\x20The\x20nex\
    t_page_token\x20returned\x20from\x20a\x20previous\x20List\x20request,\
    \x20if\x20any.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xdb\x05\x02\x08\n\
    \r\n\x05\x04\x11\x02\x02\x01\x12\x04\xdb\x05\t\x18\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xdb\x05\x1b\x1c\nC\n\x02\x04\x12\x12\x06\xdf\x05\0\xeb\
    \x05\x01\x1a5\x20Request\x20message\x20for\x20the\x20`GetReferenceImage`\
    \x20method.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xdf\x05\x08\x20\n\xb0\x01\
    \n\x04\x04\x12\x02\0\x12\x06\xe5\x05\x02\xea\x05\x04\x1a\x9f\x01\x20Requ\
    ired.\x20The\x20resource\x20name\x20of\x20the\x20ReferenceImage\x20to\
    \x20get.\n\n\x20Format\x20is:\n\n\x20`projects/PROJECT_ID/locations/LOC_\
    ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.\n\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\xe5\x05\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xe5\x05\t\r\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe5\x05\x10\x11\n\x0f\n\
    \x05\x04\x12\x02\0\x08\x12\x06\xe5\x05\x12\xea\x05\x03\n\x10\n\x08\x04\
    \x12\x02\0\x08\x9c\x08\0\x12\x04\xe6\x05\x04*\n\x11\n\x07\x04\x12\x02\0\
    \x08\x9f\x08\x12\x06\xe7\x05\x04\xe9\x05\x05\nF\n\x02\x04\x13\x12\x06\
    \xee\x05\0\xfa\x05\x01\x1a8\x20Request\x20message\x20for\x20the\x20`Dele\
    teReferenceImage`\x20method.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xee\x05\
    \x08#\n\xb3\x01\n\x04\x04\x13\x02\0\x12\x06\xf4\x05\x02\xf9\x05\x04\x1a\
    \xa2\x01\x20Required.\x20The\x20resource\x20name\x20of\x20the\x20referen\
    ce\x20image\x20to\x20delete.\n\n\x20Format\x20is:\n\n\x20`projects/PROJE\
    CT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`\n\n\
    \r\n\x05\x04\x13\x02\0\x05\x12\x04\xf4\x05\x02\x08\n\r\n\x05\x04\x13\x02\
    \0\x01\x12\x04\xf4\x05\t\r\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf4\x05\
    \x10\x11\n\x0f\n\x05\x04\x13\x02\0\x08\x12\x06\xf4\x05\x12\xf9\x05\x03\n\
    \x10\n\x08\x04\x13\x02\0\x08\x9c\x08\0\x12\x04\xf5\x05\x04*\n\x11\n\x07\
    \x04\x13\x02\0\x08\x9f\x08\x12\x06\xf6\x05\x04\xf8\x05\x05\nH\n\x02\x04\
    \x14\x12\x06\xfd\x05\0\x93\x06\x01\x1a:\x20Request\x20message\x20for\x20\
    the\x20`AddProductToProductSet`\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\xfd\x05\x08%\n\x9c\x01\n\x04\x04\x14\x02\0\x12\x06\x82\x06\x02\x87\
    \x06\x04\x1a\x8b\x01\x20Required.\x20The\x20resource\x20name\x20for\x20t\
    he\x20ProductSet\x20to\x20modify.\n\n\x20Format\x20is:\n\x20`projects/PR\
    OJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`\n\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\x82\x06\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\x82\x06\t\r\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x82\x06\x10\x11\n\
    \x0f\n\x05\x04\x14\x02\0\x08\x12\x06\x82\x06\x12\x87\x06\x03\n\x10\n\x08\
    \x04\x14\x02\0\x08\x9c\x08\0\x12\x04\x83\x06\x04*\n\x11\n\x07\x04\x14\
    \x02\0\x08\x9f\x08\x12\x06\x84\x06\x04\x86\x06\x05\n\xa7\x01\n\x04\x04\
    \x14\x02\x01\x12\x06\x8d\x06\x02\x92\x06\x04\x1a\x96\x01\x20Required.\
    \x20The\x20resource\x20name\x20for\x20the\x20Product\x20to\x20be\x20adde\
    d\x20to\x20this\x20ProductSet.\n\n\x20Format\x20is:\n\x20`projects/PROJE\
    CT_ID/locations/LOC_ID/products/PRODUCT_ID`\n\n\r\n\x05\x04\x14\x02\x01\
    \x05\x12\x04\x8d\x06\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x8d\
    \x06\t\x10\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x8d\x06\x13\x14\n\x0f\n\
    \x05\x04\x14\x02\x01\x08\x12\x06\x8d\x06\x15\x92\x06\x03\n\x10\n\x08\x04\
    \x14\x02\x01\x08\x9c\x08\0\x12\x04\x8e\x06\x04*\n\x11\n\x07\x04\x14\x02\
    \x01\x08\x9f\x08\x12\x06\x8f\x06\x04\x91\x06\x05\nM\n\x02\x04\x15\x12\
    \x06\x96\x06\0\xac\x06\x01\x1a?\x20Request\x20message\x20for\x20the\x20`\
    RemoveProductFromProductSet`\x20method.\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\x96\x06\x08*\n\x9c\x01\n\x04\x04\x15\x02\0\x12\x06\x9b\x06\x02\xa0\
    \x06\x04\x1a\x8b\x01\x20Required.\x20The\x20resource\x20name\x20for\x20t\
    he\x20ProductSet\x20to\x20modify.\n\n\x20Format\x20is:\n\x20`projects/PR\
    OJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`\n\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\x9b\x06\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\x9b\x06\t\r\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x9b\x06\x10\x11\n\
    \x0f\n\x05\x04\x15\x02\0\x08\x12\x06\x9b\x06\x12\xa0\x06\x03\n\x10\n\x08\
    \x04\x15\x02\0\x08\x9c\x08\0\x12\x04\x9c\x06\x04*\n\x11\n\x07\x04\x15\
    \x02\0\x08\x9f\x08\x12\x06\x9d\x06\x04\x9f\x06\x05\n\xab\x01\n\x04\x04\
    \x15\x02\x01\x12\x06\xa6\x06\x02\xab\x06\x04\x1a\x9a\x01\x20Required.\
    \x20The\x20resource\x20name\x20for\x20the\x20Product\x20to\x20be\x20remo\
    ved\x20from\x20this\x20ProductSet.\n\n\x20Format\x20is:\n\x20`projects/P\
    ROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`\n\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\xa6\x06\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \xa6\x06\t\x10\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xa6\x06\x13\x14\n\
    \x0f\n\x05\x04\x15\x02\x01\x08\x12\x06\xa6\x06\x15\xab\x06\x03\n\x10\n\
    \x08\x04\x15\x02\x01\x08\x9c\x08\0\x12\x04\xa7\x06\x04*\n\x11\n\x07\x04\
    \x15\x02\x01\x08\x9f\x08\x12\x06\xa8\x06\x04\xaa\x06\x05\nJ\n\x02\x04\
    \x16\x12\x06\xaf\x06\0\xc0\x06\x01\x1a<\x20Request\x20message\x20for\x20\
    the\x20`ListProductsInProductSet`\x20method.\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\xaf\x06\x08'\n\xa4\x01\n\x04\x04\x16\x02\0\x12\x06\xb4\x06\x02\
    \xb9\x06\x04\x1a\x93\x01\x20Required.\x20The\x20ProductSet\x20resource\
    \x20for\x20which\x20to\x20retrieve\x20Products.\n\n\x20Format\x20is:\n\
    \x20`projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`\n\
    \n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb4\x06\x02\x08\n\r\n\x05\x04\x16\
    \x02\0\x01\x12\x04\xb4\x06\t\r\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xb4\
    \x06\x10\x11\n\x0f\n\x05\x04\x16\x02\0\x08\x12\x06\xb4\x06\x12\xb9\x06\
    \x03\n\x10\n\x08\x04\x16\x02\0\x08\x9c\x08\0\x12\x04\xb5\x06\x04*\n\x11\
    \n\x07\x04\x16\x02\0\x08\x9f\x08\x12\x06\xb6\x06\x04\xb8\x06\x05\nO\n\
    \x04\x04\x16\x02\x01\x12\x04\xbc\x06\x02\x16\x1aA\x20The\x20maximum\x20n\
    umber\x20of\x20items\x20to\x20return.\x20Default\x2010,\x20maximum\x2010\
    0.\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xbc\x06\x02\x07\n\r\n\x05\x04\
    \x16\x02\x01\x01\x12\x04\xbc\x06\x08\x11\n\r\n\x05\x04\x16\x02\x01\x03\
    \x12\x04\xbc\x06\x14\x15\nR\n\x04\x04\x16\x02\x02\x12\x04\xbf\x06\x02\
    \x18\x1aD\x20The\x20next_page_token\x20returned\x20from\x20a\x20previous\
    \x20List\x20request,\x20if\x20any.\n\n\r\n\x05\x04\x16\x02\x02\x05\x12\
    \x04\xbf\x06\x02\x08\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xbf\x06\t\x13\
    \n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xbf\x06\x16\x17\nK\n\x02\x04\x17\
    \x12\x06\xc3\x06\0\xca\x06\x01\x1a=\x20Response\x20message\x20for\x20the\
    \x20`ListProductsInProductSet`\x20method.\n\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\xc3\x06\x08(\n%\n\x04\x04\x17\x02\0\x12\x04\xc5\x06\x02\x20\x1a\x17\
    \x20The\x20list\x20of\x20Products.\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\
    \xc5\x06\x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xc5\x06\x0b\x12\n\r\n\
    \x05\x04\x17\x02\0\x01\x12\x04\xc5\x06\x13\x1b\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xc5\x06\x1e\x1f\no\n\x04\x04\x17\x02\x01\x12\x04\xc9\x06\
    \x02\x1d\x1aa\x20Token\x20to\x20retrieve\x20the\x20next\x20page\x20of\
    \x20results,\x20or\x20empty\x20if\x20there\x20are\x20no\x20more\n\x20res\
    ults\x20in\x20the\x20list.\n\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xc9\
    \x06\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xc9\x06\t\x18\n\r\n\
    \x05\x04\x17\x02\x01\x03\x12\x04\xc9\x06\x1b\x1c\n\x82\x01\n\x02\x04\x18\
    \x12\x06\xce\x06\0\x8d\x07\x01\x1at\x20The\x20Google\x20Cloud\x20Storage\
    \x20location\x20for\x20a\x20csv\x20file\x20which\x20preserves\x20a\x20li\
    st\x20of\n\x20ImportProductSetRequests\x20in\x20each\x20line.\n\n\x0b\n\
    \x03\x04\x18\x01\x12\x04\xce\x06\x08\"\n\x9f\x14\n\x04\x04\x18\x02\0\x12\
    \x04\x8c\x07\x02\x1a\x1a\x90\x14\x20The\x20Google\x20Cloud\x20Storage\
    \x20URI\x20of\x20the\x20input\x20csv\x20file.\n\n\x20The\x20URI\x20must\
    \x20start\x20with\x20`gs://`.\n\n\x20The\x20format\x20of\x20the\x20input\
    \x20csv\x20file\x20should\x20be\x20one\x20image\x20per\x20line.\n\x20In\
    \x20each\x20line,\x20there\x20are\x208\x20columns.\n\n\x201.\x20\x20imag\
    e-uri\n\x202.\x20\x20image-id\n\x203.\x20\x20product-set-id\n\x204.\x20\
    \x20product-id\n\x205.\x20\x20product-category\n\x206.\x20\x20product-di\
    splay-name\n\x207.\x20\x20labels\n\x208.\x20\x20bounding-poly\n\n\x20The\
    \x20`image-uri`,\x20`product-set-id`,\x20`product-id`,\x20and\x20`produc\
    t-category`\n\x20columns\x20are\x20required.\x20All\x20other\x20columns\
    \x20are\x20optional.\n\n\x20If\x20the\x20`ProductSet`\x20or\x20`Product`\
    \x20specified\x20by\x20the\x20`product-set-id`\x20and\n\x20`product-id`\
    \x20values\x20does\x20not\x20exist,\x20then\x20the\x20system\x20will\x20\
    create\x20a\x20new\n\x20`ProductSet`\x20or\x20`Product`\x20for\x20the\
    \x20image.\x20In\x20this\x20case,\x20the\n\x20`product-display-name`\x20\
    column\x20refers\x20to\n\x20[display_name][google.cloud.vision.v1.Produc\
    t.display_name],\x20the\n\x20`product-category`\x20column\x20refers\x20t\
    o\n\x20[product_category][google.cloud.vision.v1.Product.product_categor\
    y],\x20and\x20the\n\x20`labels`\x20column\x20refers\x20to\x20[product_la\
    bels][google.cloud.vision.v1.Product.product_labels].\n\n\x20The\x20`ima\
    ge-id`\x20column\x20is\x20optional\x20but\x20must\x20be\x20unique\x20if\
    \x20provided.\x20If\x20it\x20is\n\x20empty,\x20the\x20system\x20will\x20\
    automatically\x20assign\x20a\x20unique\x20id\x20to\x20the\x20image.\n\n\
    \x20The\x20`product-display-name`\x20column\x20is\x20optional.\x20If\x20\
    it\x20is\x20empty,\x20the\x20system\n\x20sets\x20the\x20[display_name][g\
    oogle.cloud.vision.v1.Product.display_name]\x20field\x20for\x20the\x20pr\
    oduct\x20to\x20a\n\x20space\x20(\"\x20\").\x20You\x20can\x20update\x20th\
    e\x20`display_name`\x20later\x20by\x20using\x20the\x20API.\n\n\x20If\x20\
    a\x20`Product`\x20with\x20the\x20specified\x20`product-id`\x20already\
    \x20exists,\x20then\x20the\n\x20system\x20ignores\x20the\x20`product-dis\
    play-name`,\x20`product-category`,\x20and\x20`labels`\n\x20columns.\n\n\
    \x20The\x20`labels`\x20column\x20(optional)\x20is\x20a\x20line\x20contai\
    ning\x20a\x20list\x20of\n\x20comma-separated\x20key-value\x20pairs,\x20i\
    n\x20the\x20following\x20format:\n\n\x20\x20\x20\x20\x20\"key_1=value_1,\
    key_2=value_2,...,key_n=value_n\"\n\n\x20The\x20`bounding-poly`\x20colum\
    n\x20(optional)\x20identifies\x20one\x20region\x20of\n\x20interest\x20fr\
    om\x20the\x20image\x20in\x20the\x20same\x20manner\x20as\x20`CreateRefere\
    nceImage`.\x20If\n\x20you\x20do\x20not\x20specify\x20the\x20`bounding-po\
    ly`\x20column,\x20then\x20the\x20system\x20will\x20try\x20to\n\x20detect\
    \x20regions\x20of\x20interest\x20automatically.\n\n\x20At\x20most\x20one\
    \x20`bounding-poly`\x20column\x20is\x20allowed\x20per\x20line.\x20If\x20\
    the\x20image\n\x20contains\x20multiple\x20regions\x20of\x20interest,\x20\
    add\x20a\x20line\x20to\x20the\x20CSV\x20file\x20that\n\x20includes\x20th\
    e\x20same\x20product\x20information,\x20and\x20the\x20`bounding-poly`\
    \x20values\x20for\n\x20each\x20region\x20of\x20interest.\n\n\x20The\x20`\
    bounding-poly`\x20column\x20must\x20contain\x20an\x20even\x20number\x20o\
    f\x20comma-separated\n\x20numbers,\x20in\x20the\x20format\x20\"p1_x,p1_y\
    ,p2_x,p2_y,...,pn_x,pn_y\".\x20Use\n\x20non-negative\x20integers\x20for\
    \x20absolute\x20bounding\x20polygons,\x20and\x20float\x20values\n\x20in\
    \x20[0,\x201]\x20for\x20normalized\x20bounding\x20polygons.\n\n\x20The\
    \x20system\x20will\x20resize\x20the\x20image\x20if\x20the\x20image\x20re\
    solution\x20is\x20too\n\x20large\x20to\x20process\x20(larger\x20than\x20\
    20MP).\n\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\x8c\x07\x02\x08\n\r\n\x05\
    \x04\x18\x02\0\x01\x12\x04\x8c\x07\t\x15\n\r\n\x05\x04\x18\x02\0\x03\x12\
    \x04\x8c\x07\x18\x19\nE\n\x02\x04\x19\x12\x06\x90\x07\0\x97\x07\x01\x1a7\
    \x20The\x20input\x20content\x20for\x20the\x20`ImportProductSets`\x20meth\
    od.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\x90\x07\x08$\n*\n\x04\x04\x19\x08\
    \0\x12\x06\x92\x07\x02\x96\x07\x03\x1a\x1a\x20The\x20source\x20of\x20the\
    \x20input.\n\n\r\n\x05\x04\x19\x08\0\x01\x12\x04\x92\x07\x08\x0e\n\x82\
    \x01\n\x04\x04\x19\x02\0\x12\x04\x95\x07\x04.\x1at\x20The\x20Google\x20C\
    loud\x20Storage\x20location\x20for\x20a\x20csv\x20file\x20which\x20prese\
    rves\x20a\x20list\n\x20of\x20ImportProductSetRequests\x20in\x20each\x20l\
    ine.\n\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\x95\x07\x04\x1e\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\x95\x07\x1f)\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \x95\x07,-\nC\n\x02\x04\x1a\x12\x06\x9a\x07\0\xa7\x07\x01\x1a5\x20Reques\
    t\x20message\x20for\x20the\x20`ImportProductSets`\x20method.\n\n\x0b\n\
    \x03\x04\x1a\x01\x12\x04\x9a\x07\x08\x20\n\x88\x01\n\x04\x04\x1a\x02\0\
    \x12\x06\x9e\x07\x02\xa3\x07\x04\x1ax\x20Required.\x20The\x20project\x20\
    in\x20which\x20the\x20ProductSets\x20should\x20be\x20imported.\n\n\x20Fo\
    rmat\x20is\x20`projects/PROJECT_ID/locations/LOC_ID`.\n\n\r\n\x05\x04\
    \x1a\x02\0\x05\x12\x04\x9e\x07\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\x9e\x07\t\x0f\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x9e\x07\x12\x13\n\
    \x0f\n\x05\x04\x1a\x02\0\x08\x12\x06\x9e\x07\x14\xa3\x07\x03\n\x10\n\x08\
    \x04\x1a\x02\0\x08\x9c\x08\0\x12\x04\x9f\x07\x04*\n\x11\n\x07\x04\x1a\
    \x02\0\x08\x9f\x08\x12\x06\xa0\x07\x04\xa2\x07\x05\nE\n\x04\x04\x1a\x02\
    \x01\x12\x04\xa6\x07\x02Y\x1a7\x20Required.\x20The\x20input\x20content\
    \x20for\x20the\x20list\x20of\x20requests.\n\n\r\n\x05\x04\x1a\x02\x01\
    \x06\x12\x04\xa6\x07\x02\x1e\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xa6\
    \x07\x1f+\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xa6\x07./\n\r\n\x05\x04\
    \x1a\x02\x01\x08\x12\x04\xa6\x070X\n\x10\n\x08\x04\x1a\x02\x01\x08\x9c\
    \x08\0\x12\x04\xa6\x071W\n\xaf\x02\n\x02\x04\x1b\x12\x06\xae\x07\0\xb9\
    \x07\x01\x1a\xa0\x02\x20Response\x20message\x20for\x20the\x20`ImportProd\
    uctSets`\x20method.\n\n\x20This\x20message\x20is\x20returned\x20by\x20th\
    e\n\x20[google.longrunning.Operations.GetOperation][google.longrunning.O\
    perations.GetOperation]\x20method\x20in\x20the\x20returned\n\x20[google.\
    longrunning.Operation.response][google.longrunning.Operation.response]\
    \x20field.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xae\x07\x08!\nL\n\x04\x04\
    \x1b\x02\0\x12\x04\xb0\x07\x02/\x1a>\x20The\x20list\x20of\x20reference_i\
    mages\x20that\x20are\x20imported\x20successfully.\n\n\r\n\x05\x04\x1b\
    \x02\0\x04\x12\x04\xb0\x07\x02\n\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xb0\
    \x07\x0b\x19\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xb0\x07\x1a*\n\r\n\x05\
    \x04\x1b\x02\0\x03\x12\x04\xb0\x07-.\n\xa8\x02\n\x04\x04\x1b\x02\x01\x12\
    \x04\xb8\x07\x02*\x1a\x99\x02\x20The\x20rpc\x20status\x20for\x20each\x20\
    ImportProductSet\x20request,\x20including\x20both\x20successes\n\x20and\
    \x20errors.\n\n\x20The\x20number\x20of\x20statuses\x20here\x20matches\
    \x20the\x20number\x20of\x20lines\x20in\x20the\x20csv\x20file,\n\x20and\
    \x20statuses[i]\x20stores\x20the\x20success\x20or\x20failure\x20status\
    \x20of\x20processing\x20the\x20i-th\n\x20line\x20of\x20the\x20csv,\x20st\
    arting\x20from\x20line\x200.\n\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xb8\
    \x07\x02\n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xb8\x07\x0b\x1c\n\r\n\
    \x05\x04\x1b\x02\x01\x01\x12\x04\xb8\x07\x1d%\n\r\n\x05\x04\x1b\x02\x01\
    \x03\x12\x04\xb8\x07()\n\xe2\x01\n\x02\x04\x1c\x12\x06\xbf\x07\0\xde\x07\
    \x01\x1a\xd3\x01\x20Metadata\x20for\x20the\x20batch\x20operations\x20suc\
    h\x20as\x20the\x20current\x20state.\n\n\x20This\x20is\x20included\x20in\
    \x20the\x20`metadata`\x20field\x20of\x20the\x20`Operation`\x20returned\
    \x20by\x20the\n\x20`GetOperation`\x20call\x20of\x20the\x20`google::longr\
    unning::Operations`\x20service.\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xbf\
    \x07\x08\x1e\nR\n\x04\x04\x1c\x04\0\x12\x06\xc1\x07\x02\xd3\x07\x03\x1aB\
    \x20Enumerates\x20the\x20possible\x20states\x20that\x20the\x20batch\x20r\
    equest\x20can\x20be\x20in.\n\n\r\n\x05\x04\x1c\x04\0\x01\x12\x04\xc1\x07\
    \x07\x0c\n\x1a\n\x06\x04\x1c\x04\0\x02\0\x12\x04\xc3\x07\x04\x1a\x1a\n\
    \x20Invalid.\n\n\x0f\n\x07\x04\x1c\x04\0\x02\0\x01\x12\x04\xc3\x07\x04\
    \x15\n\x0f\n\x07\x04\x1c\x04\0\x02\0\x02\x12\x04\xc3\x07\x18\x19\n6\n\
    \x06\x04\x1c\x04\0\x02\x01\x12\x04\xc6\x07\x04\x13\x1a&\x20Request\x20is\
    \x20actively\x20being\x20processed.\n\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\
    \x01\x12\x04\xc6\x07\x04\x0e\n\x0f\n\x07\x04\x1c\x04\0\x02\x01\x02\x12\
    \x04\xc6\x07\x11\x12\n]\n\x06\x04\x1c\x04\0\x02\x02\x12\x04\xca\x07\x04\
    \x13\x1aM\x20The\x20request\x20is\x20done\x20and\x20at\x20least\x20one\
    \x20item\x20has\x20been\x20successfully\n\x20processed.\n\n\x0f\n\x07\
    \x04\x1c\x04\0\x02\x02\x01\x12\x04\xca\x07\x04\x0e\n\x0f\n\x07\x04\x1c\
    \x04\0\x02\x02\x02\x12\x04\xca\x07\x11\x12\nR\n\x06\x04\x1c\x04\0\x02\
    \x03\x12\x04\xcd\x07\x04\x0f\x1aB\x20The\x20request\x20is\x20done\x20and\
    \x20no\x20item\x20has\x20been\x20successfully\x20processed.\n\n\x0f\n\
    \x07\x04\x1c\x04\0\x02\x03\x01\x12\x04\xcd\x07\x04\n\n\x0f\n\x07\x04\x1c\
    \x04\0\x02\x03\x02\x12\x04\xcd\x07\r\x0e\n\xd9\x01\n\x06\x04\x1c\x04\0\
    \x02\x04\x12\x04\xd2\x07\x04\x12\x1a\xc8\x01\x20The\x20request\x20is\x20\
    done\x20after\x20the\x20longrunning.Operations.CancelOperation\x20has\n\
    \x20been\x20called\x20by\x20the\x20user.\x20\x20Any\x20records\x20that\
    \x20were\x20processed\x20before\x20the\n\x20cancel\x20command\x20are\x20\
    output\x20as\x20specified\x20in\x20the\x20request.\n\n\x0f\n\x07\x04\x1c\
    \x04\0\x02\x04\x01\x12\x04\xd2\x07\x04\r\n\x0f\n\x07\x04\x1c\x04\0\x02\
    \x04\x02\x12\x04\xd2\x07\x10\x11\n9\n\x04\x04\x1c\x02\0\x12\x04\xd6\x07\
    \x02\x12\x1a+\x20The\x20current\x20state\x20of\x20the\x20batch\x20operat\
    ion.\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xd6\x07\x02\x07\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xd6\x07\x08\r\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\
    \xd6\x07\x10\x11\nL\n\x04\x04\x1c\x02\x01\x12\x04\xd9\x07\x02,\x1a>\x20T\
    he\x20time\x20when\x20the\x20batch\x20request\x20was\x20submitted\x20to\
    \x20the\x20server.\n\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xd9\x07\x02\
    \x1b\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xd9\x07\x1c'\n\r\n\x05\x04\
    \x1c\x02\x01\x03\x12\x04\xd9\x07*+\n\x98\x01\n\x04\x04\x1c\x02\x02\x12\
    \x04\xdd\x07\x02)\x1a\x89\x01\x20The\x20time\x20when\x20the\x20batch\x20\
    request\x20is\x20finished\x20and\n\x20[google.longrunning.Operation.done\
    ][google.longrunning.Operation.done]\x20is\x20set\x20to\x20true.\n\n\r\n\
    \x05\x04\x1c\x02\x02\x06\x12\x04\xdd\x07\x02\x1b\n\r\n\x05\x04\x1c\x02\
    \x02\x01\x12\x04\xdd\x07\x1c$\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xdd\
    \x07'(\nW\n\x02\x04\x1d\x12\x06\xe1\x07\0\xe6\x07\x01\x1aI\x20Config\x20\
    to\x20control\x20which\x20ProductSet\x20contains\x20the\x20Products\x20t\
    o\x20be\x20deleted.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe1\x07\x08\x1d\n\
    \xb7\x01\n\x04\x04\x1d\x02\0\x12\x04\xe5\x07\x02\x1c\x1a\xa8\x01\x20The\
    \x20ProductSet\x20that\x20contains\x20the\x20Products\x20to\x20delete.\
    \x20If\x20a\x20Product\x20is\x20a\n\x20member\x20of\x20product_set_id\
    \x20in\x20addition\x20to\x20other\x20ProductSets,\x20the\x20Product\x20w\
    ill\n\x20still\x20be\x20deleted.\n\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\
    \xe5\x07\x02\x08\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xe5\x07\t\x17\n\r\n\
    \x05\x04\x1d\x02\0\x03\x12\x04\xe5\x07\x1a\x1b\n?\n\x02\x04\x1e\x12\x06\
    \xe9\x07\0\x81\x08\x01\x1a1\x20Request\x20message\x20for\x20the\x20`Purg\
    eProducts`\x20method.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xe9\x07\x08\x1c\
    \n)\n\x04\x04\x1e\x08\0\x12\x06\xeb\x07\x02\xf2\x07\x03\x1a\x19\x20The\
    \x20Products\x20to\x20delete.\n\n\r\n\x05\x04\x1e\x08\0\x01\x12\x04\xeb\
    \x07\x08\x0e\nM\n\x04\x04\x1e\x02\0\x12\x04\xed\x07\x047\x1a?\x20Specify\
    \x20which\x20ProductSet\x20contains\x20the\x20Products\x20to\x20be\x20de\
    leted.\n\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xed\x07\x04\x19\n\r\n\x05\
    \x04\x1e\x02\0\x01\x12\x04\xed\x07\x1a2\n\r\n\x05\x04\x1e\x02\0\x03\x12\
    \x04\xed\x0756\np\n\x04\x04\x1e\x02\x01\x12\x04\xf1\x07\x04$\x1ab\x20If\
    \x20delete_orphan_products\x20is\x20true,\x20all\x20Products\x20that\x20\
    are\x20not\x20in\x20any\n\x20ProductSet\x20will\x20be\x20deleted.\n\n\r\
    \n\x05\x04\x1e\x02\x01\x05\x12\x04\xf1\x07\x04\x08\n\r\n\x05\x04\x1e\x02\
    \x01\x01\x12\x04\xf1\x07\t\x1f\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf1\
    \x07\"#\n\x92\x01\n\x04\x04\x1e\x02\x02\x12\x06\xf7\x07\x02\xfc\x07\x04\
    \x1a\x81\x01\x20Required.\x20The\x20project\x20and\x20location\x20in\x20\
    which\x20the\x20Products\x20should\x20be\x20deleted.\n\n\x20Format\x20is\
    \x20`projects/PROJECT_ID/locations/LOC_ID`.\n\n\r\n\x05\x04\x1e\x02\x02\
    \x05\x12\x04\xf7\x07\x02\x08\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xf7\
    \x07\t\x0f\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xf7\x07\x12\x13\n\x0f\n\
    \x05\x04\x1e\x02\x02\x08\x12\x06\xf7\x07\x14\xfc\x07\x03\n\x10\n\x08\x04\
    \x1e\x02\x02\x08\x9c\x08\0\x12\x04\xf8\x07\x04*\n\x11\n\x07\x04\x1e\x02\
    \x02\x08\x9f\x08\x12\x06\xf9\x07\x04\xfb\x07\x05\ng\n\x04\x04\x1e\x02\
    \x03\x12\x04\x80\x08\x02\x11\x1aY\x20The\x20default\x20value\x20is\x20fa\
    lse.\x20Override\x20this\x20value\x20to\x20true\x20to\x20actually\x20per\
    form\n\x20the\x20purge.\n\n\r\n\x05\x04\x1e\x02\x03\x05\x12\x04\x80\x08\
    \x02\x06\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\x80\x08\x07\x0c\n\r\n\x05\
    \x04\x1e\x02\x03\x03\x12\x04\x80\x08\x0f\x10b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}

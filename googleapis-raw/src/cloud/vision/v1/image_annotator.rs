// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/vision/v1/image_annotator.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Feature {
    // message fields
    pub field_type: Feature_Type,
    pub max_results: i32,
    pub model: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Feature {
    fn default() -> &'a Feature {
        <Feature as ::protobuf::Message>::default_instance()
    }
}

impl Feature {
    pub fn new() -> Feature {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.Feature.Type type = 1;


    pub fn get_field_type(&self) -> Feature_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Feature_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Feature_Type) {
        self.field_type = v;
    }

    // int32 max_results = 2;


    pub fn get_max_results(&self) -> i32 {
        self.max_results
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = v;
    }

    // string model = 3;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Feature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Feature_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.max_results != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Feature_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.max_results != 0 {
            os.write_int32(2, self.max_results)?;
        }
        if !self.model.is_empty() {
            os.write_string(3, &self.model)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Feature {
        Feature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Feature_Type>>(
                "type",
                |m: &Feature| { &m.field_type },
                |m: &mut Feature| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &Feature| { &m.max_results },
                |m: &mut Feature| { &mut m.max_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &Feature| { &m.model },
                |m: &mut Feature| { &mut m.model },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Feature>(
                "Feature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Feature {
        static instance: ::protobuf::rt::LazyV2<Feature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Feature::new)
    }
}

impl ::protobuf::Clear for Feature {
    fn clear(&mut self) {
        self.field_type = Feature_Type::TYPE_UNSPECIFIED;
        self.max_results = 0;
        self.model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Feature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Feature_Type {
    TYPE_UNSPECIFIED = 0,
    FACE_DETECTION = 1,
    LANDMARK_DETECTION = 2,
    LOGO_DETECTION = 3,
    LABEL_DETECTION = 4,
    TEXT_DETECTION = 5,
    DOCUMENT_TEXT_DETECTION = 11,
    SAFE_SEARCH_DETECTION = 6,
    IMAGE_PROPERTIES = 7,
    CROP_HINTS = 9,
    WEB_DETECTION = 10,
    PRODUCT_SEARCH = 12,
    OBJECT_LOCALIZATION = 19,
}

impl ::protobuf::ProtobufEnum for Feature_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Feature_Type> {
        match value {
            0 => ::std::option::Option::Some(Feature_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Feature_Type::FACE_DETECTION),
            2 => ::std::option::Option::Some(Feature_Type::LANDMARK_DETECTION),
            3 => ::std::option::Option::Some(Feature_Type::LOGO_DETECTION),
            4 => ::std::option::Option::Some(Feature_Type::LABEL_DETECTION),
            5 => ::std::option::Option::Some(Feature_Type::TEXT_DETECTION),
            11 => ::std::option::Option::Some(Feature_Type::DOCUMENT_TEXT_DETECTION),
            6 => ::std::option::Option::Some(Feature_Type::SAFE_SEARCH_DETECTION),
            7 => ::std::option::Option::Some(Feature_Type::IMAGE_PROPERTIES),
            9 => ::std::option::Option::Some(Feature_Type::CROP_HINTS),
            10 => ::std::option::Option::Some(Feature_Type::WEB_DETECTION),
            12 => ::std::option::Option::Some(Feature_Type::PRODUCT_SEARCH),
            19 => ::std::option::Option::Some(Feature_Type::OBJECT_LOCALIZATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Feature_Type] = &[
            Feature_Type::TYPE_UNSPECIFIED,
            Feature_Type::FACE_DETECTION,
            Feature_Type::LANDMARK_DETECTION,
            Feature_Type::LOGO_DETECTION,
            Feature_Type::LABEL_DETECTION,
            Feature_Type::TEXT_DETECTION,
            Feature_Type::DOCUMENT_TEXT_DETECTION,
            Feature_Type::SAFE_SEARCH_DETECTION,
            Feature_Type::IMAGE_PROPERTIES,
            Feature_Type::CROP_HINTS,
            Feature_Type::WEB_DETECTION,
            Feature_Type::PRODUCT_SEARCH,
            Feature_Type::OBJECT_LOCALIZATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Feature_Type>("Feature.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Feature_Type {
}

impl ::std::default::Default for Feature_Type {
    fn default() -> Self {
        Feature_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Feature_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageSource {
    // message fields
    pub gcs_image_uri: ::std::string::String,
    pub image_uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageSource {
    fn default() -> &'a ImageSource {
        <ImageSource as ::protobuf::Message>::default_instance()
    }
}

impl ImageSource {
    pub fn new() -> ImageSource {
        ::std::default::Default::default()
    }

    // string gcs_image_uri = 1;


    pub fn get_gcs_image_uri(&self) -> &str {
        &self.gcs_image_uri
    }
    pub fn clear_gcs_image_uri(&mut self) {
        self.gcs_image_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_gcs_image_uri(&mut self, v: ::std::string::String) {
        self.gcs_image_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcs_image_uri(&mut self) -> &mut ::std::string::String {
        &mut self.gcs_image_uri
    }

    // Take field
    pub fn take_gcs_image_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gcs_image_uri, ::std::string::String::new())
    }

    // string image_uri = 2;


    pub fn get_image_uri(&self) -> &str {
        &self.image_uri
    }
    pub fn clear_image_uri(&mut self) {
        self.image_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_uri(&mut self, v: ::std::string::String) {
        self.image_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_uri(&mut self) -> &mut ::std::string::String {
        &mut self.image_uri
    }

    // Take field
    pub fn take_image_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImageSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gcs_image_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gcs_image_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.gcs_image_uri);
        }
        if !self.image_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.image_uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gcs_image_uri.is_empty() {
            os.write_string(1, &self.gcs_image_uri)?;
        }
        if !self.image_uri.is_empty() {
            os.write_string(2, &self.image_uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageSource {
        ImageSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gcs_image_uri",
                |m: &ImageSource| { &m.gcs_image_uri },
                |m: &mut ImageSource| { &mut m.gcs_image_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_uri",
                |m: &ImageSource| { &m.image_uri },
                |m: &mut ImageSource| { &mut m.image_uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageSource>(
                "ImageSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageSource {
        static instance: ::protobuf::rt::LazyV2<ImageSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageSource::new)
    }
}

impl ::protobuf::Clear for ImageSource {
    fn clear(&mut self) {
        self.gcs_image_uri.clear();
        self.image_uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    pub source: ::protobuf::SingularPtrField<ImageSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }

    // .google.cloud.vision.v1.ImageSource source = 2;


    pub fn get_source(&self) -> &ImageSource {
        self.source.as_ref().unwrap_or_else(|| <ImageSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ImageSource) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ImageSource {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ImageSource {
        self.source.take().unwrap_or_else(|| ImageSource::new())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &Image| { &m.content },
                |m: &mut Image| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSource>>(
                "source",
                |m: &Image| { &m.source },
                |m: &mut Image| { &mut m.source },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.content.clear();
        self.source.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FaceAnnotation {
    // message fields
    pub bounding_poly: ::protobuf::SingularPtrField<super::geometry::BoundingPoly>,
    pub fd_bounding_poly: ::protobuf::SingularPtrField<super::geometry::BoundingPoly>,
    pub landmarks: ::protobuf::RepeatedField<FaceAnnotation_Landmark>,
    pub roll_angle: f32,
    pub pan_angle: f32,
    pub tilt_angle: f32,
    pub detection_confidence: f32,
    pub landmarking_confidence: f32,
    pub joy_likelihood: Likelihood,
    pub sorrow_likelihood: Likelihood,
    pub anger_likelihood: Likelihood,
    pub surprise_likelihood: Likelihood,
    pub under_exposed_likelihood: Likelihood,
    pub blurred_likelihood: Likelihood,
    pub headwear_likelihood: Likelihood,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FaceAnnotation {
    fn default() -> &'a FaceAnnotation {
        <FaceAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl FaceAnnotation {
    pub fn new() -> FaceAnnotation {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.BoundingPoly bounding_poly = 1;


    pub fn get_bounding_poly(&self) -> &super::geometry::BoundingPoly {
        self.bounding_poly.as_ref().unwrap_or_else(|| <super::geometry::BoundingPoly as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bounding_poly(&mut self) {
        self.bounding_poly.clear();
    }

    pub fn has_bounding_poly(&self) -> bool {
        self.bounding_poly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_poly(&mut self, v: super::geometry::BoundingPoly) {
        self.bounding_poly = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_poly(&mut self) -> &mut super::geometry::BoundingPoly {
        if self.bounding_poly.is_none() {
            self.bounding_poly.set_default();
        }
        self.bounding_poly.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_poly(&mut self) -> super::geometry::BoundingPoly {
        self.bounding_poly.take().unwrap_or_else(|| super::geometry::BoundingPoly::new())
    }

    // .google.cloud.vision.v1.BoundingPoly fd_bounding_poly = 2;


    pub fn get_fd_bounding_poly(&self) -> &super::geometry::BoundingPoly {
        self.fd_bounding_poly.as_ref().unwrap_or_else(|| <super::geometry::BoundingPoly as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fd_bounding_poly(&mut self) {
        self.fd_bounding_poly.clear();
    }

    pub fn has_fd_bounding_poly(&self) -> bool {
        self.fd_bounding_poly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd_bounding_poly(&mut self, v: super::geometry::BoundingPoly) {
        self.fd_bounding_poly = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fd_bounding_poly(&mut self) -> &mut super::geometry::BoundingPoly {
        if self.fd_bounding_poly.is_none() {
            self.fd_bounding_poly.set_default();
        }
        self.fd_bounding_poly.as_mut().unwrap()
    }

    // Take field
    pub fn take_fd_bounding_poly(&mut self) -> super::geometry::BoundingPoly {
        self.fd_bounding_poly.take().unwrap_or_else(|| super::geometry::BoundingPoly::new())
    }

    // repeated .google.cloud.vision.v1.FaceAnnotation.Landmark landmarks = 3;


    pub fn get_landmarks(&self) -> &[FaceAnnotation_Landmark] {
        &self.landmarks
    }
    pub fn clear_landmarks(&mut self) {
        self.landmarks.clear();
    }

    // Param is passed by value, moved
    pub fn set_landmarks(&mut self, v: ::protobuf::RepeatedField<FaceAnnotation_Landmark>) {
        self.landmarks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_landmarks(&mut self) -> &mut ::protobuf::RepeatedField<FaceAnnotation_Landmark> {
        &mut self.landmarks
    }

    // Take field
    pub fn take_landmarks(&mut self) -> ::protobuf::RepeatedField<FaceAnnotation_Landmark> {
        ::std::mem::replace(&mut self.landmarks, ::protobuf::RepeatedField::new())
    }

    // float roll_angle = 4;


    pub fn get_roll_angle(&self) -> f32 {
        self.roll_angle
    }
    pub fn clear_roll_angle(&mut self) {
        self.roll_angle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_angle(&mut self, v: f32) {
        self.roll_angle = v;
    }

    // float pan_angle = 5;


    pub fn get_pan_angle(&self) -> f32 {
        self.pan_angle
    }
    pub fn clear_pan_angle(&mut self) {
        self.pan_angle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pan_angle(&mut self, v: f32) {
        self.pan_angle = v;
    }

    // float tilt_angle = 6;


    pub fn get_tilt_angle(&self) -> f32 {
        self.tilt_angle
    }
    pub fn clear_tilt_angle(&mut self) {
        self.tilt_angle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tilt_angle(&mut self, v: f32) {
        self.tilt_angle = v;
    }

    // float detection_confidence = 7;


    pub fn get_detection_confidence(&self) -> f32 {
        self.detection_confidence
    }
    pub fn clear_detection_confidence(&mut self) {
        self.detection_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_detection_confidence(&mut self, v: f32) {
        self.detection_confidence = v;
    }

    // float landmarking_confidence = 8;


    pub fn get_landmarking_confidence(&self) -> f32 {
        self.landmarking_confidence
    }
    pub fn clear_landmarking_confidence(&mut self) {
        self.landmarking_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_landmarking_confidence(&mut self, v: f32) {
        self.landmarking_confidence = v;
    }

    // .google.cloud.vision.v1.Likelihood joy_likelihood = 9;


    pub fn get_joy_likelihood(&self) -> Likelihood {
        self.joy_likelihood
    }
    pub fn clear_joy_likelihood(&mut self) {
        self.joy_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_joy_likelihood(&mut self, v: Likelihood) {
        self.joy_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood sorrow_likelihood = 10;


    pub fn get_sorrow_likelihood(&self) -> Likelihood {
        self.sorrow_likelihood
    }
    pub fn clear_sorrow_likelihood(&mut self) {
        self.sorrow_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_sorrow_likelihood(&mut self, v: Likelihood) {
        self.sorrow_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood anger_likelihood = 11;


    pub fn get_anger_likelihood(&self) -> Likelihood {
        self.anger_likelihood
    }
    pub fn clear_anger_likelihood(&mut self) {
        self.anger_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_anger_likelihood(&mut self, v: Likelihood) {
        self.anger_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood surprise_likelihood = 12;


    pub fn get_surprise_likelihood(&self) -> Likelihood {
        self.surprise_likelihood
    }
    pub fn clear_surprise_likelihood(&mut self) {
        self.surprise_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_surprise_likelihood(&mut self, v: Likelihood) {
        self.surprise_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood under_exposed_likelihood = 13;


    pub fn get_under_exposed_likelihood(&self) -> Likelihood {
        self.under_exposed_likelihood
    }
    pub fn clear_under_exposed_likelihood(&mut self) {
        self.under_exposed_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_under_exposed_likelihood(&mut self, v: Likelihood) {
        self.under_exposed_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood blurred_likelihood = 14;


    pub fn get_blurred_likelihood(&self) -> Likelihood {
        self.blurred_likelihood
    }
    pub fn clear_blurred_likelihood(&mut self) {
        self.blurred_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_blurred_likelihood(&mut self, v: Likelihood) {
        self.blurred_likelihood = v;
    }

    // .google.cloud.vision.v1.Likelihood headwear_likelihood = 15;


    pub fn get_headwear_likelihood(&self) -> Likelihood {
        self.headwear_likelihood
    }
    pub fn clear_headwear_likelihood(&mut self) {
        self.headwear_likelihood = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_headwear_likelihood(&mut self, v: Likelihood) {
        self.headwear_likelihood = v;
    }
}

impl ::protobuf::Message for FaceAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_poly {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fd_bounding_poly {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.landmarks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_poly)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fd_bounding_poly)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.landmarks)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_angle = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pan_angle = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tilt_angle = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.detection_confidence = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.landmarking_confidence = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.joy_likelihood, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sorrow_likelihood, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.anger_likelihood, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.surprise_likelihood, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.under_exposed_likelihood, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.blurred_likelihood, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.headwear_likelihood, 15, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bounding_poly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fd_bounding_poly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.landmarks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.roll_angle != 0. {
            my_size += 5;
        }
        if self.pan_angle != 0. {
            my_size += 5;
        }
        if self.tilt_angle != 0. {
            my_size += 5;
        }
        if self.detection_confidence != 0. {
            my_size += 5;
        }
        if self.landmarking_confidence != 0. {
            my_size += 5;
        }
        if self.joy_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(9, self.joy_likelihood);
        }
        if self.sorrow_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.sorrow_likelihood);
        }
        if self.anger_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(11, self.anger_likelihood);
        }
        if self.surprise_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(12, self.surprise_likelihood);
        }
        if self.under_exposed_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(13, self.under_exposed_likelihood);
        }
        if self.blurred_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(14, self.blurred_likelihood);
        }
        if self.headwear_likelihood != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(15, self.headwear_likelihood);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bounding_poly.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fd_bounding_poly.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.landmarks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.roll_angle != 0. {
            os.write_float(4, self.roll_angle)?;
        }
        if self.pan_angle != 0. {
            os.write_float(5, self.pan_angle)?;
        }
        if self.tilt_angle != 0. {
            os.write_float(6, self.tilt_angle)?;
        }
        if self.detection_confidence != 0. {
            os.write_float(7, self.detection_confidence)?;
        }
        if self.landmarking_confidence != 0. {
            os.write_float(8, self.landmarking_confidence)?;
        }
        if self.joy_likelihood != Likelihood::UNKNOWN {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.joy_likelihood))?;
        }
        if self.sorrow_likelihood != Likelihood::UNKNOWN {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.sorrow_likelihood))?;
        }
        if self.anger_likelihood != Likelihood::UNKNOWN {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.anger_likelihood))?;
        }
        if self.surprise_likelihood != Likelihood::UNKNOWN {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.surprise_likelihood))?;
        }
        if self.under_exposed_likelihood != Likelihood::UNKNOWN {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.under_exposed_likelihood))?;
        }
        if self.blurred_likelihood != Likelihood::UNKNOWN {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.blurred_likelihood))?;
        }
        if self.headwear_likelihood != Likelihood::UNKNOWN {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.headwear_likelihood))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FaceAnnotation {
        FaceAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "bounding_poly",
                |m: &FaceAnnotation| { &m.bounding_poly },
                |m: &mut FaceAnnotation| { &mut m.bounding_poly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "fd_bounding_poly",
                |m: &FaceAnnotation| { &m.fd_bounding_poly },
                |m: &mut FaceAnnotation| { &mut m.fd_bounding_poly },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FaceAnnotation_Landmark>>(
                "landmarks",
                |m: &FaceAnnotation| { &m.landmarks },
                |m: &mut FaceAnnotation| { &mut m.landmarks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "roll_angle",
                |m: &FaceAnnotation| { &m.roll_angle },
                |m: &mut FaceAnnotation| { &mut m.roll_angle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pan_angle",
                |m: &FaceAnnotation| { &m.pan_angle },
                |m: &mut FaceAnnotation| { &mut m.pan_angle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tilt_angle",
                |m: &FaceAnnotation| { &m.tilt_angle },
                |m: &mut FaceAnnotation| { &mut m.tilt_angle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "detection_confidence",
                |m: &FaceAnnotation| { &m.detection_confidence },
                |m: &mut FaceAnnotation| { &mut m.detection_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "landmarking_confidence",
                |m: &FaceAnnotation| { &m.landmarking_confidence },
                |m: &mut FaceAnnotation| { &mut m.landmarking_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "joy_likelihood",
                |m: &FaceAnnotation| { &m.joy_likelihood },
                |m: &mut FaceAnnotation| { &mut m.joy_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "sorrow_likelihood",
                |m: &FaceAnnotation| { &m.sorrow_likelihood },
                |m: &mut FaceAnnotation| { &mut m.sorrow_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "anger_likelihood",
                |m: &FaceAnnotation| { &m.anger_likelihood },
                |m: &mut FaceAnnotation| { &mut m.anger_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "surprise_likelihood",
                |m: &FaceAnnotation| { &m.surprise_likelihood },
                |m: &mut FaceAnnotation| { &mut m.surprise_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "under_exposed_likelihood",
                |m: &FaceAnnotation| { &m.under_exposed_likelihood },
                |m: &mut FaceAnnotation| { &mut m.under_exposed_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "blurred_likelihood",
                |m: &FaceAnnotation| { &m.blurred_likelihood },
                |m: &mut FaceAnnotation| { &mut m.blurred_likelihood },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "headwear_likelihood",
                |m: &FaceAnnotation| { &m.headwear_likelihood },
                |m: &mut FaceAnnotation| { &mut m.headwear_likelihood },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FaceAnnotation>(
                "FaceAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FaceAnnotation {
        static instance: ::protobuf::rt::LazyV2<FaceAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FaceAnnotation::new)
    }
}

impl ::protobuf::Clear for FaceAnnotation {
    fn clear(&mut self) {
        self.bounding_poly.clear();
        self.fd_bounding_poly.clear();
        self.landmarks.clear();
        self.roll_angle = 0.;
        self.pan_angle = 0.;
        self.tilt_angle = 0.;
        self.detection_confidence = 0.;
        self.landmarking_confidence = 0.;
        self.joy_likelihood = Likelihood::UNKNOWN;
        self.sorrow_likelihood = Likelihood::UNKNOWN;
        self.anger_likelihood = Likelihood::UNKNOWN;
        self.surprise_likelihood = Likelihood::UNKNOWN;
        self.under_exposed_likelihood = Likelihood::UNKNOWN;
        self.blurred_likelihood = Likelihood::UNKNOWN;
        self.headwear_likelihood = Likelihood::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FaceAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FaceAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FaceAnnotation_Landmark {
    // message fields
    pub field_type: FaceAnnotation_Landmark_Type,
    pub position: ::protobuf::SingularPtrField<super::geometry::Position>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FaceAnnotation_Landmark {
    fn default() -> &'a FaceAnnotation_Landmark {
        <FaceAnnotation_Landmark as ::protobuf::Message>::default_instance()
    }
}

impl FaceAnnotation_Landmark {
    pub fn new() -> FaceAnnotation_Landmark {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.FaceAnnotation.Landmark.Type type = 3;


    pub fn get_field_type(&self) -> FaceAnnotation_Landmark_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FaceAnnotation_Landmark_Type) {
        self.field_type = v;
    }

    // .google.cloud.vision.v1.Position position = 4;


    pub fn get_position(&self) -> &super::geometry::Position {
        self.position.as_ref().unwrap_or_else(|| <super::geometry::Position as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::geometry::Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::geometry::Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::geometry::Position {
        self.position.take().unwrap_or_else(|| super::geometry::Position::new())
    }
}

impl ::protobuf::Message for FaceAnnotation_Landmark {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FaceAnnotation_Landmark {
        FaceAnnotation_Landmark::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FaceAnnotation_Landmark_Type>>(
                "type",
                |m: &FaceAnnotation_Landmark| { &m.field_type },
                |m: &mut FaceAnnotation_Landmark| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::Position>>(
                "position",
                |m: &FaceAnnotation_Landmark| { &m.position },
                |m: &mut FaceAnnotation_Landmark| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FaceAnnotation_Landmark>(
                "FaceAnnotation.Landmark",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FaceAnnotation_Landmark {
        static instance: ::protobuf::rt::LazyV2<FaceAnnotation_Landmark> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FaceAnnotation_Landmark::new)
    }
}

impl ::protobuf::Clear for FaceAnnotation_Landmark {
    fn clear(&mut self) {
        self.field_type = FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK;
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FaceAnnotation_Landmark {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FaceAnnotation_Landmark {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FaceAnnotation_Landmark_Type {
    UNKNOWN_LANDMARK = 0,
    LEFT_EYE = 1,
    RIGHT_EYE = 2,
    LEFT_OF_LEFT_EYEBROW = 3,
    RIGHT_OF_LEFT_EYEBROW = 4,
    LEFT_OF_RIGHT_EYEBROW = 5,
    RIGHT_OF_RIGHT_EYEBROW = 6,
    MIDPOINT_BETWEEN_EYES = 7,
    NOSE_TIP = 8,
    UPPER_LIP = 9,
    LOWER_LIP = 10,
    MOUTH_LEFT = 11,
    MOUTH_RIGHT = 12,
    MOUTH_CENTER = 13,
    NOSE_BOTTOM_RIGHT = 14,
    NOSE_BOTTOM_LEFT = 15,
    NOSE_BOTTOM_CENTER = 16,
    LEFT_EYE_TOP_BOUNDARY = 17,
    LEFT_EYE_RIGHT_CORNER = 18,
    LEFT_EYE_BOTTOM_BOUNDARY = 19,
    LEFT_EYE_LEFT_CORNER = 20,
    RIGHT_EYE_TOP_BOUNDARY = 21,
    RIGHT_EYE_RIGHT_CORNER = 22,
    RIGHT_EYE_BOTTOM_BOUNDARY = 23,
    RIGHT_EYE_LEFT_CORNER = 24,
    LEFT_EYEBROW_UPPER_MIDPOINT = 25,
    RIGHT_EYEBROW_UPPER_MIDPOINT = 26,
    LEFT_EAR_TRAGION = 27,
    RIGHT_EAR_TRAGION = 28,
    LEFT_EYE_PUPIL = 29,
    RIGHT_EYE_PUPIL = 30,
    FOREHEAD_GLABELLA = 31,
    CHIN_GNATHION = 32,
    CHIN_LEFT_GONION = 33,
    CHIN_RIGHT_GONION = 34,
}

impl ::protobuf::ProtobufEnum for FaceAnnotation_Landmark_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FaceAnnotation_Landmark_Type> {
        match value {
            0 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK),
            1 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE),
            2 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE),
            3 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_OF_LEFT_EYEBROW),
            4 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_OF_LEFT_EYEBROW),
            5 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_OF_RIGHT_EYEBROW),
            6 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_OF_RIGHT_EYEBROW),
            7 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::MIDPOINT_BETWEEN_EYES),
            8 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::NOSE_TIP),
            9 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::UPPER_LIP),
            10 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LOWER_LIP),
            11 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::MOUTH_LEFT),
            12 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::MOUTH_RIGHT),
            13 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::MOUTH_CENTER),
            14 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::NOSE_BOTTOM_RIGHT),
            15 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::NOSE_BOTTOM_LEFT),
            16 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::NOSE_BOTTOM_CENTER),
            17 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE_TOP_BOUNDARY),
            18 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE_RIGHT_CORNER),
            19 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE_BOTTOM_BOUNDARY),
            20 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE_LEFT_CORNER),
            21 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE_TOP_BOUNDARY),
            22 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE_RIGHT_CORNER),
            23 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE_BOTTOM_BOUNDARY),
            24 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE_LEFT_CORNER),
            25 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYEBROW_UPPER_MIDPOINT),
            26 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYEBROW_UPPER_MIDPOINT),
            27 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EAR_TRAGION),
            28 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EAR_TRAGION),
            29 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::LEFT_EYE_PUPIL),
            30 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::RIGHT_EYE_PUPIL),
            31 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::FOREHEAD_GLABELLA),
            32 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::CHIN_GNATHION),
            33 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::CHIN_LEFT_GONION),
            34 => ::std::option::Option::Some(FaceAnnotation_Landmark_Type::CHIN_RIGHT_GONION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FaceAnnotation_Landmark_Type] = &[
            FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK,
            FaceAnnotation_Landmark_Type::LEFT_EYE,
            FaceAnnotation_Landmark_Type::RIGHT_EYE,
            FaceAnnotation_Landmark_Type::LEFT_OF_LEFT_EYEBROW,
            FaceAnnotation_Landmark_Type::RIGHT_OF_LEFT_EYEBROW,
            FaceAnnotation_Landmark_Type::LEFT_OF_RIGHT_EYEBROW,
            FaceAnnotation_Landmark_Type::RIGHT_OF_RIGHT_EYEBROW,
            FaceAnnotation_Landmark_Type::MIDPOINT_BETWEEN_EYES,
            FaceAnnotation_Landmark_Type::NOSE_TIP,
            FaceAnnotation_Landmark_Type::UPPER_LIP,
            FaceAnnotation_Landmark_Type::LOWER_LIP,
            FaceAnnotation_Landmark_Type::MOUTH_LEFT,
            FaceAnnotation_Landmark_Type::MOUTH_RIGHT,
            FaceAnnotation_Landmark_Type::MOUTH_CENTER,
            FaceAnnotation_Landmark_Type::NOSE_BOTTOM_RIGHT,
            FaceAnnotation_Landmark_Type::NOSE_BOTTOM_LEFT,
            FaceAnnotation_Landmark_Type::NOSE_BOTTOM_CENTER,
            FaceAnnotation_Landmark_Type::LEFT_EYE_TOP_BOUNDARY,
            FaceAnnotation_Landmark_Type::LEFT_EYE_RIGHT_CORNER,
            FaceAnnotation_Landmark_Type::LEFT_EYE_BOTTOM_BOUNDARY,
            FaceAnnotation_Landmark_Type::LEFT_EYE_LEFT_CORNER,
            FaceAnnotation_Landmark_Type::RIGHT_EYE_TOP_BOUNDARY,
            FaceAnnotation_Landmark_Type::RIGHT_EYE_RIGHT_CORNER,
            FaceAnnotation_Landmark_Type::RIGHT_EYE_BOTTOM_BOUNDARY,
            FaceAnnotation_Landmark_Type::RIGHT_EYE_LEFT_CORNER,
            FaceAnnotation_Landmark_Type::LEFT_EYEBROW_UPPER_MIDPOINT,
            FaceAnnotation_Landmark_Type::RIGHT_EYEBROW_UPPER_MIDPOINT,
            FaceAnnotation_Landmark_Type::LEFT_EAR_TRAGION,
            FaceAnnotation_Landmark_Type::RIGHT_EAR_TRAGION,
            FaceAnnotation_Landmark_Type::LEFT_EYE_PUPIL,
            FaceAnnotation_Landmark_Type::RIGHT_EYE_PUPIL,
            FaceAnnotation_Landmark_Type::FOREHEAD_GLABELLA,
            FaceAnnotation_Landmark_Type::CHIN_GNATHION,
            FaceAnnotation_Landmark_Type::CHIN_LEFT_GONION,
            FaceAnnotation_Landmark_Type::CHIN_RIGHT_GONION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FaceAnnotation_Landmark_Type>("FaceAnnotation.Landmark.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FaceAnnotation_Landmark_Type {
}

impl ::std::default::Default for FaceAnnotation_Landmark_Type {
    fn default() -> Self {
        FaceAnnotation_Landmark_Type::UNKNOWN_LANDMARK
    }
}

impl ::protobuf::reflect::ProtobufValue for FaceAnnotation_Landmark_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocationInfo {
    // message fields
    pub lat_lng: ::protobuf::SingularPtrField<super::latlng::LatLng>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocationInfo {
    fn default() -> &'a LocationInfo {
        <LocationInfo as ::protobuf::Message>::default_instance()
    }
}

impl LocationInfo {
    pub fn new() -> LocationInfo {
        ::std::default::Default::default()
    }

    // .google.type.LatLng lat_lng = 1;


    pub fn get_lat_lng(&self) -> &super::latlng::LatLng {
        self.lat_lng.as_ref().unwrap_or_else(|| <super::latlng::LatLng as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lat_lng(&mut self) {
        self.lat_lng.clear();
    }

    pub fn has_lat_lng(&self) -> bool {
        self.lat_lng.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_lng(&mut self, v: super::latlng::LatLng) {
        self.lat_lng = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lat_lng(&mut self) -> &mut super::latlng::LatLng {
        if self.lat_lng.is_none() {
            self.lat_lng.set_default();
        }
        self.lat_lng.as_mut().unwrap()
    }

    // Take field
    pub fn take_lat_lng(&mut self) -> super::latlng::LatLng {
        self.lat_lng.take().unwrap_or_else(|| super::latlng::LatLng::new())
    }
}

impl ::protobuf::Message for LocationInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.lat_lng {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lat_lng)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lat_lng.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lat_lng.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocationInfo {
        LocationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::latlng::LatLng>>(
                "lat_lng",
                |m: &LocationInfo| { &m.lat_lng },
                |m: &mut LocationInfo| { &mut m.lat_lng },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocationInfo>(
                "LocationInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocationInfo {
        static instance: ::protobuf::rt::LazyV2<LocationInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocationInfo::new)
    }
}

impl ::protobuf::Clear for LocationInfo {
    fn clear(&mut self) {
        self.lat_lng.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Property {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::string::String,
    pub uint64_value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Property {
    fn default() -> &'a Property {
        <Property as ::protobuf::Message>::default_instance()
    }
}

impl Property {
    pub fn new() -> Property {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // uint64 uint64_value = 3;


    pub fn get_uint64_value(&self) -> u64 {
        self.uint64_value
    }
    pub fn clear_uint64_value(&mut self) {
        self.uint64_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_uint64_value(&mut self, v: u64) {
        self.uint64_value = v;
    }
}

impl ::protobuf::Message for Property {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uint64_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.uint64_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.uint64_value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.uint64_value != 0 {
            os.write_uint64(3, self.uint64_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Property {
        Property::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Property| { &m.name },
                |m: &mut Property| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Property| { &m.value },
                |m: &mut Property| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "uint64_value",
                |m: &Property| { &m.uint64_value },
                |m: &mut Property| { &mut m.uint64_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Property>(
                "Property",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Property {
        static instance: ::protobuf::rt::LazyV2<Property> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Property::new)
    }
}

impl ::protobuf::Clear for Property {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.uint64_value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Property {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Property {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityAnnotation {
    // message fields
    pub mid: ::std::string::String,
    pub locale: ::std::string::String,
    pub description: ::std::string::String,
    pub score: f32,
    pub confidence: f32,
    pub topicality: f32,
    pub bounding_poly: ::protobuf::SingularPtrField<super::geometry::BoundingPoly>,
    pub locations: ::protobuf::RepeatedField<LocationInfo>,
    pub properties: ::protobuf::RepeatedField<Property>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityAnnotation {
    fn default() -> &'a EntityAnnotation {
        <EntityAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl EntityAnnotation {
    pub fn new() -> EntityAnnotation {
        ::std::default::Default::default()
    }

    // string mid = 1;


    pub fn get_mid(&self) -> &str {
        &self.mid
    }
    pub fn clear_mid(&mut self) {
        self.mid.clear();
    }

    // Param is passed by value, moved
    pub fn set_mid(&mut self, v: ::std::string::String) {
        self.mid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid(&mut self) -> &mut ::std::string::String {
        &mut self.mid
    }

    // Take field
    pub fn take_mid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mid, ::std::string::String::new())
    }

    // string locale = 2;


    pub fn get_locale(&self) -> &str {
        &self.locale
    }
    pub fn clear_locale(&mut self) {
        self.locale.clear();
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        &mut self.locale
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.locale, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // float score = 4;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // float confidence = 5;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }

    // float topicality = 6;


    pub fn get_topicality(&self) -> f32 {
        self.topicality
    }
    pub fn clear_topicality(&mut self) {
        self.topicality = 0.;
    }

    // Param is passed by value, moved
    pub fn set_topicality(&mut self, v: f32) {
        self.topicality = v;
    }

    // .google.cloud.vision.v1.BoundingPoly bounding_poly = 7;


    pub fn get_bounding_poly(&self) -> &super::geometry::BoundingPoly {
        self.bounding_poly.as_ref().unwrap_or_else(|| <super::geometry::BoundingPoly as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bounding_poly(&mut self) {
        self.bounding_poly.clear();
    }

    pub fn has_bounding_poly(&self) -> bool {
        self.bounding_poly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_poly(&mut self, v: super::geometry::BoundingPoly) {
        self.bounding_poly = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_poly(&mut self) -> &mut super::geometry::BoundingPoly {
        if self.bounding_poly.is_none() {
            self.bounding_poly.set_default();
        }
        self.bounding_poly.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_poly(&mut self) -> super::geometry::BoundingPoly {
        self.bounding_poly.take().unwrap_or_else(|| super::geometry::BoundingPoly::new())
    }

    // repeated .google.cloud.vision.v1.LocationInfo locations = 8;


    pub fn get_locations(&self) -> &[LocationInfo] {
        &self.locations
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: ::protobuf::RepeatedField<LocationInfo>) {
        self.locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locations(&mut self) -> &mut ::protobuf::RepeatedField<LocationInfo> {
        &mut self.locations
    }

    // Take field
    pub fn take_locations(&mut self) -> ::protobuf::RepeatedField<LocationInfo> {
        ::std::mem::replace(&mut self.locations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.Property properties = 9;


    pub fn get_properties(&self) -> &[Property] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EntityAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_poly {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.locale)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.topicality = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_poly)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locations)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mid);
        }
        if !self.locale.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.locale);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.score != 0. {
            my_size += 5;
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        if self.topicality != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.bounding_poly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mid.is_empty() {
            os.write_string(1, &self.mid)?;
        }
        if !self.locale.is_empty() {
            os.write_string(2, &self.locale)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.score != 0. {
            os.write_float(4, self.score)?;
        }
        if self.confidence != 0. {
            os.write_float(5, self.confidence)?;
        }
        if self.topicality != 0. {
            os.write_float(6, self.topicality)?;
        }
        if let Some(ref v) = self.bounding_poly.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.locations {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.properties {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityAnnotation {
        EntityAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mid",
                |m: &EntityAnnotation| { &m.mid },
                |m: &mut EntityAnnotation| { &mut m.mid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locale",
                |m: &EntityAnnotation| { &m.locale },
                |m: &mut EntityAnnotation| { &mut m.locale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &EntityAnnotation| { &m.description },
                |m: &mut EntityAnnotation| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &EntityAnnotation| { &m.score },
                |m: &mut EntityAnnotation| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "confidence",
                |m: &EntityAnnotation| { &m.confidence },
                |m: &mut EntityAnnotation| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "topicality",
                |m: &EntityAnnotation| { &m.topicality },
                |m: &mut EntityAnnotation| { &mut m.topicality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "bounding_poly",
                |m: &EntityAnnotation| { &m.bounding_poly },
                |m: &mut EntityAnnotation| { &mut m.bounding_poly },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocationInfo>>(
                "locations",
                |m: &EntityAnnotation| { &m.locations },
                |m: &mut EntityAnnotation| { &mut m.locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                "properties",
                |m: &EntityAnnotation| { &m.properties },
                |m: &mut EntityAnnotation| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntityAnnotation>(
                "EntityAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntityAnnotation {
        static instance: ::protobuf::rt::LazyV2<EntityAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntityAnnotation::new)
    }
}

impl ::protobuf::Clear for EntityAnnotation {
    fn clear(&mut self) {
        self.mid.clear();
        self.locale.clear();
        self.description.clear();
        self.score = 0.;
        self.confidence = 0.;
        self.topicality = 0.;
        self.bounding_poly.clear();
        self.locations.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalizedObjectAnnotation {
    // message fields
    pub mid: ::std::string::String,
    pub language_code: ::std::string::String,
    pub name: ::std::string::String,
    pub score: f32,
    pub bounding_poly: ::protobuf::SingularPtrField<super::geometry::BoundingPoly>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalizedObjectAnnotation {
    fn default() -> &'a LocalizedObjectAnnotation {
        <LocalizedObjectAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl LocalizedObjectAnnotation {
    pub fn new() -> LocalizedObjectAnnotation {
        ::std::default::Default::default()
    }

    // string mid = 1;


    pub fn get_mid(&self) -> &str {
        &self.mid
    }
    pub fn clear_mid(&mut self) {
        self.mid.clear();
    }

    // Param is passed by value, moved
    pub fn set_mid(&mut self, v: ::std::string::String) {
        self.mid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid(&mut self) -> &mut ::std::string::String {
        &mut self.mid
    }

    // Take field
    pub fn take_mid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mid, ::std::string::String::new())
    }

    // string language_code = 2;


    pub fn get_language_code(&self) -> &str {
        &self.language_code
    }
    pub fn clear_language_code(&mut self) {
        self.language_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        &mut self.language_code
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language_code, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // float score = 4;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // .google.cloud.vision.v1.BoundingPoly bounding_poly = 5;


    pub fn get_bounding_poly(&self) -> &super::geometry::BoundingPoly {
        self.bounding_poly.as_ref().unwrap_or_else(|| <super::geometry::BoundingPoly as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bounding_poly(&mut self) {
        self.bounding_poly.clear();
    }

    pub fn has_bounding_poly(&self) -> bool {
        self.bounding_poly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_poly(&mut self, v: super::geometry::BoundingPoly) {
        self.bounding_poly = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_poly(&mut self) -> &mut super::geometry::BoundingPoly {
        if self.bounding_poly.is_none() {
            self.bounding_poly.set_default();
        }
        self.bounding_poly.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_poly(&mut self) -> super::geometry::BoundingPoly {
        self.bounding_poly.take().unwrap_or_else(|| super::geometry::BoundingPoly::new())
    }
}

impl ::protobuf::Message for LocalizedObjectAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_poly {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language_code)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_poly)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mid);
        }
        if !self.language_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language_code);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.score != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.bounding_poly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mid.is_empty() {
            os.write_string(1, &self.mid)?;
        }
        if !self.language_code.is_empty() {
            os.write_string(2, &self.language_code)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.score != 0. {
            os.write_float(4, self.score)?;
        }
        if let Some(ref v) = self.bounding_poly.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalizedObjectAnnotation {
        LocalizedObjectAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mid",
                |m: &LocalizedObjectAnnotation| { &m.mid },
                |m: &mut LocalizedObjectAnnotation| { &mut m.mid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language_code",
                |m: &LocalizedObjectAnnotation| { &m.language_code },
                |m: &mut LocalizedObjectAnnotation| { &mut m.language_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LocalizedObjectAnnotation| { &m.name },
                |m: &mut LocalizedObjectAnnotation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &LocalizedObjectAnnotation| { &m.score },
                |m: &mut LocalizedObjectAnnotation| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "bounding_poly",
                |m: &LocalizedObjectAnnotation| { &m.bounding_poly },
                |m: &mut LocalizedObjectAnnotation| { &mut m.bounding_poly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalizedObjectAnnotation>(
                "LocalizedObjectAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalizedObjectAnnotation {
        static instance: ::protobuf::rt::LazyV2<LocalizedObjectAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalizedObjectAnnotation::new)
    }
}

impl ::protobuf::Clear for LocalizedObjectAnnotation {
    fn clear(&mut self) {
        self.mid.clear();
        self.language_code.clear();
        self.name.clear();
        self.score = 0.;
        self.bounding_poly.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalizedObjectAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalizedObjectAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SafeSearchAnnotation {
    // message fields
    pub adult: Likelihood,
    pub spoof: Likelihood,
    pub medical: Likelihood,
    pub violence: Likelihood,
    pub racy: Likelihood,
    pub adult_confidence: f32,
    pub spoof_confidence: f32,
    pub medical_confidence: f32,
    pub violence_confidence: f32,
    pub racy_confidence: f32,
    pub nsfw_confidence: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SafeSearchAnnotation {
    fn default() -> &'a SafeSearchAnnotation {
        <SafeSearchAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl SafeSearchAnnotation {
    pub fn new() -> SafeSearchAnnotation {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.Likelihood adult = 1;


    pub fn get_adult(&self) -> Likelihood {
        self.adult
    }
    pub fn clear_adult(&mut self) {
        self.adult = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_adult(&mut self, v: Likelihood) {
        self.adult = v;
    }

    // .google.cloud.vision.v1.Likelihood spoof = 2;


    pub fn get_spoof(&self) -> Likelihood {
        self.spoof
    }
    pub fn clear_spoof(&mut self) {
        self.spoof = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_spoof(&mut self, v: Likelihood) {
        self.spoof = v;
    }

    // .google.cloud.vision.v1.Likelihood medical = 3;


    pub fn get_medical(&self) -> Likelihood {
        self.medical
    }
    pub fn clear_medical(&mut self) {
        self.medical = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_medical(&mut self, v: Likelihood) {
        self.medical = v;
    }

    // .google.cloud.vision.v1.Likelihood violence = 4;


    pub fn get_violence(&self) -> Likelihood {
        self.violence
    }
    pub fn clear_violence(&mut self) {
        self.violence = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_violence(&mut self, v: Likelihood) {
        self.violence = v;
    }

    // .google.cloud.vision.v1.Likelihood racy = 9;


    pub fn get_racy(&self) -> Likelihood {
        self.racy
    }
    pub fn clear_racy(&mut self) {
        self.racy = Likelihood::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_racy(&mut self, v: Likelihood) {
        self.racy = v;
    }

    // float adult_confidence = 16;


    pub fn get_adult_confidence(&self) -> f32 {
        self.adult_confidence
    }
    pub fn clear_adult_confidence(&mut self) {
        self.adult_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adult_confidence(&mut self, v: f32) {
        self.adult_confidence = v;
    }

    // float spoof_confidence = 18;


    pub fn get_spoof_confidence(&self) -> f32 {
        self.spoof_confidence
    }
    pub fn clear_spoof_confidence(&mut self) {
        self.spoof_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spoof_confidence(&mut self, v: f32) {
        self.spoof_confidence = v;
    }

    // float medical_confidence = 20;


    pub fn get_medical_confidence(&self) -> f32 {
        self.medical_confidence
    }
    pub fn clear_medical_confidence(&mut self) {
        self.medical_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_medical_confidence(&mut self, v: f32) {
        self.medical_confidence = v;
    }

    // float violence_confidence = 22;


    pub fn get_violence_confidence(&self) -> f32 {
        self.violence_confidence
    }
    pub fn clear_violence_confidence(&mut self) {
        self.violence_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_violence_confidence(&mut self, v: f32) {
        self.violence_confidence = v;
    }

    // float racy_confidence = 24;


    pub fn get_racy_confidence(&self) -> f32 {
        self.racy_confidence
    }
    pub fn clear_racy_confidence(&mut self) {
        self.racy_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_racy_confidence(&mut self, v: f32) {
        self.racy_confidence = v;
    }

    // float nsfw_confidence = 26;


    pub fn get_nsfw_confidence(&self) -> f32 {
        self.nsfw_confidence
    }
    pub fn clear_nsfw_confidence(&mut self) {
        self.nsfw_confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_nsfw_confidence(&mut self, v: f32) {
        self.nsfw_confidence = v;
    }
}

impl ::protobuf::Message for SafeSearchAnnotation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.adult, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.spoof, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.medical, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.violence, 4, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.racy, 9, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.adult_confidence = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spoof_confidence = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.medical_confidence = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.violence_confidence = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.racy_confidence = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.nsfw_confidence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.adult != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.adult);
        }
        if self.spoof != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.spoof);
        }
        if self.medical != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.medical);
        }
        if self.violence != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.violence);
        }
        if self.racy != Likelihood::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(9, self.racy);
        }
        if self.adult_confidence != 0. {
            my_size += 6;
        }
        if self.spoof_confidence != 0. {
            my_size += 6;
        }
        if self.medical_confidence != 0. {
            my_size += 6;
        }
        if self.violence_confidence != 0. {
            my_size += 6;
        }
        if self.racy_confidence != 0. {
            my_size += 6;
        }
        if self.nsfw_confidence != 0. {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.adult != Likelihood::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.adult))?;
        }
        if self.spoof != Likelihood::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.spoof))?;
        }
        if self.medical != Likelihood::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.medical))?;
        }
        if self.violence != Likelihood::UNKNOWN {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.violence))?;
        }
        if self.racy != Likelihood::UNKNOWN {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.racy))?;
        }
        if self.adult_confidence != 0. {
            os.write_float(16, self.adult_confidence)?;
        }
        if self.spoof_confidence != 0. {
            os.write_float(18, self.spoof_confidence)?;
        }
        if self.medical_confidence != 0. {
            os.write_float(20, self.medical_confidence)?;
        }
        if self.violence_confidence != 0. {
            os.write_float(22, self.violence_confidence)?;
        }
        if self.racy_confidence != 0. {
            os.write_float(24, self.racy_confidence)?;
        }
        if self.nsfw_confidence != 0. {
            os.write_float(26, self.nsfw_confidence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SafeSearchAnnotation {
        SafeSearchAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "adult",
                |m: &SafeSearchAnnotation| { &m.adult },
                |m: &mut SafeSearchAnnotation| { &mut m.adult },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "spoof",
                |m: &SafeSearchAnnotation| { &m.spoof },
                |m: &mut SafeSearchAnnotation| { &mut m.spoof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "medical",
                |m: &SafeSearchAnnotation| { &m.medical },
                |m: &mut SafeSearchAnnotation| { &mut m.medical },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "violence",
                |m: &SafeSearchAnnotation| { &m.violence },
                |m: &mut SafeSearchAnnotation| { &mut m.violence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Likelihood>>(
                "racy",
                |m: &SafeSearchAnnotation| { &m.racy },
                |m: &mut SafeSearchAnnotation| { &mut m.racy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "adult_confidence",
                |m: &SafeSearchAnnotation| { &m.adult_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.adult_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spoof_confidence",
                |m: &SafeSearchAnnotation| { &m.spoof_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.spoof_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "medical_confidence",
                |m: &SafeSearchAnnotation| { &m.medical_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.medical_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "violence_confidence",
                |m: &SafeSearchAnnotation| { &m.violence_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.violence_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "racy_confidence",
                |m: &SafeSearchAnnotation| { &m.racy_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.racy_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "nsfw_confidence",
                |m: &SafeSearchAnnotation| { &m.nsfw_confidence },
                |m: &mut SafeSearchAnnotation| { &mut m.nsfw_confidence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SafeSearchAnnotation>(
                "SafeSearchAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SafeSearchAnnotation {
        static instance: ::protobuf::rt::LazyV2<SafeSearchAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SafeSearchAnnotation::new)
    }
}

impl ::protobuf::Clear for SafeSearchAnnotation {
    fn clear(&mut self) {
        self.adult = Likelihood::UNKNOWN;
        self.spoof = Likelihood::UNKNOWN;
        self.medical = Likelihood::UNKNOWN;
        self.violence = Likelihood::UNKNOWN;
        self.racy = Likelihood::UNKNOWN;
        self.adult_confidence = 0.;
        self.spoof_confidence = 0.;
        self.medical_confidence = 0.;
        self.violence_confidence = 0.;
        self.racy_confidence = 0.;
        self.nsfw_confidence = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SafeSearchAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SafeSearchAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LatLongRect {
    // message fields
    pub min_lat_lng: ::protobuf::SingularPtrField<super::latlng::LatLng>,
    pub max_lat_lng: ::protobuf::SingularPtrField<super::latlng::LatLng>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LatLongRect {
    fn default() -> &'a LatLongRect {
        <LatLongRect as ::protobuf::Message>::default_instance()
    }
}

impl LatLongRect {
    pub fn new() -> LatLongRect {
        ::std::default::Default::default()
    }

    // .google.type.LatLng min_lat_lng = 1;


    pub fn get_min_lat_lng(&self) -> &super::latlng::LatLng {
        self.min_lat_lng.as_ref().unwrap_or_else(|| <super::latlng::LatLng as ::protobuf::Message>::default_instance())
    }
    pub fn clear_min_lat_lng(&mut self) {
        self.min_lat_lng.clear();
    }

    pub fn has_min_lat_lng(&self) -> bool {
        self.min_lat_lng.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_lat_lng(&mut self, v: super::latlng::LatLng) {
        self.min_lat_lng = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_lat_lng(&mut self) -> &mut super::latlng::LatLng {
        if self.min_lat_lng.is_none() {
            self.min_lat_lng.set_default();
        }
        self.min_lat_lng.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_lat_lng(&mut self) -> super::latlng::LatLng {
        self.min_lat_lng.take().unwrap_or_else(|| super::latlng::LatLng::new())
    }

    // .google.type.LatLng max_lat_lng = 2;


    pub fn get_max_lat_lng(&self) -> &super::latlng::LatLng {
        self.max_lat_lng.as_ref().unwrap_or_else(|| <super::latlng::LatLng as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_lat_lng(&mut self) {
        self.max_lat_lng.clear();
    }

    pub fn has_max_lat_lng(&self) -> bool {
        self.max_lat_lng.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_lat_lng(&mut self, v: super::latlng::LatLng) {
        self.max_lat_lng = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_lat_lng(&mut self) -> &mut super::latlng::LatLng {
        if self.max_lat_lng.is_none() {
            self.max_lat_lng.set_default();
        }
        self.max_lat_lng.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_lat_lng(&mut self) -> super::latlng::LatLng {
        self.max_lat_lng.take().unwrap_or_else(|| super::latlng::LatLng::new())
    }
}

impl ::protobuf::Message for LatLongRect {
    fn is_initialized(&self) -> bool {
        for v in &self.min_lat_lng {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_lat_lng {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_lat_lng)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_lat_lng)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.min_lat_lng.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_lat_lng.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.min_lat_lng.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_lat_lng.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LatLongRect {
        LatLongRect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::latlng::LatLng>>(
                "min_lat_lng",
                |m: &LatLongRect| { &m.min_lat_lng },
                |m: &mut LatLongRect| { &mut m.min_lat_lng },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::latlng::LatLng>>(
                "max_lat_lng",
                |m: &LatLongRect| { &m.max_lat_lng },
                |m: &mut LatLongRect| { &mut m.max_lat_lng },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LatLongRect>(
                "LatLongRect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LatLongRect {
        static instance: ::protobuf::rt::LazyV2<LatLongRect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LatLongRect::new)
    }
}

impl ::protobuf::Clear for LatLongRect {
    fn clear(&mut self) {
        self.min_lat_lng.clear();
        self.max_lat_lng.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LatLongRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LatLongRect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColorInfo {
    // message fields
    pub color: ::protobuf::SingularPtrField<super::color::Color>,
    pub score: f32,
    pub pixel_fraction: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorInfo {
    fn default() -> &'a ColorInfo {
        <ColorInfo as ::protobuf::Message>::default_instance()
    }
}

impl ColorInfo {
    pub fn new() -> ColorInfo {
        ::std::default::Default::default()
    }

    // .google.type.Color color = 1;


    pub fn get_color(&self) -> &super::color::Color {
        self.color.as_ref().unwrap_or_else(|| <super::color::Color as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: super::color::Color) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut super::color::Color {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> super::color::Color {
        self.color.take().unwrap_or_else(|| super::color::Color::new())
    }

    // float score = 2;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // float pixel_fraction = 3;


    pub fn get_pixel_fraction(&self) -> f32 {
        self.pixel_fraction
    }
    pub fn clear_pixel_fraction(&mut self) {
        self.pixel_fraction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pixel_fraction(&mut self, v: f32) {
        self.pixel_fraction = v;
    }
}

impl ::protobuf::Message for ColorInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pixel_fraction = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.score != 0. {
            my_size += 5;
        }
        if self.pixel_fraction != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.score != 0. {
            os.write_float(2, self.score)?;
        }
        if self.pixel_fraction != 0. {
            os.write_float(3, self.pixel_fraction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorInfo {
        ColorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::color::Color>>(
                "color",
                |m: &ColorInfo| { &m.color },
                |m: &mut ColorInfo| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &ColorInfo| { &m.score },
                |m: &mut ColorInfo| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pixel_fraction",
                |m: &ColorInfo| { &m.pixel_fraction },
                |m: &mut ColorInfo| { &mut m.pixel_fraction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColorInfo>(
                "ColorInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColorInfo {
        static instance: ::protobuf::rt::LazyV2<ColorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColorInfo::new)
    }
}

impl ::protobuf::Clear for ColorInfo {
    fn clear(&mut self) {
        self.color.clear();
        self.score = 0.;
        self.pixel_fraction = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DominantColorsAnnotation {
    // message fields
    pub colors: ::protobuf::RepeatedField<ColorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DominantColorsAnnotation {
    fn default() -> &'a DominantColorsAnnotation {
        <DominantColorsAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl DominantColorsAnnotation {
    pub fn new() -> DominantColorsAnnotation {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.ColorInfo colors = 1;


    pub fn get_colors(&self) -> &[ColorInfo] {
        &self.colors
    }
    pub fn clear_colors(&mut self) {
        self.colors.clear();
    }

    // Param is passed by value, moved
    pub fn set_colors(&mut self, v: ::protobuf::RepeatedField<ColorInfo>) {
        self.colors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colors(&mut self) -> &mut ::protobuf::RepeatedField<ColorInfo> {
        &mut self.colors
    }

    // Take field
    pub fn take_colors(&mut self) -> ::protobuf::RepeatedField<ColorInfo> {
        ::std::mem::replace(&mut self.colors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DominantColorsAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.colors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.colors {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DominantColorsAnnotation {
        DominantColorsAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColorInfo>>(
                "colors",
                |m: &DominantColorsAnnotation| { &m.colors },
                |m: &mut DominantColorsAnnotation| { &mut m.colors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DominantColorsAnnotation>(
                "DominantColorsAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DominantColorsAnnotation {
        static instance: ::protobuf::rt::LazyV2<DominantColorsAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DominantColorsAnnotation::new)
    }
}

impl ::protobuf::Clear for DominantColorsAnnotation {
    fn clear(&mut self) {
        self.colors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DominantColorsAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DominantColorsAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageProperties {
    // message fields
    pub dominant_colors: ::protobuf::SingularPtrField<DominantColorsAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageProperties {
    fn default() -> &'a ImageProperties {
        <ImageProperties as ::protobuf::Message>::default_instance()
    }
}

impl ImageProperties {
    pub fn new() -> ImageProperties {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.DominantColorsAnnotation dominant_colors = 1;


    pub fn get_dominant_colors(&self) -> &DominantColorsAnnotation {
        self.dominant_colors.as_ref().unwrap_or_else(|| <DominantColorsAnnotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dominant_colors(&mut self) {
        self.dominant_colors.clear();
    }

    pub fn has_dominant_colors(&self) -> bool {
        self.dominant_colors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dominant_colors(&mut self, v: DominantColorsAnnotation) {
        self.dominant_colors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dominant_colors(&mut self) -> &mut DominantColorsAnnotation {
        if self.dominant_colors.is_none() {
            self.dominant_colors.set_default();
        }
        self.dominant_colors.as_mut().unwrap()
    }

    // Take field
    pub fn take_dominant_colors(&mut self) -> DominantColorsAnnotation {
        self.dominant_colors.take().unwrap_or_else(|| DominantColorsAnnotation::new())
    }
}

impl ::protobuf::Message for ImageProperties {
    fn is_initialized(&self) -> bool {
        for v in &self.dominant_colors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dominant_colors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dominant_colors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dominant_colors.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageProperties {
        ImageProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DominantColorsAnnotation>>(
                "dominant_colors",
                |m: &ImageProperties| { &m.dominant_colors },
                |m: &mut ImageProperties| { &mut m.dominant_colors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageProperties>(
                "ImageProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageProperties {
        static instance: ::protobuf::rt::LazyV2<ImageProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageProperties::new)
    }
}

impl ::protobuf::Clear for ImageProperties {
    fn clear(&mut self) {
        self.dominant_colors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CropHint {
    // message fields
    pub bounding_poly: ::protobuf::SingularPtrField<super::geometry::BoundingPoly>,
    pub confidence: f32,
    pub importance_fraction: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CropHint {
    fn default() -> &'a CropHint {
        <CropHint as ::protobuf::Message>::default_instance()
    }
}

impl CropHint {
    pub fn new() -> CropHint {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.BoundingPoly bounding_poly = 1;


    pub fn get_bounding_poly(&self) -> &super::geometry::BoundingPoly {
        self.bounding_poly.as_ref().unwrap_or_else(|| <super::geometry::BoundingPoly as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bounding_poly(&mut self) {
        self.bounding_poly.clear();
    }

    pub fn has_bounding_poly(&self) -> bool {
        self.bounding_poly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_poly(&mut self, v: super::geometry::BoundingPoly) {
        self.bounding_poly = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_poly(&mut self) -> &mut super::geometry::BoundingPoly {
        if self.bounding_poly.is_none() {
            self.bounding_poly.set_default();
        }
        self.bounding_poly.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_poly(&mut self) -> super::geometry::BoundingPoly {
        self.bounding_poly.take().unwrap_or_else(|| super::geometry::BoundingPoly::new())
    }

    // float confidence = 2;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }

    // float importance_fraction = 3;


    pub fn get_importance_fraction(&self) -> f32 {
        self.importance_fraction
    }
    pub fn clear_importance_fraction(&mut self) {
        self.importance_fraction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_importance_fraction(&mut self, v: f32) {
        self.importance_fraction = v;
    }
}

impl ::protobuf::Message for CropHint {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_poly {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_poly)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.importance_fraction = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bounding_poly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        if self.importance_fraction != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bounding_poly.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confidence != 0. {
            os.write_float(2, self.confidence)?;
        }
        if self.importance_fraction != 0. {
            os.write_float(3, self.importance_fraction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CropHint {
        CropHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::geometry::BoundingPoly>>(
                "bounding_poly",
                |m: &CropHint| { &m.bounding_poly },
                |m: &mut CropHint| { &mut m.bounding_poly },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "confidence",
                |m: &CropHint| { &m.confidence },
                |m: &mut CropHint| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "importance_fraction",
                |m: &CropHint| { &m.importance_fraction },
                |m: &mut CropHint| { &mut m.importance_fraction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CropHint>(
                "CropHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CropHint {
        static instance: ::protobuf::rt::LazyV2<CropHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CropHint::new)
    }
}

impl ::protobuf::Clear for CropHint {
    fn clear(&mut self) {
        self.bounding_poly.clear();
        self.confidence = 0.;
        self.importance_fraction = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CropHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CropHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CropHintsAnnotation {
    // message fields
    pub crop_hints: ::protobuf::RepeatedField<CropHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CropHintsAnnotation {
    fn default() -> &'a CropHintsAnnotation {
        <CropHintsAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl CropHintsAnnotation {
    pub fn new() -> CropHintsAnnotation {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.CropHint crop_hints = 1;


    pub fn get_crop_hints(&self) -> &[CropHint] {
        &self.crop_hints
    }
    pub fn clear_crop_hints(&mut self) {
        self.crop_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_crop_hints(&mut self, v: ::protobuf::RepeatedField<CropHint>) {
        self.crop_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crop_hints(&mut self) -> &mut ::protobuf::RepeatedField<CropHint> {
        &mut self.crop_hints
    }

    // Take field
    pub fn take_crop_hints(&mut self) -> ::protobuf::RepeatedField<CropHint> {
        ::std::mem::replace(&mut self.crop_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CropHintsAnnotation {
    fn is_initialized(&self) -> bool {
        for v in &self.crop_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crop_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crop_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crop_hints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CropHintsAnnotation {
        CropHintsAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CropHint>>(
                "crop_hints",
                |m: &CropHintsAnnotation| { &m.crop_hints },
                |m: &mut CropHintsAnnotation| { &mut m.crop_hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CropHintsAnnotation>(
                "CropHintsAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CropHintsAnnotation {
        static instance: ::protobuf::rt::LazyV2<CropHintsAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CropHintsAnnotation::new)
    }
}

impl ::protobuf::Clear for CropHintsAnnotation {
    fn clear(&mut self) {
        self.crop_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CropHintsAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CropHintsAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CropHintsParams {
    // message fields
    pub aspect_ratios: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CropHintsParams {
    fn default() -> &'a CropHintsParams {
        <CropHintsParams as ::protobuf::Message>::default_instance()
    }
}

impl CropHintsParams {
    pub fn new() -> CropHintsParams {
        ::std::default::Default::default()
    }

    // repeated float aspect_ratios = 1;


    pub fn get_aspect_ratios(&self) -> &[f32] {
        &self.aspect_ratios
    }
    pub fn clear_aspect_ratios(&mut self) {
        self.aspect_ratios.clear();
    }

    // Param is passed by value, moved
    pub fn set_aspect_ratios(&mut self, v: ::std::vec::Vec<f32>) {
        self.aspect_ratios = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aspect_ratios(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.aspect_ratios
    }

    // Take field
    pub fn take_aspect_ratios(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.aspect_ratios, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CropHintsParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.aspect_ratios)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.aspect_ratios.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aspect_ratios {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CropHintsParams {
        CropHintsParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "aspect_ratios",
                |m: &CropHintsParams| { &m.aspect_ratios },
                |m: &mut CropHintsParams| { &mut m.aspect_ratios },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CropHintsParams>(
                "CropHintsParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CropHintsParams {
        static instance: ::protobuf::rt::LazyV2<CropHintsParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CropHintsParams::new)
    }
}

impl ::protobuf::Clear for CropHintsParams {
    fn clear(&mut self) {
        self.aspect_ratios.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CropHintsParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CropHintsParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WebDetectionParams {
    // message fields
    pub include_geo_results: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebDetectionParams {
    fn default() -> &'a WebDetectionParams {
        <WebDetectionParams as ::protobuf::Message>::default_instance()
    }
}

impl WebDetectionParams {
    pub fn new() -> WebDetectionParams {
        ::std::default::Default::default()
    }

    // bool include_geo_results = 2;


    pub fn get_include_geo_results(&self) -> bool {
        self.include_geo_results
    }
    pub fn clear_include_geo_results(&mut self) {
        self.include_geo_results = false;
    }

    // Param is passed by value, moved
    pub fn set_include_geo_results(&mut self, v: bool) {
        self.include_geo_results = v;
    }
}

impl ::protobuf::Message for WebDetectionParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_geo_results = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_geo_results != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_geo_results != false {
            os.write_bool(2, self.include_geo_results)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebDetectionParams {
        WebDetectionParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_geo_results",
                |m: &WebDetectionParams| { &m.include_geo_results },
                |m: &mut WebDetectionParams| { &mut m.include_geo_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebDetectionParams>(
                "WebDetectionParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebDetectionParams {
        static instance: ::protobuf::rt::LazyV2<WebDetectionParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebDetectionParams::new)
    }
}

impl ::protobuf::Clear for WebDetectionParams {
    fn clear(&mut self) {
        self.include_geo_results = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebDetectionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebDetectionParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageContext {
    // message fields
    pub lat_long_rect: ::protobuf::SingularPtrField<LatLongRect>,
    pub language_hints: ::protobuf::RepeatedField<::std::string::String>,
    pub crop_hints_params: ::protobuf::SingularPtrField<CropHintsParams>,
    pub product_search_params: ::protobuf::SingularPtrField<super::product_search::ProductSearchParams>,
    pub web_detection_params: ::protobuf::SingularPtrField<WebDetectionParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageContext {
    fn default() -> &'a ImageContext {
        <ImageContext as ::protobuf::Message>::default_instance()
    }
}

impl ImageContext {
    pub fn new() -> ImageContext {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.LatLongRect lat_long_rect = 1;


    pub fn get_lat_long_rect(&self) -> &LatLongRect {
        self.lat_long_rect.as_ref().unwrap_or_else(|| <LatLongRect as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lat_long_rect(&mut self) {
        self.lat_long_rect.clear();
    }

    pub fn has_lat_long_rect(&self) -> bool {
        self.lat_long_rect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_long_rect(&mut self, v: LatLongRect) {
        self.lat_long_rect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lat_long_rect(&mut self) -> &mut LatLongRect {
        if self.lat_long_rect.is_none() {
            self.lat_long_rect.set_default();
        }
        self.lat_long_rect.as_mut().unwrap()
    }

    // Take field
    pub fn take_lat_long_rect(&mut self) -> LatLongRect {
        self.lat_long_rect.take().unwrap_or_else(|| LatLongRect::new())
    }

    // repeated string language_hints = 2;


    pub fn get_language_hints(&self) -> &[::std::string::String] {
        &self.language_hints
    }
    pub fn clear_language_hints(&mut self) {
        self.language_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_hints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.language_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_hints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.language_hints
    }

    // Take field
    pub fn take_language_hints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.language_hints, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.CropHintsParams crop_hints_params = 4;


    pub fn get_crop_hints_params(&self) -> &CropHintsParams {
        self.crop_hints_params.as_ref().unwrap_or_else(|| <CropHintsParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crop_hints_params(&mut self) {
        self.crop_hints_params.clear();
    }

    pub fn has_crop_hints_params(&self) -> bool {
        self.crop_hints_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crop_hints_params(&mut self, v: CropHintsParams) {
        self.crop_hints_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crop_hints_params(&mut self) -> &mut CropHintsParams {
        if self.crop_hints_params.is_none() {
            self.crop_hints_params.set_default();
        }
        self.crop_hints_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_crop_hints_params(&mut self) -> CropHintsParams {
        self.crop_hints_params.take().unwrap_or_else(|| CropHintsParams::new())
    }

    // .google.cloud.vision.v1.ProductSearchParams product_search_params = 5;


    pub fn get_product_search_params(&self) -> &super::product_search::ProductSearchParams {
        self.product_search_params.as_ref().unwrap_or_else(|| <super::product_search::ProductSearchParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product_search_params(&mut self) {
        self.product_search_params.clear();
    }

    pub fn has_product_search_params(&self) -> bool {
        self.product_search_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_search_params(&mut self, v: super::product_search::ProductSearchParams) {
        self.product_search_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_search_params(&mut self) -> &mut super::product_search::ProductSearchParams {
        if self.product_search_params.is_none() {
            self.product_search_params.set_default();
        }
        self.product_search_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_search_params(&mut self) -> super::product_search::ProductSearchParams {
        self.product_search_params.take().unwrap_or_else(|| super::product_search::ProductSearchParams::new())
    }

    // .google.cloud.vision.v1.WebDetectionParams web_detection_params = 6;


    pub fn get_web_detection_params(&self) -> &WebDetectionParams {
        self.web_detection_params.as_ref().unwrap_or_else(|| <WebDetectionParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_web_detection_params(&mut self) {
        self.web_detection_params.clear();
    }

    pub fn has_web_detection_params(&self) -> bool {
        self.web_detection_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_web_detection_params(&mut self, v: WebDetectionParams) {
        self.web_detection_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_web_detection_params(&mut self) -> &mut WebDetectionParams {
        if self.web_detection_params.is_none() {
            self.web_detection_params.set_default();
        }
        self.web_detection_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_web_detection_params(&mut self) -> WebDetectionParams {
        self.web_detection_params.take().unwrap_or_else(|| WebDetectionParams::new())
    }
}

impl ::protobuf::Message for ImageContext {
    fn is_initialized(&self) -> bool {
        for v in &self.lat_long_rect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crop_hints_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.product_search_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.web_detection_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lat_long_rect)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.language_hints)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crop_hints_params)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product_search_params)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.web_detection_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lat_long_rect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.language_hints {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.crop_hints_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.product_search_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.web_detection_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lat_long_rect.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.language_hints {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.crop_hints_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.product_search_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.web_detection_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageContext {
        ImageContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LatLongRect>>(
                "lat_long_rect",
                |m: &ImageContext| { &m.lat_long_rect },
                |m: &mut ImageContext| { &mut m.lat_long_rect },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language_hints",
                |m: &ImageContext| { &m.language_hints },
                |m: &mut ImageContext| { &mut m.language_hints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CropHintsParams>>(
                "crop_hints_params",
                |m: &ImageContext| { &m.crop_hints_params },
                |m: &mut ImageContext| { &mut m.crop_hints_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::product_search::ProductSearchParams>>(
                "product_search_params",
                |m: &ImageContext| { &m.product_search_params },
                |m: &mut ImageContext| { &mut m.product_search_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebDetectionParams>>(
                "web_detection_params",
                |m: &ImageContext| { &m.web_detection_params },
                |m: &mut ImageContext| { &mut m.web_detection_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageContext>(
                "ImageContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageContext {
        static instance: ::protobuf::rt::LazyV2<ImageContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageContext::new)
    }
}

impl ::protobuf::Clear for ImageContext {
    fn clear(&mut self) {
        self.lat_long_rect.clear();
        self.language_hints.clear();
        self.crop_hints_params.clear();
        self.product_search_params.clear();
        self.web_detection_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateImageRequest {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    pub features: ::protobuf::RepeatedField<Feature>,
    pub image_context: ::protobuf::SingularPtrField<ImageContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateImageRequest {
    fn default() -> &'a AnnotateImageRequest {
        <AnnotateImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateImageRequest {
    pub fn new() -> AnnotateImageRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.Image image = 1;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    // repeated .google.cloud.vision.v1.Feature features = 2;


    pub fn get_features(&self) -> &[Feature] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<Feature> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.ImageContext image_context = 3;


    pub fn get_image_context(&self) -> &ImageContext {
        self.image_context.as_ref().unwrap_or_else(|| <ImageContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image_context(&mut self) {
        self.image_context.clear();
    }

    pub fn has_image_context(&self) -> bool {
        self.image_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_context(&mut self, v: ImageContext) {
        self.image_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_context(&mut self) -> &mut ImageContext {
        if self.image_context.is_none() {
            self.image_context.set_default();
        }
        self.image_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_context(&mut self) -> ImageContext {
        self.image_context.take().unwrap_or_else(|| ImageContext::new())
    }
}

impl ::protobuf::Message for AnnotateImageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.features)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.features {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateImageRequest {
        AnnotateImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &AnnotateImageRequest| { &m.image },
                |m: &mut AnnotateImageRequest| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &AnnotateImageRequest| { &m.features },
                |m: &mut AnnotateImageRequest| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageContext>>(
                "image_context",
                |m: &AnnotateImageRequest| { &m.image_context },
                |m: &mut AnnotateImageRequest| { &mut m.image_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnnotateImageRequest>(
                "AnnotateImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnnotateImageRequest {
        static instance: ::protobuf::rt::LazyV2<AnnotateImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnnotateImageRequest::new)
    }
}

impl ::protobuf::Clear for AnnotateImageRequest {
    fn clear(&mut self) {
        self.image.clear();
        self.features.clear();
        self.image_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageAnnotationContext {
    // message fields
    pub uri: ::std::string::String,
    pub page_number: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageAnnotationContext {
    fn default() -> &'a ImageAnnotationContext {
        <ImageAnnotationContext as ::protobuf::Message>::default_instance()
    }
}

impl ImageAnnotationContext {
    pub fn new() -> ImageAnnotationContext {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // int32 page_number = 2;


    pub fn get_page_number(&self) -> i32 {
        self.page_number
    }
    pub fn clear_page_number(&mut self) {
        self.page_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_number(&mut self, v: i32) {
        self.page_number = v;
    }
}

impl ::protobuf::Message for ImageAnnotationContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        if self.page_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        if self.page_number != 0 {
            os.write_int32(2, self.page_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageAnnotationContext {
        ImageAnnotationContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &ImageAnnotationContext| { &m.uri },
                |m: &mut ImageAnnotationContext| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_number",
                |m: &ImageAnnotationContext| { &m.page_number },
                |m: &mut ImageAnnotationContext| { &mut m.page_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageAnnotationContext>(
                "ImageAnnotationContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageAnnotationContext {
        static instance: ::protobuf::rt::LazyV2<ImageAnnotationContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageAnnotationContext::new)
    }
}

impl ::protobuf::Clear for ImageAnnotationContext {
    fn clear(&mut self) {
        self.uri.clear();
        self.page_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageAnnotationContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageAnnotationContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateImageResponse {
    // message fields
    pub face_annotations: ::protobuf::RepeatedField<FaceAnnotation>,
    pub landmark_annotations: ::protobuf::RepeatedField<EntityAnnotation>,
    pub logo_annotations: ::protobuf::RepeatedField<EntityAnnotation>,
    pub label_annotations: ::protobuf::RepeatedField<EntityAnnotation>,
    pub localized_object_annotations: ::protobuf::RepeatedField<LocalizedObjectAnnotation>,
    pub text_annotations: ::protobuf::RepeatedField<EntityAnnotation>,
    pub full_text_annotation: ::protobuf::SingularPtrField<super::text_annotation::TextAnnotation>,
    pub safe_search_annotation: ::protobuf::SingularPtrField<SafeSearchAnnotation>,
    pub image_properties_annotation: ::protobuf::SingularPtrField<ImageProperties>,
    pub crop_hints_annotation: ::protobuf::SingularPtrField<CropHintsAnnotation>,
    pub web_detection: ::protobuf::SingularPtrField<super::web_detection::WebDetection>,
    pub product_search_results: ::protobuf::SingularPtrField<super::product_search::ProductSearchResults>,
    pub error: ::protobuf::SingularPtrField<super::status::Status>,
    pub context: ::protobuf::SingularPtrField<ImageAnnotationContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateImageResponse {
    fn default() -> &'a AnnotateImageResponse {
        <AnnotateImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateImageResponse {
    pub fn new() -> AnnotateImageResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.FaceAnnotation face_annotations = 1;


    pub fn get_face_annotations(&self) -> &[FaceAnnotation] {
        &self.face_annotations
    }
    pub fn clear_face_annotations(&mut self) {
        self.face_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_face_annotations(&mut self, v: ::protobuf::RepeatedField<FaceAnnotation>) {
        self.face_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_face_annotations(&mut self) -> &mut ::protobuf::RepeatedField<FaceAnnotation> {
        &mut self.face_annotations
    }

    // Take field
    pub fn take_face_annotations(&mut self) -> ::protobuf::RepeatedField<FaceAnnotation> {
        ::std::mem::replace(&mut self.face_annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.EntityAnnotation landmark_annotations = 2;


    pub fn get_landmark_annotations(&self) -> &[EntityAnnotation] {
        &self.landmark_annotations
    }
    pub fn clear_landmark_annotations(&mut self) {
        self.landmark_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_landmark_annotations(&mut self, v: ::protobuf::RepeatedField<EntityAnnotation>) {
        self.landmark_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_landmark_annotations(&mut self) -> &mut ::protobuf::RepeatedField<EntityAnnotation> {
        &mut self.landmark_annotations
    }

    // Take field
    pub fn take_landmark_annotations(&mut self) -> ::protobuf::RepeatedField<EntityAnnotation> {
        ::std::mem::replace(&mut self.landmark_annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.EntityAnnotation logo_annotations = 3;


    pub fn get_logo_annotations(&self) -> &[EntityAnnotation] {
        &self.logo_annotations
    }
    pub fn clear_logo_annotations(&mut self) {
        self.logo_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo_annotations(&mut self, v: ::protobuf::RepeatedField<EntityAnnotation>) {
        self.logo_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logo_annotations(&mut self) -> &mut ::protobuf::RepeatedField<EntityAnnotation> {
        &mut self.logo_annotations
    }

    // Take field
    pub fn take_logo_annotations(&mut self) -> ::protobuf::RepeatedField<EntityAnnotation> {
        ::std::mem::replace(&mut self.logo_annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.EntityAnnotation label_annotations = 4;


    pub fn get_label_annotations(&self) -> &[EntityAnnotation] {
        &self.label_annotations
    }
    pub fn clear_label_annotations(&mut self) {
        self.label_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_annotations(&mut self, v: ::protobuf::RepeatedField<EntityAnnotation>) {
        self.label_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_annotations(&mut self) -> &mut ::protobuf::RepeatedField<EntityAnnotation> {
        &mut self.label_annotations
    }

    // Take field
    pub fn take_label_annotations(&mut self) -> ::protobuf::RepeatedField<EntityAnnotation> {
        ::std::mem::replace(&mut self.label_annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.LocalizedObjectAnnotation localized_object_annotations = 22;


    pub fn get_localized_object_annotations(&self) -> &[LocalizedObjectAnnotation] {
        &self.localized_object_annotations
    }
    pub fn clear_localized_object_annotations(&mut self) {
        self.localized_object_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_localized_object_annotations(&mut self, v: ::protobuf::RepeatedField<LocalizedObjectAnnotation>) {
        self.localized_object_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_localized_object_annotations(&mut self) -> &mut ::protobuf::RepeatedField<LocalizedObjectAnnotation> {
        &mut self.localized_object_annotations
    }

    // Take field
    pub fn take_localized_object_annotations(&mut self) -> ::protobuf::RepeatedField<LocalizedObjectAnnotation> {
        ::std::mem::replace(&mut self.localized_object_annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.vision.v1.EntityAnnotation text_annotations = 5;


    pub fn get_text_annotations(&self) -> &[EntityAnnotation] {
        &self.text_annotations
    }
    pub fn clear_text_annotations(&mut self) {
        self.text_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_text_annotations(&mut self, v: ::protobuf::RepeatedField<EntityAnnotation>) {
        self.text_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text_annotations(&mut self) -> &mut ::protobuf::RepeatedField<EntityAnnotation> {
        &mut self.text_annotations
    }

    // Take field
    pub fn take_text_annotations(&mut self) -> ::protobuf::RepeatedField<EntityAnnotation> {
        ::std::mem::replace(&mut self.text_annotations, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.TextAnnotation full_text_annotation = 12;


    pub fn get_full_text_annotation(&self) -> &super::text_annotation::TextAnnotation {
        self.full_text_annotation.as_ref().unwrap_or_else(|| <super::text_annotation::TextAnnotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_full_text_annotation(&mut self) {
        self.full_text_annotation.clear();
    }

    pub fn has_full_text_annotation(&self) -> bool {
        self.full_text_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_text_annotation(&mut self, v: super::text_annotation::TextAnnotation) {
        self.full_text_annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_text_annotation(&mut self) -> &mut super::text_annotation::TextAnnotation {
        if self.full_text_annotation.is_none() {
            self.full_text_annotation.set_default();
        }
        self.full_text_annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_text_annotation(&mut self) -> super::text_annotation::TextAnnotation {
        self.full_text_annotation.take().unwrap_or_else(|| super::text_annotation::TextAnnotation::new())
    }

    // .google.cloud.vision.v1.SafeSearchAnnotation safe_search_annotation = 6;


    pub fn get_safe_search_annotation(&self) -> &SafeSearchAnnotation {
        self.safe_search_annotation.as_ref().unwrap_or_else(|| <SafeSearchAnnotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_safe_search_annotation(&mut self) {
        self.safe_search_annotation.clear();
    }

    pub fn has_safe_search_annotation(&self) -> bool {
        self.safe_search_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_safe_search_annotation(&mut self, v: SafeSearchAnnotation) {
        self.safe_search_annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_safe_search_annotation(&mut self) -> &mut SafeSearchAnnotation {
        if self.safe_search_annotation.is_none() {
            self.safe_search_annotation.set_default();
        }
        self.safe_search_annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_safe_search_annotation(&mut self) -> SafeSearchAnnotation {
        self.safe_search_annotation.take().unwrap_or_else(|| SafeSearchAnnotation::new())
    }

    // .google.cloud.vision.v1.ImageProperties image_properties_annotation = 8;


    pub fn get_image_properties_annotation(&self) -> &ImageProperties {
        self.image_properties_annotation.as_ref().unwrap_or_else(|| <ImageProperties as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image_properties_annotation(&mut self) {
        self.image_properties_annotation.clear();
    }

    pub fn has_image_properties_annotation(&self) -> bool {
        self.image_properties_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_properties_annotation(&mut self, v: ImageProperties) {
        self.image_properties_annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_properties_annotation(&mut self) -> &mut ImageProperties {
        if self.image_properties_annotation.is_none() {
            self.image_properties_annotation.set_default();
        }
        self.image_properties_annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_properties_annotation(&mut self) -> ImageProperties {
        self.image_properties_annotation.take().unwrap_or_else(|| ImageProperties::new())
    }

    // .google.cloud.vision.v1.CropHintsAnnotation crop_hints_annotation = 11;


    pub fn get_crop_hints_annotation(&self) -> &CropHintsAnnotation {
        self.crop_hints_annotation.as_ref().unwrap_or_else(|| <CropHintsAnnotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crop_hints_annotation(&mut self) {
        self.crop_hints_annotation.clear();
    }

    pub fn has_crop_hints_annotation(&self) -> bool {
        self.crop_hints_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crop_hints_annotation(&mut self, v: CropHintsAnnotation) {
        self.crop_hints_annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crop_hints_annotation(&mut self) -> &mut CropHintsAnnotation {
        if self.crop_hints_annotation.is_none() {
            self.crop_hints_annotation.set_default();
        }
        self.crop_hints_annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_crop_hints_annotation(&mut self) -> CropHintsAnnotation {
        self.crop_hints_annotation.take().unwrap_or_else(|| CropHintsAnnotation::new())
    }

    // .google.cloud.vision.v1.WebDetection web_detection = 13;


    pub fn get_web_detection(&self) -> &super::web_detection::WebDetection {
        self.web_detection.as_ref().unwrap_or_else(|| <super::web_detection::WebDetection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_web_detection(&mut self) {
        self.web_detection.clear();
    }

    pub fn has_web_detection(&self) -> bool {
        self.web_detection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_web_detection(&mut self, v: super::web_detection::WebDetection) {
        self.web_detection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_web_detection(&mut self) -> &mut super::web_detection::WebDetection {
        if self.web_detection.is_none() {
            self.web_detection.set_default();
        }
        self.web_detection.as_mut().unwrap()
    }

    // Take field
    pub fn take_web_detection(&mut self) -> super::web_detection::WebDetection {
        self.web_detection.take().unwrap_or_else(|| super::web_detection::WebDetection::new())
    }

    // .google.cloud.vision.v1.ProductSearchResults product_search_results = 14;


    pub fn get_product_search_results(&self) -> &super::product_search::ProductSearchResults {
        self.product_search_results.as_ref().unwrap_or_else(|| <super::product_search::ProductSearchResults as ::protobuf::Message>::default_instance())
    }
    pub fn clear_product_search_results(&mut self) {
        self.product_search_results.clear();
    }

    pub fn has_product_search_results(&self) -> bool {
        self.product_search_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_search_results(&mut self, v: super::product_search::ProductSearchResults) {
        self.product_search_results = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_search_results(&mut self) -> &mut super::product_search::ProductSearchResults {
        if self.product_search_results.is_none() {
            self.product_search_results.set_default();
        }
        self.product_search_results.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_search_results(&mut self) -> super::product_search::ProductSearchResults {
        self.product_search_results.take().unwrap_or_else(|| super::product_search::ProductSearchResults::new())
    }

    // .google.rpc.Status error = 9;


    pub fn get_error(&self) -> &super::status::Status {
        self.error.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        self.error.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.cloud.vision.v1.ImageAnnotationContext context = 21;


    pub fn get_context(&self) -> &ImageAnnotationContext {
        self.context.as_ref().unwrap_or_else(|| <ImageAnnotationContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ImageAnnotationContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ImageAnnotationContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> ImageAnnotationContext {
        self.context.take().unwrap_or_else(|| ImageAnnotationContext::new())
    }
}

impl ::protobuf::Message for AnnotateImageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.face_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.landmark_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logo_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.localized_object_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.full_text_annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.safe_search_annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_properties_annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crop_hints_annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.web_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.product_search_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.face_annotations)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.landmark_annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logo_annotations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_annotations)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.localized_object_annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.text_annotations)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.full_text_annotation)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.safe_search_annotation)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image_properties_annotation)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crop_hints_annotation)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.web_detection)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.product_search_results)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.face_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.landmark_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.logo_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.localized_object_annotations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.text_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.full_text_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.safe_search_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.image_properties_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.crop_hints_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.web_detection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.product_search_results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.face_annotations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.landmark_annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.logo_annotations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.localized_object_annotations {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.text_annotations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.full_text_annotation.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.safe_search_annotation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.image_properties_annotation.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.crop_hints_annotation.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.web_detection.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.product_search_results.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateImageResponse {
        AnnotateImageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FaceAnnotation>>(
                "face_annotations",
                |m: &AnnotateImageResponse| { &m.face_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.face_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntityAnnotation>>(
                "landmark_annotations",
                |m: &AnnotateImageResponse| { &m.landmark_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.landmark_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntityAnnotation>>(
                "logo_annotations",
                |m: &AnnotateImageResponse| { &m.logo_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.logo_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntityAnnotation>>(
                "label_annotations",
                |m: &AnnotateImageResponse| { &m.label_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.label_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalizedObjectAnnotation>>(
                "localized_object_annotations",
                |m: &AnnotateImageResponse| { &m.localized_object_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.localized_object_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntityAnnotation>>(
                "text_annotations",
                |m: &AnnotateImageResponse| { &m.text_annotations },
                |m: &mut AnnotateImageResponse| { &mut m.text_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::text_annotation::TextAnnotation>>(
                "full_text_annotation",
                |m: &AnnotateImageResponse| { &m.full_text_annotation },
                |m: &mut AnnotateImageResponse| { &mut m.full_text_annotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SafeSearchAnnotation>>(
                "safe_search_annotation",
                |m: &AnnotateImageResponse| { &m.safe_search_annotation },
                |m: &mut AnnotateImageResponse| { &mut m.safe_search_annotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageProperties>>(
                "image_properties_annotation",
                |m: &AnnotateImageResponse| { &m.image_properties_annotation },
                |m: &mut AnnotateImageResponse| { &mut m.image_properties_annotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CropHintsAnnotation>>(
                "crop_hints_annotation",
                |m: &AnnotateImageResponse| { &m.crop_hints_annotation },
                |m: &mut AnnotateImageResponse| { &mut m.crop_hints_annotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::web_detection::WebDetection>>(
                "web_detection",
                |m: &AnnotateImageResponse| { &m.web_detection },
                |m: &mut AnnotateImageResponse| { &mut m.web_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::product_search::ProductSearchResults>>(
                "product_search_results",
                |m: &AnnotateImageResponse| { &m.product_search_results },
                |m: &mut AnnotateImageResponse| { &mut m.product_search_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "error",
                |m: &AnnotateImageResponse| { &m.error },
                |m: &mut AnnotateImageResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageAnnotationContext>>(
                "context",
                |m: &AnnotateImageResponse| { &m.context },
                |m: &mut AnnotateImageResponse| { &mut m.context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnnotateImageResponse>(
                "AnnotateImageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnnotateImageResponse {
        static instance: ::protobuf::rt::LazyV2<AnnotateImageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnnotateImageResponse::new)
    }
}

impl ::protobuf::Clear for AnnotateImageResponse {
    fn clear(&mut self) {
        self.face_annotations.clear();
        self.landmark_annotations.clear();
        self.logo_annotations.clear();
        self.label_annotations.clear();
        self.localized_object_annotations.clear();
        self.text_annotations.clear();
        self.full_text_annotation.clear();
        self.safe_search_annotation.clear();
        self.image_properties_annotation.clear();
        self.crop_hints_annotation.clear();
        self.web_detection.clear();
        self.product_search_results.clear();
        self.error.clear();
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateImageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchAnnotateImagesRequest {
    // message fields
    pub requests: ::protobuf::RepeatedField<AnnotateImageRequest>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchAnnotateImagesRequest {
    fn default() -> &'a BatchAnnotateImagesRequest {
        <BatchAnnotateImagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchAnnotateImagesRequest {
    pub fn new() -> BatchAnnotateImagesRequest {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AnnotateImageRequest requests = 1;


    pub fn get_requests(&self) -> &[AnnotateImageRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<AnnotateImageRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateImageRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<AnnotateImageRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // string parent = 4;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BatchAnnotateImagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.parent.is_empty() {
            os.write_string(4, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchAnnotateImagesRequest {
        BatchAnnotateImagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateImageRequest>>(
                "requests",
                |m: &BatchAnnotateImagesRequest| { &m.requests },
                |m: &mut BatchAnnotateImagesRequest| { &mut m.requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &BatchAnnotateImagesRequest| { &m.parent },
                |m: &mut BatchAnnotateImagesRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchAnnotateImagesRequest>(
                "BatchAnnotateImagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchAnnotateImagesRequest {
        static instance: ::protobuf::rt::LazyV2<BatchAnnotateImagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchAnnotateImagesRequest::new)
    }
}

impl ::protobuf::Clear for BatchAnnotateImagesRequest {
    fn clear(&mut self) {
        self.requests.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchAnnotateImagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchAnnotateImagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchAnnotateImagesResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<AnnotateImageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchAnnotateImagesResponse {
    fn default() -> &'a BatchAnnotateImagesResponse {
        <BatchAnnotateImagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchAnnotateImagesResponse {
    pub fn new() -> BatchAnnotateImagesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AnnotateImageResponse responses = 1;


    pub fn get_responses(&self) -> &[AnnotateImageResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<AnnotateImageResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateImageResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<AnnotateImageResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchAnnotateImagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchAnnotateImagesResponse {
        BatchAnnotateImagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateImageResponse>>(
                "responses",
                |m: &BatchAnnotateImagesResponse| { &m.responses },
                |m: &mut BatchAnnotateImagesResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchAnnotateImagesResponse>(
                "BatchAnnotateImagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchAnnotateImagesResponse {
        static instance: ::protobuf::rt::LazyV2<BatchAnnotateImagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchAnnotateImagesResponse::new)
    }
}

impl ::protobuf::Clear for BatchAnnotateImagesResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchAnnotateImagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchAnnotateImagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateFileRequest {
    // message fields
    pub input_config: ::protobuf::SingularPtrField<InputConfig>,
    pub features: ::protobuf::RepeatedField<Feature>,
    pub image_context: ::protobuf::SingularPtrField<ImageContext>,
    pub pages: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateFileRequest {
    fn default() -> &'a AnnotateFileRequest {
        <AnnotateFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateFileRequest {
    pub fn new() -> AnnotateFileRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.InputConfig input_config = 1;


    pub fn get_input_config(&self) -> &InputConfig {
        self.input_config.as_ref().unwrap_or_else(|| <InputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_config(&mut self) {
        self.input_config.clear();
    }

    pub fn has_input_config(&self) -> bool {
        self.input_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_config(&mut self, v: InputConfig) {
        self.input_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_config(&mut self) -> &mut InputConfig {
        if self.input_config.is_none() {
            self.input_config.set_default();
        }
        self.input_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_config(&mut self) -> InputConfig {
        self.input_config.take().unwrap_or_else(|| InputConfig::new())
    }

    // repeated .google.cloud.vision.v1.Feature features = 2;


    pub fn get_features(&self) -> &[Feature] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<Feature> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.ImageContext image_context = 3;


    pub fn get_image_context(&self) -> &ImageContext {
        self.image_context.as_ref().unwrap_or_else(|| <ImageContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image_context(&mut self) {
        self.image_context.clear();
    }

    pub fn has_image_context(&self) -> bool {
        self.image_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_context(&mut self, v: ImageContext) {
        self.image_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_context(&mut self) -> &mut ImageContext {
        if self.image_context.is_none() {
            self.image_context.set_default();
        }
        self.image_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_context(&mut self) -> ImageContext {
        self.image_context.take().unwrap_or_else(|| ImageContext::new())
    }

    // repeated int32 pages = 4;


    pub fn get_pages(&self) -> &[i32] {
        &self.pages
    }
    pub fn clear_pages(&mut self) {
        self.pages.clear();
    }

    // Param is passed by value, moved
    pub fn set_pages(&mut self, v: ::std::vec::Vec<i32>) {
        self.pages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pages(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pages
    }

    // Take field
    pub fn take_pages(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.pages, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AnnotateFileRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.input_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_config)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.features)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image_context)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.pages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pages {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.features {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pages {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateFileRequest {
        AnnotateFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputConfig>>(
                "input_config",
                |m: &AnnotateFileRequest| { &m.input_config },
                |m: &mut AnnotateFileRequest| { &mut m.input_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &AnnotateFileRequest| { &m.features },
                |m: &mut AnnotateFileRequest| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageContext>>(
                "image_context",
                |m: &AnnotateFileRequest| { &m.image_context },
                |m: &mut AnnotateFileRequest| { &mut m.image_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pages",
                |m: &AnnotateFileRequest| { &m.pages },
                |m: &mut AnnotateFileRequest| { &mut m.pages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnnotateFileRequest>(
                "AnnotateFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnnotateFileRequest {
        static instance: ::protobuf::rt::LazyV2<AnnotateFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnnotateFileRequest::new)
    }
}

impl ::protobuf::Clear for AnnotateFileRequest {
    fn clear(&mut self) {
        self.input_config.clear();
        self.features.clear();
        self.image_context.clear();
        self.pages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateFileResponse {
    // message fields
    pub input_config: ::protobuf::SingularPtrField<InputConfig>,
    pub responses: ::protobuf::RepeatedField<AnnotateImageResponse>,
    pub total_pages: i32,
    pub error: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateFileResponse {
    fn default() -> &'a AnnotateFileResponse {
        <AnnotateFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateFileResponse {
    pub fn new() -> AnnotateFileResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.InputConfig input_config = 1;


    pub fn get_input_config(&self) -> &InputConfig {
        self.input_config.as_ref().unwrap_or_else(|| <InputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_config(&mut self) {
        self.input_config.clear();
    }

    pub fn has_input_config(&self) -> bool {
        self.input_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_config(&mut self, v: InputConfig) {
        self.input_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_config(&mut self) -> &mut InputConfig {
        if self.input_config.is_none() {
            self.input_config.set_default();
        }
        self.input_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_config(&mut self) -> InputConfig {
        self.input_config.take().unwrap_or_else(|| InputConfig::new())
    }

    // repeated .google.cloud.vision.v1.AnnotateImageResponse responses = 2;


    pub fn get_responses(&self) -> &[AnnotateImageResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<AnnotateImageResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateImageResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<AnnotateImageResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }

    // int32 total_pages = 3;


    pub fn get_total_pages(&self) -> i32 {
        self.total_pages
    }
    pub fn clear_total_pages(&mut self) {
        self.total_pages = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pages(&mut self, v: i32) {
        self.total_pages = v;
    }

    // .google.rpc.Status error = 4;


    pub fn get_error(&self) -> &super::status::Status {
        self.error.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        self.error.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for AnnotateFileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.input_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_config)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_pages = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_pages != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_pages, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.responses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_pages != 0 {
            os.write_int32(3, self.total_pages)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateFileResponse {
        AnnotateFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputConfig>>(
                "input_config",
                |m: &AnnotateFileResponse| { &m.input_config },
                |m: &mut AnnotateFileResponse| { &mut m.input_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateImageResponse>>(
                "responses",
                |m: &AnnotateFileResponse| { &m.responses },
                |m: &mut AnnotateFileResponse| { &mut m.responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_pages",
                |m: &AnnotateFileResponse| { &m.total_pages },
                |m: &mut AnnotateFileResponse| { &mut m.total_pages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "error",
                |m: &AnnotateFileResponse| { &m.error },
                |m: &mut AnnotateFileResponse| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnnotateFileResponse>(
                "AnnotateFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnnotateFileResponse {
        static instance: ::protobuf::rt::LazyV2<AnnotateFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnnotateFileResponse::new)
    }
}

impl ::protobuf::Clear for AnnotateFileResponse {
    fn clear(&mut self) {
        self.input_config.clear();
        self.responses.clear();
        self.total_pages = 0;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchAnnotateFilesRequest {
    // message fields
    pub requests: ::protobuf::RepeatedField<AnnotateFileRequest>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchAnnotateFilesRequest {
    fn default() -> &'a BatchAnnotateFilesRequest {
        <BatchAnnotateFilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchAnnotateFilesRequest {
    pub fn new() -> BatchAnnotateFilesRequest {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AnnotateFileRequest requests = 1;


    pub fn get_requests(&self) -> &[AnnotateFileRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<AnnotateFileRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateFileRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<AnnotateFileRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // string parent = 3;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BatchAnnotateFilesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.parent.is_empty() {
            os.write_string(3, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchAnnotateFilesRequest {
        BatchAnnotateFilesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateFileRequest>>(
                "requests",
                |m: &BatchAnnotateFilesRequest| { &m.requests },
                |m: &mut BatchAnnotateFilesRequest| { &mut m.requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &BatchAnnotateFilesRequest| { &m.parent },
                |m: &mut BatchAnnotateFilesRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchAnnotateFilesRequest>(
                "BatchAnnotateFilesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchAnnotateFilesRequest {
        static instance: ::protobuf::rt::LazyV2<BatchAnnotateFilesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchAnnotateFilesRequest::new)
    }
}

impl ::protobuf::Clear for BatchAnnotateFilesRequest {
    fn clear(&mut self) {
        self.requests.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchAnnotateFilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchAnnotateFilesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchAnnotateFilesResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<AnnotateFileResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchAnnotateFilesResponse {
    fn default() -> &'a BatchAnnotateFilesResponse {
        <BatchAnnotateFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchAnnotateFilesResponse {
    pub fn new() -> BatchAnnotateFilesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AnnotateFileResponse responses = 1;


    pub fn get_responses(&self) -> &[AnnotateFileResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<AnnotateFileResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateFileResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<AnnotateFileResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchAnnotateFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchAnnotateFilesResponse {
        BatchAnnotateFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateFileResponse>>(
                "responses",
                |m: &BatchAnnotateFilesResponse| { &m.responses },
                |m: &mut BatchAnnotateFilesResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchAnnotateFilesResponse>(
                "BatchAnnotateFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchAnnotateFilesResponse {
        static instance: ::protobuf::rt::LazyV2<BatchAnnotateFilesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchAnnotateFilesResponse::new)
    }
}

impl ::protobuf::Clear for BatchAnnotateFilesResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchAnnotateFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchAnnotateFilesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncAnnotateFileRequest {
    // message fields
    pub input_config: ::protobuf::SingularPtrField<InputConfig>,
    pub features: ::protobuf::RepeatedField<Feature>,
    pub image_context: ::protobuf::SingularPtrField<ImageContext>,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncAnnotateFileRequest {
    fn default() -> &'a AsyncAnnotateFileRequest {
        <AsyncAnnotateFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl AsyncAnnotateFileRequest {
    pub fn new() -> AsyncAnnotateFileRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.InputConfig input_config = 1;


    pub fn get_input_config(&self) -> &InputConfig {
        self.input_config.as_ref().unwrap_or_else(|| <InputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_config(&mut self) {
        self.input_config.clear();
    }

    pub fn has_input_config(&self) -> bool {
        self.input_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_config(&mut self, v: InputConfig) {
        self.input_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_config(&mut self) -> &mut InputConfig {
        if self.input_config.is_none() {
            self.input_config.set_default();
        }
        self.input_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_config(&mut self) -> InputConfig {
        self.input_config.take().unwrap_or_else(|| InputConfig::new())
    }

    // repeated .google.cloud.vision.v1.Feature features = 2;


    pub fn get_features(&self) -> &[Feature] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<Feature>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<Feature> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<Feature> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.ImageContext image_context = 3;


    pub fn get_image_context(&self) -> &ImageContext {
        self.image_context.as_ref().unwrap_or_else(|| <ImageContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image_context(&mut self) {
        self.image_context.clear();
    }

    pub fn has_image_context(&self) -> bool {
        self.image_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_context(&mut self, v: ImageContext) {
        self.image_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_context(&mut self) -> &mut ImageContext {
        if self.image_context.is_none() {
            self.image_context.set_default();
        }
        self.image_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_context(&mut self) -> ImageContext {
        self.image_context.take().unwrap_or_else(|| ImageContext::new())
    }

    // .google.cloud.vision.v1.OutputConfig output_config = 4;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }
}

impl ::protobuf::Message for AsyncAnnotateFileRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.input_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_config)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.features)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image_context)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.features {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.image_context.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncAnnotateFileRequest {
        AsyncAnnotateFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputConfig>>(
                "input_config",
                |m: &AsyncAnnotateFileRequest| { &m.input_config },
                |m: &mut AsyncAnnotateFileRequest| { &mut m.input_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "features",
                |m: &AsyncAnnotateFileRequest| { &m.features },
                |m: &mut AsyncAnnotateFileRequest| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageContext>>(
                "image_context",
                |m: &AsyncAnnotateFileRequest| { &m.image_context },
                |m: &mut AsyncAnnotateFileRequest| { &mut m.image_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &AsyncAnnotateFileRequest| { &m.output_config },
                |m: &mut AsyncAnnotateFileRequest| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncAnnotateFileRequest>(
                "AsyncAnnotateFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncAnnotateFileRequest {
        static instance: ::protobuf::rt::LazyV2<AsyncAnnotateFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncAnnotateFileRequest::new)
    }
}

impl ::protobuf::Clear for AsyncAnnotateFileRequest {
    fn clear(&mut self) {
        self.input_config.clear();
        self.features.clear();
        self.image_context.clear();
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncAnnotateFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncAnnotateFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncAnnotateFileResponse {
    // message fields
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncAnnotateFileResponse {
    fn default() -> &'a AsyncAnnotateFileResponse {
        <AsyncAnnotateFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl AsyncAnnotateFileResponse {
    pub fn new() -> AsyncAnnotateFileResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.OutputConfig output_config = 1;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }
}

impl ::protobuf::Message for AsyncAnnotateFileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncAnnotateFileResponse {
        AsyncAnnotateFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &AsyncAnnotateFileResponse| { &m.output_config },
                |m: &mut AsyncAnnotateFileResponse| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncAnnotateFileResponse>(
                "AsyncAnnotateFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncAnnotateFileResponse {
        static instance: ::protobuf::rt::LazyV2<AsyncAnnotateFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncAnnotateFileResponse::new)
    }
}

impl ::protobuf::Clear for AsyncAnnotateFileResponse {
    fn clear(&mut self) {
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncAnnotateFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncAnnotateFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncBatchAnnotateImagesRequest {
    // message fields
    pub requests: ::protobuf::RepeatedField<AnnotateImageRequest>,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncBatchAnnotateImagesRequest {
    fn default() -> &'a AsyncBatchAnnotateImagesRequest {
        <AsyncBatchAnnotateImagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AsyncBatchAnnotateImagesRequest {
    pub fn new() -> AsyncBatchAnnotateImagesRequest {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AnnotateImageRequest requests = 1;


    pub fn get_requests(&self) -> &[AnnotateImageRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<AnnotateImageRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<AnnotateImageRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<AnnotateImageRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.vision.v1.OutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }

    // string parent = 4;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AsyncBatchAnnotateImagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent.is_empty() {
            os.write_string(4, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncBatchAnnotateImagesRequest {
        AsyncBatchAnnotateImagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateImageRequest>>(
                "requests",
                |m: &AsyncBatchAnnotateImagesRequest| { &m.requests },
                |m: &mut AsyncBatchAnnotateImagesRequest| { &mut m.requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &AsyncBatchAnnotateImagesRequest| { &m.output_config },
                |m: &mut AsyncBatchAnnotateImagesRequest| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &AsyncBatchAnnotateImagesRequest| { &m.parent },
                |m: &mut AsyncBatchAnnotateImagesRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncBatchAnnotateImagesRequest>(
                "AsyncBatchAnnotateImagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncBatchAnnotateImagesRequest {
        static instance: ::protobuf::rt::LazyV2<AsyncBatchAnnotateImagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncBatchAnnotateImagesRequest::new)
    }
}

impl ::protobuf::Clear for AsyncBatchAnnotateImagesRequest {
    fn clear(&mut self) {
        self.requests.clear();
        self.output_config.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncBatchAnnotateImagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncBatchAnnotateImagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncBatchAnnotateImagesResponse {
    // message fields
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncBatchAnnotateImagesResponse {
    fn default() -> &'a AsyncBatchAnnotateImagesResponse {
        <AsyncBatchAnnotateImagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AsyncBatchAnnotateImagesResponse {
    pub fn new() -> AsyncBatchAnnotateImagesResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.OutputConfig output_config = 1;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }
}

impl ::protobuf::Message for AsyncBatchAnnotateImagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncBatchAnnotateImagesResponse {
        AsyncBatchAnnotateImagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &AsyncBatchAnnotateImagesResponse| { &m.output_config },
                |m: &mut AsyncBatchAnnotateImagesResponse| { &mut m.output_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncBatchAnnotateImagesResponse>(
                "AsyncBatchAnnotateImagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncBatchAnnotateImagesResponse {
        static instance: ::protobuf::rt::LazyV2<AsyncBatchAnnotateImagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncBatchAnnotateImagesResponse::new)
    }
}

impl ::protobuf::Clear for AsyncBatchAnnotateImagesResponse {
    fn clear(&mut self) {
        self.output_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncBatchAnnotateImagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncBatchAnnotateImagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncBatchAnnotateFilesRequest {
    // message fields
    pub requests: ::protobuf::RepeatedField<AsyncAnnotateFileRequest>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncBatchAnnotateFilesRequest {
    fn default() -> &'a AsyncBatchAnnotateFilesRequest {
        <AsyncBatchAnnotateFilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AsyncBatchAnnotateFilesRequest {
    pub fn new() -> AsyncBatchAnnotateFilesRequest {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AsyncAnnotateFileRequest requests = 1;


    pub fn get_requests(&self) -> &[AsyncAnnotateFileRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<AsyncAnnotateFileRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<AsyncAnnotateFileRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<AsyncAnnotateFileRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // string parent = 4;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AsyncBatchAnnotateFilesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.parent.is_empty() {
            os.write_string(4, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncBatchAnnotateFilesRequest {
        AsyncBatchAnnotateFilesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsyncAnnotateFileRequest>>(
                "requests",
                |m: &AsyncBatchAnnotateFilesRequest| { &m.requests },
                |m: &mut AsyncBatchAnnotateFilesRequest| { &mut m.requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &AsyncBatchAnnotateFilesRequest| { &m.parent },
                |m: &mut AsyncBatchAnnotateFilesRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncBatchAnnotateFilesRequest>(
                "AsyncBatchAnnotateFilesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncBatchAnnotateFilesRequest {
        static instance: ::protobuf::rt::LazyV2<AsyncBatchAnnotateFilesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncBatchAnnotateFilesRequest::new)
    }
}

impl ::protobuf::Clear for AsyncBatchAnnotateFilesRequest {
    fn clear(&mut self) {
        self.requests.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncBatchAnnotateFilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncBatchAnnotateFilesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsyncBatchAnnotateFilesResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<AsyncAnnotateFileResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncBatchAnnotateFilesResponse {
    fn default() -> &'a AsyncBatchAnnotateFilesResponse {
        <AsyncBatchAnnotateFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AsyncBatchAnnotateFilesResponse {
    pub fn new() -> AsyncBatchAnnotateFilesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.vision.v1.AsyncAnnotateFileResponse responses = 1;


    pub fn get_responses(&self) -> &[AsyncAnnotateFileResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<AsyncAnnotateFileResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<AsyncAnnotateFileResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<AsyncAnnotateFileResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AsyncBatchAnnotateFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncBatchAnnotateFilesResponse {
        AsyncBatchAnnotateFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsyncAnnotateFileResponse>>(
                "responses",
                |m: &AsyncBatchAnnotateFilesResponse| { &m.responses },
                |m: &mut AsyncBatchAnnotateFilesResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncBatchAnnotateFilesResponse>(
                "AsyncBatchAnnotateFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncBatchAnnotateFilesResponse {
        static instance: ::protobuf::rt::LazyV2<AsyncBatchAnnotateFilesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncBatchAnnotateFilesResponse::new)
    }
}

impl ::protobuf::Clear for AsyncBatchAnnotateFilesResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncBatchAnnotateFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncBatchAnnotateFilesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InputConfig {
    // message fields
    pub gcs_source: ::protobuf::SingularPtrField<GcsSource>,
    pub content: ::std::vec::Vec<u8>,
    pub mime_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputConfig {
    fn default() -> &'a InputConfig {
        <InputConfig as ::protobuf::Message>::default_instance()
    }
}

impl InputConfig {
    pub fn new() -> InputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.GcsSource gcs_source = 1;


    pub fn get_gcs_source(&self) -> &GcsSource {
        self.gcs_source.as_ref().unwrap_or_else(|| <GcsSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcs_source(&mut self) {
        self.gcs_source.clear();
    }

    pub fn has_gcs_source(&self) -> bool {
        self.gcs_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcs_source(&mut self, v: GcsSource) {
        self.gcs_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcs_source(&mut self) -> &mut GcsSource {
        if self.gcs_source.is_none() {
            self.gcs_source.set_default();
        }
        self.gcs_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcs_source(&mut self) -> GcsSource {
        self.gcs_source.take().unwrap_or_else(|| GcsSource::new())
    }

    // bytes content = 3;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }

    // string mime_type = 2;


    pub fn get_mime_type(&self) -> &str {
        &self.mime_type
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        &mut self.mime_type
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mime_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InputConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.gcs_source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcs_source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mime_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gcs_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.content);
        }
        if !self.mime_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mime_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gcs_source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(3, &self.content)?;
        }
        if !self.mime_type.is_empty() {
            os.write_string(2, &self.mime_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputConfig {
        InputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GcsSource>>(
                "gcs_source",
                |m: &InputConfig| { &m.gcs_source },
                |m: &mut InputConfig| { &mut m.gcs_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &InputConfig| { &m.content },
                |m: &mut InputConfig| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mime_type",
                |m: &InputConfig| { &m.mime_type },
                |m: &mut InputConfig| { &mut m.mime_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputConfig>(
                "InputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputConfig {
        static instance: ::protobuf::rt::LazyV2<InputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputConfig::new)
    }
}

impl ::protobuf::Clear for InputConfig {
    fn clear(&mut self) {
        self.gcs_source.clear();
        self.content.clear();
        self.mime_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputConfig {
    // message fields
    pub gcs_destination: ::protobuf::SingularPtrField<GcsDestination>,
    pub batch_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputConfig {
    fn default() -> &'a OutputConfig {
        <OutputConfig as ::protobuf::Message>::default_instance()
    }
}

impl OutputConfig {
    pub fn new() -> OutputConfig {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.GcsDestination gcs_destination = 1;


    pub fn get_gcs_destination(&self) -> &GcsDestination {
        self.gcs_destination.as_ref().unwrap_or_else(|| <GcsDestination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcs_destination(&mut self) {
        self.gcs_destination.clear();
    }

    pub fn has_gcs_destination(&self) -> bool {
        self.gcs_destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcs_destination(&mut self, v: GcsDestination) {
        self.gcs_destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcs_destination(&mut self) -> &mut GcsDestination {
        if self.gcs_destination.is_none() {
            self.gcs_destination.set_default();
        }
        self.gcs_destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcs_destination(&mut self) -> GcsDestination {
        self.gcs_destination.take().unwrap_or_else(|| GcsDestination::new())
    }

    // int32 batch_size = 2;


    pub fn get_batch_size(&self) -> i32 {
        self.batch_size
    }
    pub fn clear_batch_size(&mut self) {
        self.batch_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_size(&mut self, v: i32) {
        self.batch_size = v;
    }
}

impl ::protobuf::Message for OutputConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.gcs_destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcs_destination)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.batch_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gcs_destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.batch_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gcs_destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.batch_size != 0 {
            os.write_int32(2, self.batch_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputConfig {
        OutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GcsDestination>>(
                "gcs_destination",
                |m: &OutputConfig| { &m.gcs_destination },
                |m: &mut OutputConfig| { &mut m.gcs_destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "batch_size",
                |m: &OutputConfig| { &m.batch_size },
                |m: &mut OutputConfig| { &mut m.batch_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputConfig>(
                "OutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputConfig {
        static instance: ::protobuf::rt::LazyV2<OutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputConfig::new)
    }
}

impl ::protobuf::Clear for OutputConfig {
    fn clear(&mut self) {
        self.gcs_destination.clear();
        self.batch_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsSource {
    // message fields
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsSource {
    fn default() -> &'a GcsSource {
        <GcsSource as ::protobuf::Message>::default_instance()
    }
}

impl GcsSource {
    pub fn new() -> GcsSource {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GcsSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsSource {
        GcsSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &GcsSource| { &m.uri },
                |m: &mut GcsSource| { &mut m.uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsSource>(
                "GcsSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsSource {
        static instance: ::protobuf::rt::LazyV2<GcsSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsSource::new)
    }
}

impl ::protobuf::Clear for GcsSource {
    fn clear(&mut self) {
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcsDestination {
    // message fields
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcsDestination {
    fn default() -> &'a GcsDestination {
        <GcsDestination as ::protobuf::Message>::default_instance()
    }
}

impl GcsDestination {
    pub fn new() -> GcsDestination {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GcsDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcsDestination {
        GcsDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &GcsDestination| { &m.uri },
                |m: &mut GcsDestination| { &mut m.uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GcsDestination>(
                "GcsDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GcsDestination {
        static instance: ::protobuf::rt::LazyV2<GcsDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GcsDestination::new)
    }
}

impl ::protobuf::Clear for GcsDestination {
    fn clear(&mut self) {
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GcsDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcsDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationMetadata {
    // message fields
    pub state: OperationMetadata_State,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationMetadata {
    fn default() -> &'a OperationMetadata {
        <OperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OperationMetadata {
    pub fn new() -> OperationMetadata {
        ::std::default::Default::default()
    }

    // .google.cloud.vision.v1.OperationMetadata.State state = 1;


    pub fn get_state(&self) -> OperationMetadata_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = OperationMetadata_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: OperationMetadata_State) {
        self.state = v;
    }

    // .google.protobuf.Timestamp create_time = 5;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 6;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for OperationMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != OperationMetadata_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != OperationMetadata_State::STATE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationMetadata {
        OperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationMetadata_State>>(
                "state",
                |m: &OperationMetadata| { &m.state },
                |m: &mut OperationMetadata| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &OperationMetadata| { &m.create_time },
                |m: &mut OperationMetadata| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &OperationMetadata| { &m.update_time },
                |m: &mut OperationMetadata| { &mut m.update_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationMetadata>(
                "OperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperationMetadata {
        static instance: ::protobuf::rt::LazyV2<OperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperationMetadata::new)
    }
}

impl ::protobuf::Clear for OperationMetadata {
    fn clear(&mut self) {
        self.state = OperationMetadata_State::STATE_UNSPECIFIED;
        self.create_time.clear();
        self.update_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationMetadata_State {
    STATE_UNSPECIFIED = 0,
    CREATED = 1,
    RUNNING = 2,
    DONE = 3,
    CANCELLED = 4,
}

impl ::protobuf::ProtobufEnum for OperationMetadata_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationMetadata_State> {
        match value {
            0 => ::std::option::Option::Some(OperationMetadata_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OperationMetadata_State::CREATED),
            2 => ::std::option::Option::Some(OperationMetadata_State::RUNNING),
            3 => ::std::option::Option::Some(OperationMetadata_State::DONE),
            4 => ::std::option::Option::Some(OperationMetadata_State::CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationMetadata_State] = &[
            OperationMetadata_State::STATE_UNSPECIFIED,
            OperationMetadata_State::CREATED,
            OperationMetadata_State::RUNNING,
            OperationMetadata_State::DONE,
            OperationMetadata_State::CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OperationMetadata_State>("OperationMetadata.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OperationMetadata_State {
}

impl ::std::default::Default for OperationMetadata_State {
    fn default() -> Self {
        OperationMetadata_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Likelihood {
    UNKNOWN = 0,
    VERY_UNLIKELY = 1,
    UNLIKELY = 2,
    POSSIBLE = 3,
    LIKELY = 4,
    VERY_LIKELY = 5,
}

impl ::protobuf::ProtobufEnum for Likelihood {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Likelihood> {
        match value {
            0 => ::std::option::Option::Some(Likelihood::UNKNOWN),
            1 => ::std::option::Option::Some(Likelihood::VERY_UNLIKELY),
            2 => ::std::option::Option::Some(Likelihood::UNLIKELY),
            3 => ::std::option::Option::Some(Likelihood::POSSIBLE),
            4 => ::std::option::Option::Some(Likelihood::LIKELY),
            5 => ::std::option::Option::Some(Likelihood::VERY_LIKELY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Likelihood] = &[
            Likelihood::UNKNOWN,
            Likelihood::VERY_UNLIKELY,
            Likelihood::UNLIKELY,
            Likelihood::POSSIBLE,
            Likelihood::LIKELY,
            Likelihood::VERY_LIKELY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Likelihood>("Likelihood", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Likelihood {
}

impl ::std::default::Default for Likelihood {
    fn default() -> Self {
        Likelihood::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Likelihood {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,google/cloud/vision/v1/image_annotator.proto\x12\x16google.cloud.visi\
    on.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\
    \x1a\x1fgoogle/api/field_behavior.proto\x1a%google/cloud/vision/v1/geome\
    try.proto\x1a+google/cloud/vision/v1/product_search.proto\x1a,google/clo\
    ud/vision/v1/text_annotation.proto\x1a*google/cloud/vision/v1/web_detect\
    ion.proto\x1a#google/longrunning/operations.proto\x1a\x20google/protobuf\
    /field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x17google/r\
    pc/status.proto\x1a\x17google/type/color.proto\x1a\x18google/type/latlng\
    .proto\"\xa0\x03\n\x07Feature\x128\n\x04type\x18\x01\x20\x01(\x0e2$.goog\
    le.cloud.vision.v1.Feature.TypeR\x04type\x12\x1f\n\x0bmax_results\x18\
    \x02\x20\x01(\x05R\nmaxResults\x12\x14\n\x05model\x18\x03\x20\x01(\tR\
    \x05model\"\xa3\x02\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\
    \x12\n\x0eFACE_DETECTION\x10\x01\x12\x16\n\x12LANDMARK_DETECTION\x10\x02\
    \x12\x12\n\x0eLOGO_DETECTION\x10\x03\x12\x13\n\x0fLABEL_DETECTION\x10\
    \x04\x12\x12\n\x0eTEXT_DETECTION\x10\x05\x12\x1b\n\x17DOCUMENT_TEXT_DETE\
    CTION\x10\x0b\x12\x19\n\x15SAFE_SEARCH_DETECTION\x10\x06\x12\x14\n\x10IM\
    AGE_PROPERTIES\x10\x07\x12\x0e\n\nCROP_HINTS\x10\t\x12\x11\n\rWEB_DETECT\
    ION\x10\n\x12\x12\n\x0ePRODUCT_SEARCH\x10\x0c\x12\x17\n\x13OBJECT_LOCALI\
    ZATION\x10\x13\"N\n\x0bImageSource\x12\"\n\rgcs_image_uri\x18\x01\x20\
    \x01(\tR\x0bgcsImageUri\x12\x1b\n\timage_uri\x18\x02\x20\x01(\tR\x08imag\
    eUri\"^\n\x05Image\x12\x18\n\x07content\x18\x01\x20\x01(\x0cR\x07content\
    \x12;\n\x06source\x18\x02\x20\x01(\x0b2#.google.cloud.vision.v1.ImageSou\
    rceR\x06source\"\xd1\x0f\n\x0eFaceAnnotation\x12I\n\rbounding_poly\x18\
    \x01\x20\x01(\x0b2$.google.cloud.vision.v1.BoundingPolyR\x0cboundingPoly\
    \x12N\n\x10fd_bounding_poly\x18\x02\x20\x01(\x0b2$.google.cloud.vision.v\
    1.BoundingPolyR\x0efdBoundingPoly\x12M\n\tlandmarks\x18\x03\x20\x03(\x0b\
    2/.google.cloud.vision.v1.FaceAnnotation.LandmarkR\tlandmarks\x12\x1d\n\
    \nroll_angle\x18\x04\x20\x01(\x02R\trollAngle\x12\x1b\n\tpan_angle\x18\
    \x05\x20\x01(\x02R\x08panAngle\x12\x1d\n\ntilt_angle\x18\x06\x20\x01(\
    \x02R\ttiltAngle\x121\n\x14detection_confidence\x18\x07\x20\x01(\x02R\
    \x13detectionConfidence\x125\n\x16landmarking_confidence\x18\x08\x20\x01\
    (\x02R\x15landmarkingConfidence\x12I\n\x0ejoy_likelihood\x18\t\x20\x01(\
    \x0e2\".google.cloud.vision.v1.LikelihoodR\rjoyLikelihood\x12O\n\x11sorr\
    ow_likelihood\x18\n\x20\x01(\x0e2\".google.cloud.vision.v1.LikelihoodR\
    \x10sorrowLikelihood\x12M\n\x10anger_likelihood\x18\x0b\x20\x01(\x0e2\".\
    google.cloud.vision.v1.LikelihoodR\x0fangerLikelihood\x12S\n\x13surprise\
    _likelihood\x18\x0c\x20\x01(\x0e2\".google.cloud.vision.v1.LikelihoodR\
    \x12surpriseLikelihood\x12\\\n\x18under_exposed_likelihood\x18\r\x20\x01\
    (\x0e2\".google.cloud.vision.v1.LikelihoodR\x16underExposedLikelihood\
    \x12Q\n\x12blurred_likelihood\x18\x0e\x20\x01(\x0e2\".google.cloud.visio\
    n.v1.LikelihoodR\x11blurredLikelihood\x12S\n\x13headwear_likelihood\x18\
    \x0f\x20\x01(\x0e2\".google.cloud.vision.v1.LikelihoodR\x12headwearLikel\
    ihood\x1a\xc9\x07\n\x08Landmark\x12H\n\x04type\x18\x03\x20\x01(\x0e24.go\
    ogle.cloud.vision.v1.FaceAnnotation.Landmark.TypeR\x04type\x12<\n\x08pos\
    ition\x18\x04\x20\x01(\x0b2\x20.google.cloud.vision.v1.PositionR\x08posi\
    tion\"\xb4\x06\n\x04Type\x12\x14\n\x10UNKNOWN_LANDMARK\x10\0\x12\x0c\n\
    \x08LEFT_EYE\x10\x01\x12\r\n\tRIGHT_EYE\x10\x02\x12\x18\n\x14LEFT_OF_LEF\
    T_EYEBROW\x10\x03\x12\x19\n\x15RIGHT_OF_LEFT_EYEBROW\x10\x04\x12\x19\n\
    \x15LEFT_OF_RIGHT_EYEBROW\x10\x05\x12\x1a\n\x16RIGHT_OF_RIGHT_EYEBROW\
    \x10\x06\x12\x19\n\x15MIDPOINT_BETWEEN_EYES\x10\x07\x12\x0c\n\x08NOSE_TI\
    P\x10\x08\x12\r\n\tUPPER_LIP\x10\t\x12\r\n\tLOWER_LIP\x10\n\x12\x0e\n\nM\
    OUTH_LEFT\x10\x0b\x12\x0f\n\x0bMOUTH_RIGHT\x10\x0c\x12\x10\n\x0cMOUTH_CE\
    NTER\x10\r\x12\x15\n\x11NOSE_BOTTOM_RIGHT\x10\x0e\x12\x14\n\x10NOSE_BOTT\
    OM_LEFT\x10\x0f\x12\x16\n\x12NOSE_BOTTOM_CENTER\x10\x10\x12\x19\n\x15LEF\
    T_EYE_TOP_BOUNDARY\x10\x11\x12\x19\n\x15LEFT_EYE_RIGHT_CORNER\x10\x12\
    \x12\x1c\n\x18LEFT_EYE_BOTTOM_BOUNDARY\x10\x13\x12\x18\n\x14LEFT_EYE_LEF\
    T_CORNER\x10\x14\x12\x1a\n\x16RIGHT_EYE_TOP_BOUNDARY\x10\x15\x12\x1a\n\
    \x16RIGHT_EYE_RIGHT_CORNER\x10\x16\x12\x1d\n\x19RIGHT_EYE_BOTTOM_BOUNDAR\
    Y\x10\x17\x12\x19\n\x15RIGHT_EYE_LEFT_CORNER\x10\x18\x12\x1f\n\x1bLEFT_E\
    YEBROW_UPPER_MIDPOINT\x10\x19\x12\x20\n\x1cRIGHT_EYEBROW_UPPER_MIDPOINT\
    \x10\x1a\x12\x14\n\x10LEFT_EAR_TRAGION\x10\x1b\x12\x15\n\x11RIGHT_EAR_TR\
    AGION\x10\x1c\x12\x12\n\x0eLEFT_EYE_PUPIL\x10\x1d\x12\x13\n\x0fRIGHT_EYE\
    _PUPIL\x10\x1e\x12\x15\n\x11FOREHEAD_GLABELLA\x10\x1f\x12\x11\n\rCHIN_GN\
    ATHION\x10\x20\x12\x14\n\x10CHIN_LEFT_GONION\x10!\x12\x15\n\x11CHIN_RIGH\
    T_GONION\x10\"\"<\n\x0cLocationInfo\x12,\n\x07lat_lng\x18\x01\x20\x01(\
    \x0b2\x13.google.type.LatLngR\x06latLng\"W\n\x08Property\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value\x12!\n\x0cuint64_value\x18\x03\x20\x01(\x04R\x0buint64Value\"\
    \x89\x03\n\x10EntityAnnotation\x12\x10\n\x03mid\x18\x01\x20\x01(\tR\x03m\
    id\x12\x16\n\x06locale\x18\x02\x20\x01(\tR\x06locale\x12\x20\n\x0bdescri\
    ption\x18\x03\x20\x01(\tR\x0bdescription\x12\x14\n\x05score\x18\x04\x20\
    \x01(\x02R\x05score\x12\"\n\nconfidence\x18\x05\x20\x01(\x02R\nconfidenc\
    eB\x02\x18\x01\x12\x1e\n\ntopicality\x18\x06\x20\x01(\x02R\ntopicality\
    \x12I\n\rbounding_poly\x18\x07\x20\x01(\x0b2$.google.cloud.vision.v1.Bou\
    ndingPolyR\x0cboundingPoly\x12B\n\tlocations\x18\x08\x20\x03(\x0b2$.goog\
    le.cloud.vision.v1.LocationInfoR\tlocations\x12@\n\nproperties\x18\t\x20\
    \x03(\x0b2\x20.google.cloud.vision.v1.PropertyR\nproperties\"\xc7\x01\n\
    \x19LocalizedObjectAnnotation\x12\x10\n\x03mid\x18\x01\x20\x01(\tR\x03mi\
    d\x12#\n\rlanguage_code\x18\x02\x20\x01(\tR\x0clanguageCode\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05score\x18\x04\x20\x01(\
    \x02R\x05score\x12I\n\rbounding_poly\x18\x05\x20\x01(\x0b2$.google.cloud\
    .vision.v1.BoundingPolyR\x0cboundingPoly\"\xc8\x04\n\x14SafeSearchAnnota\
    tion\x128\n\x05adult\x18\x01\x20\x01(\x0e2\".google.cloud.vision.v1.Like\
    lihoodR\x05adult\x128\n\x05spoof\x18\x02\x20\x01(\x0e2\".google.cloud.vi\
    sion.v1.LikelihoodR\x05spoof\x12<\n\x07medical\x18\x03\x20\x01(\x0e2\".g\
    oogle.cloud.vision.v1.LikelihoodR\x07medical\x12>\n\x08violence\x18\x04\
    \x20\x01(\x0e2\".google.cloud.vision.v1.LikelihoodR\x08violence\x126\n\
    \x04racy\x18\t\x20\x01(\x0e2\".google.cloud.vision.v1.LikelihoodR\x04rac\
    y\x12)\n\x10adult_confidence\x18\x10\x20\x01(\x02R\x0fadultConfidence\
    \x12)\n\x10spoof_confidence\x18\x12\x20\x01(\x02R\x0fspoofConfidence\x12\
    -\n\x12medical_confidence\x18\x14\x20\x01(\x02R\x11medicalConfidence\x12\
    /\n\x13violence_confidence\x18\x16\x20\x01(\x02R\x12violenceConfidence\
    \x12'\n\x0fracy_confidence\x18\x18\x20\x01(\x02R\x0eracyConfidence\x12'\
    \n\x0fnsfw_confidence\x18\x1a\x20\x01(\x02R\x0ensfwConfidence\"w\n\x0bLa\
    tLongRect\x123\n\x0bmin_lat_lng\x18\x01\x20\x01(\x0b2\x13.google.type.La\
    tLngR\tminLatLng\x123\n\x0bmax_lat_lng\x18\x02\x20\x01(\x0b2\x13.google.\
    type.LatLngR\tmaxLatLng\"r\n\tColorInfo\x12(\n\x05color\x18\x01\x20\x01(\
    \x0b2\x12.google.type.ColorR\x05color\x12\x14\n\x05score\x18\x02\x20\x01\
    (\x02R\x05score\x12%\n\x0epixel_fraction\x18\x03\x20\x01(\x02R\rpixelFra\
    ction\"U\n\x18DominantColorsAnnotation\x129\n\x06colors\x18\x01\x20\x03(\
    \x0b2!.google.cloud.vision.v1.ColorInfoR\x06colors\"l\n\x0fImageProperti\
    es\x12Y\n\x0fdominant_colors\x18\x01\x20\x01(\x0b20.google.cloud.vision.\
    v1.DominantColorsAnnotationR\x0edominantColors\"\xa6\x01\n\x08CropHint\
    \x12I\n\rbounding_poly\x18\x01\x20\x01(\x0b2$.google.cloud.vision.v1.Bou\
    ndingPolyR\x0cboundingPoly\x12\x1e\n\nconfidence\x18\x02\x20\x01(\x02R\n\
    confidence\x12/\n\x13importance_fraction\x18\x03\x20\x01(\x02R\x12import\
    anceFraction\"V\n\x13CropHintsAnnotation\x12?\n\ncrop_hints\x18\x01\x20\
    \x03(\x0b2\x20.google.cloud.vision.v1.CropHintR\tcropHints\"6\n\x0fCropH\
    intsParams\x12#\n\raspect_ratios\x18\x01\x20\x03(\x02R\x0caspectRatios\"\
    D\n\x12WebDetectionParams\x12.\n\x13include_geo_results\x18\x02\x20\x01(\
    \x08R\x11includeGeoResults\"\x92\x03\n\x0cImageContext\x12G\n\rlat_long_\
    rect\x18\x01\x20\x01(\x0b2#.google.cloud.vision.v1.LatLongRectR\x0blatLo\
    ngRect\x12%\n\x0elanguage_hints\x18\x02\x20\x03(\tR\rlanguageHints\x12S\
    \n\x11crop_hints_params\x18\x04\x20\x01(\x0b2'.google.cloud.vision.v1.Cr\
    opHintsParamsR\x0fcropHintsParams\x12_\n\x15product_search_params\x18\
    \x05\x20\x01(\x0b2+.google.cloud.vision.v1.ProductSearchParamsR\x13produ\
    ctSearchParams\x12\\\n\x14web_detection_params\x18\x06\x20\x01(\x0b2*.go\
    ogle.cloud.vision.v1.WebDetectionParamsR\x12webDetectionParams\"\xd3\x01\
    \n\x14AnnotateImageRequest\x123\n\x05image\x18\x01\x20\x01(\x0b2\x1d.goo\
    gle.cloud.vision.v1.ImageR\x05image\x12;\n\x08features\x18\x02\x20\x03(\
    \x0b2\x1f.google.cloud.vision.v1.FeatureR\x08features\x12I\n\rimage_cont\
    ext\x18\x03\x20\x01(\x0b2$.google.cloud.vision.v1.ImageContextR\x0cimage\
    Context\"K\n\x16ImageAnnotationContext\x12\x10\n\x03uri\x18\x01\x20\x01(\
    \tR\x03uri\x12\x1f\n\x0bpage_number\x18\x02\x20\x01(\x05R\npageNumber\"\
    \xe8\t\n\x15AnnotateImageResponse\x12Q\n\x10face_annotations\x18\x01\x20\
    \x03(\x0b2&.google.cloud.vision.v1.FaceAnnotationR\x0ffaceAnnotations\
    \x12[\n\x14landmark_annotations\x18\x02\x20\x03(\x0b2(.google.cloud.visi\
    on.v1.EntityAnnotationR\x13landmarkAnnotations\x12S\n\x10logo_annotation\
    s\x18\x03\x20\x03(\x0b2(.google.cloud.vision.v1.EntityAnnotationR\x0flog\
    oAnnotations\x12U\n\x11label_annotations\x18\x04\x20\x03(\x0b2(.google.c\
    loud.vision.v1.EntityAnnotationR\x10labelAnnotations\x12s\n\x1clocalized\
    _object_annotations\x18\x16\x20\x03(\x0b21.google.cloud.vision.v1.Locali\
    zedObjectAnnotationR\x1alocalizedObjectAnnotations\x12S\n\x10text_annota\
    tions\x18\x05\x20\x03(\x0b2(.google.cloud.vision.v1.EntityAnnotationR\
    \x0ftextAnnotations\x12X\n\x14full_text_annotation\x18\x0c\x20\x01(\x0b2\
    &.google.cloud.vision.v1.TextAnnotationR\x12fullTextAnnotation\x12b\n\
    \x16safe_search_annotation\x18\x06\x20\x01(\x0b2,.google.cloud.vision.v1\
    .SafeSearchAnnotationR\x14safeSearchAnnotation\x12g\n\x1bimage_propertie\
    s_annotation\x18\x08\x20\x01(\x0b2'.google.cloud.vision.v1.ImageProperti\
    esR\x19imagePropertiesAnnotation\x12_\n\x15crop_hints_annotation\x18\x0b\
    \x20\x01(\x0b2+.google.cloud.vision.v1.CropHintsAnnotationR\x13cropHints\
    Annotation\x12I\n\rweb_detection\x18\r\x20\x01(\x0b2$.google.cloud.visio\
    n.v1.WebDetectionR\x0cwebDetection\x12b\n\x16product_search_results\x18\
    \x0e\x20\x01(\x0b2,.google.cloud.vision.v1.ProductSearchResultsR\x14prod\
    uctSearchResults\x12(\n\x05error\x18\t\x20\x01(\x0b2\x12.google.rpc.Stat\
    usR\x05error\x12H\n\x07context\x18\x15\x20\x01(\x0b2..google.cloud.visio\
    n.v1.ImageAnnotationContextR\x07context\"\x83\x01\n\x1aBatchAnnotateImag\
    esRequest\x12M\n\x08requests\x18\x01\x20\x03(\x0b2,.google.cloud.vision.\
    v1.AnnotateImageRequestR\x08requestsB\x03\xe0A\x02\x12\x16\n\x06parent\
    \x18\x04\x20\x01(\tR\x06parent\"j\n\x1bBatchAnnotateImagesResponse\x12K\
    \n\tresponses\x18\x01\x20\x03(\x0b2-.google.cloud.vision.v1.AnnotateImag\
    eResponseR\tresponses\"\xfb\x01\n\x13AnnotateFileRequest\x12F\n\x0cinput\
    _config\x18\x01\x20\x01(\x0b2#.google.cloud.vision.v1.InputConfigR\x0bin\
    putConfig\x12;\n\x08features\x18\x02\x20\x03(\x0b2\x1f.google.cloud.visi\
    on.v1.FeatureR\x08features\x12I\n\rimage_context\x18\x03\x20\x01(\x0b2$.\
    google.cloud.vision.v1.ImageContextR\x0cimageContext\x12\x14\n\x05pages\
    \x18\x04\x20\x03(\x05R\x05pages\"\xf6\x01\n\x14AnnotateFileResponse\x12F\
    \n\x0cinput_config\x18\x01\x20\x01(\x0b2#.google.cloud.vision.v1.InputCo\
    nfigR\x0binputConfig\x12K\n\tresponses\x18\x02\x20\x03(\x0b2-.google.clo\
    ud.vision.v1.AnnotateImageResponseR\tresponses\x12\x1f\n\x0btotal_pages\
    \x18\x03\x20\x01(\x05R\ntotalPages\x12(\n\x05error\x18\x04\x20\x01(\x0b2\
    \x12.google.rpc.StatusR\x05error\"\x81\x01\n\x19BatchAnnotateFilesReques\
    t\x12L\n\x08requests\x18\x01\x20\x03(\x0b2+.google.cloud.vision.v1.Annot\
    ateFileRequestR\x08requestsB\x03\xe0A\x02\x12\x16\n\x06parent\x18\x03\
    \x20\x01(\tR\x06parent\"h\n\x1aBatchAnnotateFilesResponse\x12J\n\trespon\
    ses\x18\x01\x20\x03(\x0b2,.google.cloud.vision.v1.AnnotateFileResponseR\
    \tresponses\"\xb5\x02\n\x18AsyncAnnotateFileRequest\x12F\n\x0cinput_conf\
    ig\x18\x01\x20\x01(\x0b2#.google.cloud.vision.v1.InputConfigR\x0binputCo\
    nfig\x12;\n\x08features\x18\x02\x20\x03(\x0b2\x1f.google.cloud.vision.v1\
    .FeatureR\x08features\x12I\n\rimage_context\x18\x03\x20\x01(\x0b2$.googl\
    e.cloud.vision.v1.ImageContextR\x0cimageContext\x12I\n\routput_config\
    \x18\x04\x20\x01(\x0b2$.google.cloud.vision.v1.OutputConfigR\x0coutputCo\
    nfig\"f\n\x19AsyncAnnotateFileResponse\x12I\n\routput_config\x18\x01\x20\
    \x01(\x0b2$.google.cloud.vision.v1.OutputConfigR\x0coutputConfig\"\xd8\
    \x01\n\x1fAsyncBatchAnnotateImagesRequest\x12M\n\x08requests\x18\x01\x20\
    \x03(\x0b2,.google.cloud.vision.v1.AnnotateImageRequestR\x08requestsB\
    \x03\xe0A\x02\x12N\n\routput_config\x18\x02\x20\x01(\x0b2$.google.cloud.\
    vision.v1.OutputConfigR\x0coutputConfigB\x03\xe0A\x02\x12\x16\n\x06paren\
    t\x18\x04\x20\x01(\tR\x06parent\"m\n\x20AsyncBatchAnnotateImagesResponse\
    \x12I\n\routput_config\x18\x01\x20\x01(\x0b2$.google.cloud.vision.v1.Out\
    putConfigR\x0coutputConfig\"\x8b\x01\n\x1eAsyncBatchAnnotateFilesRequest\
    \x12Q\n\x08requests\x18\x01\x20\x03(\x0b20.google.cloud.vision.v1.AsyncA\
    nnotateFileRequestR\x08requestsB\x03\xe0A\x02\x12\x16\n\x06parent\x18\
    \x04\x20\x01(\tR\x06parent\"r\n\x1fAsyncBatchAnnotateFilesResponse\x12O\
    \n\tresponses\x18\x01\x20\x03(\x0b21.google.cloud.vision.v1.AsyncAnnotat\
    eFileResponseR\tresponses\"\x86\x01\n\x0bInputConfig\x12@\n\ngcs_source\
    \x18\x01\x20\x01(\x0b2!.google.cloud.vision.v1.GcsSourceR\tgcsSource\x12\
    \x18\n\x07content\x18\x03\x20\x01(\x0cR\x07content\x12\x1b\n\tmime_type\
    \x18\x02\x20\x01(\tR\x08mimeType\"~\n\x0cOutputConfig\x12O\n\x0fgcs_dest\
    ination\x18\x01\x20\x01(\x0b2&.google.cloud.vision.v1.GcsDestinationR\
    \x0egcsDestination\x12\x1d\n\nbatch_size\x18\x02\x20\x01(\x05R\tbatchSiz\
    e\"\x1d\n\tGcsSource\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\"\"\n\
    \x0eGcsDestination\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\"\xa7\x02\
    \n\x11OperationMetadata\x12E\n\x05state\x18\x01\x20\x01(\x0e2/.google.cl\
    oud.vision.v1.OperationMetadata.StateR\x05state\x12;\n\x0bcreate_time\
    \x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\
    \x0bupdate_time\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nup\
    dateTime\"Q\n\x05State\x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\x0b\n\
    \x07CREATED\x10\x01\x12\x0b\n\x07RUNNING\x10\x02\x12\x08\n\x04DONE\x10\
    \x03\x12\r\n\tCANCELLED\x10\x04*e\n\nLikelihood\x12\x0b\n\x07UNKNOWN\x10\
    \0\x12\x11\n\rVERY_UNLIKELY\x10\x01\x12\x0c\n\x08UNLIKELY\x10\x02\x12\
    \x0c\n\x08POSSIBLE\x10\x03\x12\n\n\x06LIKELY\x10\x04\x12\x0f\n\x0bVERY_L\
    IKELY\x10\x052\xf5\n\n\x0eImageAnnotator\x12\x93\x02\n\x13BatchAnnotateI\
    mages\x122.google.cloud.vision.v1.BatchAnnotateImagesRequest\x1a3.google\
    .cloud.vision.v1.BatchAnnotateImagesResponse\"\x92\x01\x82\xd3\xe4\x93\
    \x02\x80\x01\"\x13/v1/images:annotate:\x01*Z8\"3/v1/{parent=projects/*/l\
    ocations/*}/images:annotate:\x01*Z,\"'/v1/{parent=projects/*}/images:ann\
    otate:\x01*\xdaA\x08requests\x12\x8c\x02\n\x12BatchAnnotateFiles\x121.go\
    ogle.cloud.vision.v1.BatchAnnotateFilesRequest\x1a2.google.cloud.vision.\
    v1.BatchAnnotateFilesResponse\"\x8e\x01\x82\xd3\xe4\x93\x02}\"\x12/v1/fi\
    les:annotate:\x01*Z7\"2/v1/{parent=projects/*/locations/*}/files:annotat\
    e:\x01*Z+\"&/v1/{parent=projects/*}/files:annotate:\x01*\xdaA\x08request\
    s\x12\xeb\x02\n\x18AsyncBatchAnnotateImages\x127.google.cloud.vision.v1.\
    AsyncBatchAnnotateImagesRequest\x1a\x1d.google.longrunning.Operation\"\
    \xf6\x01\xcaA5\n\x20AsyncBatchAnnotateImagesResponse\x12\x11OperationMet\
    adata\x82\xd3\xe4\x93\x02\x9e\x01\"\x1d/v1/images:asyncBatchAnnotate:\
    \x01*ZB\"=/v1/{parent=projects/*/locations/*}/images:asyncBatchAnnotate:\
    \x01*Z6\"1/v1/{parent=projects/*}/images:asyncBatchAnnotate:\x01*\xdaA\
    \x16requests,output_config\x12\xd7\x02\n\x17AsyncBatchAnnotateFiles\x126\
    .google.cloud.vision.v1.AsyncBatchAnnotateFilesRequest\x1a\x1d.google.lo\
    ngrunning.Operation\"\xe4\x01\xcaA4\n\x1fAsyncBatchAnnotateFilesResponse\
    \x12\x11OperationMetadata\x82\xd3\xe4\x93\x02\x9b\x01\"\x1c/v1/files:asy\
    ncBatchAnnotate:\x01*ZA\"</v1/{parent=projects/*/locations/*}/files:asyn\
    cBatchAnnotate:\x01*Z5\"0/v1/{parent=projects/*}/files:asyncBatchAnnotat\
    e:\x01*\xdaA\x08requests\x1av\xd2A[https://www.googleapis.com/auth/cloud\
    -platform,https://www.googleapis.com/auth/cloud-vision\xcaA\x15vision.go\
    ogleapis.comB{\n\x1acom.google.cloud.vision.v1B\x13ImageAnnotatorProtoP\
    \x01Z<google.golang.org/genproto/googleapis/cloud/vision/v1;vision\xf8\
    \x01\x01\xa2\x02\x04GCVNJ\x8e\x9a\x02\n\x07\x12\x05\x0f\0\x94\x08\x01\n\
    \xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Go\
    ogle\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ve\
    rsion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20t\
    his\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1f\n\t\n\x02\x03\
    \0\x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0!\n\t\n\x02\x03\x02\x12\
    \x03\x15\0)\n\t\n\x02\x03\x03\x12\x03\x16\0/\n\t\n\x02\x03\x04\x12\x03\
    \x17\05\n\t\n\x02\x03\x05\x12\x03\x18\06\n\t\n\x02\x03\x06\x12\x03\x19\0\
    4\n\t\n\x02\x03\x07\x12\x03\x1a\0-\n\t\n\x02\x03\x08\x12\x03\x1b\0*\n\t\
    \n\x02\x03\t\x12\x03\x1c\0)\n\t\n\x02\x03\n\x12\x03\x1d\0!\n\t\n\x02\x03\
    \x0b\x12\x03\x1e\0!\n\t\n\x02\x03\x0c\x12\x03\x1f\0\"\n\x08\n\x01\x08\
    \x12\x03!\0\x1f\n\t\n\x02\x08\x1f\x12\x03!\0\x1f\n\x08\n\x01\x08\x12\x03\
    \"\0S\n\t\n\x02\x08\x0b\x12\x03\"\0S\n\x08\n\x01\x08\x12\x03#\0\"\n\t\n\
    \x02\x08\n\x12\x03#\0\"\n\x08\n\x01\x08\x12\x03$\04\n\t\n\x02\x08\x08\
    \x12\x03$\04\n\x08\n\x01\x08\x12\x03%\03\n\t\n\x02\x08\x01\x12\x03%\03\n\
    \x08\n\x01\x08\x12\x03&\0\"\n\t\n\x02\x08$\x12\x03&\0\"\n\xe2\x01\n\x02\
    \x06\0\x12\x05+\0\x8f\x01\x01\x1a\xd4\x01\x20Service\x20that\x20performs\
    \x20Google\x20Cloud\x20Vision\x20API\x20detection\x20tasks\x20over\x20cl\
    ient\n\x20images,\x20such\x20as\x20face,\x20landmark,\x20logo,\x20label,\
    \x20and\x20text\x20detection.\x20The\n\x20ImageAnnotator\x20service\x20r\
    eturns\x20detected\x20entities\x20from\x20the\x20images.\n\n\n\n\x03\x06\
    \0\x01\x12\x03+\x08\x16\n\n\n\x03\x06\0\x03\x12\x03,\x02=\n\x0c\n\x05\
    \x06\0\x03\x99\x08\x12\x03,\x02=\n\x0b\n\x03\x06\0\x03\x12\x04-\x02/5\n\
    \r\n\x05\x06\0\x03\x9a\x08\x12\x04-\x02/5\nI\n\x04\x06\0\x02\0\x12\x042\
    \x02@\x03\x1a;\x20Run\x20image\x20detection\x20and\x20annotation\x20for\
    \x20a\x20batch\x20of\x20images.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x032\
    \x06\x19\n\x0c\n\x05\x06\0\x02\0\x02\x12\x032\x1a4\n\x0c\n\x05\x06\0\x02\
    \0\x03\x12\x032?Z\n\r\n\x05\x06\0\x02\0\x04\x12\x043\x04>\x06\n\x11\n\t\
    \x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x043\x04>\x06\n\x0c\n\x05\x06\0\x02\0\
    \x04\x12\x03?\x046\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03?\x046\n\
    \x85\x03\n\x04\x06\0\x02\x01\x12\x04I\x02W\x03\x1a\xf6\x02\x20Service\
    \x20that\x20performs\x20image\x20detection\x20and\x20annotation\x20for\
    \x20a\x20batch\x20of\x20files.\n\x20Now\x20only\x20\"application/pdf\",\
    \x20\"image/tiff\"\x20and\x20\"image/gif\"\x20are\x20supported.\n\n\x20T\
    his\x20service\x20will\x20extract\x20at\x20most\x205\x20(customers\x20ca\
    n\x20specify\x20which\x205\x20in\n\x20AnnotateFileRequest.pages)\x20fram\
    es\x20(gif)\x20or\x20pages\x20(pdf\x20or\x20tiff)\x20from\x20each\n\x20f\
    ile\x20provided\x20and\x20perform\x20detection\x20and\x20annotation\x20f\
    or\x20each\x20image\n\x20extracted.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\
    \x03I\x06\x18\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03I\x192\n\x0c\n\x05\
    \x06\0\x02\x01\x03\x12\x03I=W\n\r\n\x05\x06\0\x02\x01\x04\x12\x04J\x04U\
    \x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04J\x04U\x06\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03V\x046\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\
    \x08\0\x12\x03V\x046\n\xd9\x03\n\x04\x06\0\x02\x02\x12\x04b\x02t\x03\x1a\
    \xca\x03\x20Run\x20asynchronous\x20image\x20detection\x20and\x20annotati\
    on\x20for\x20a\x20list\x20of\x20images.\n\n\x20Progress\x20and\x20result\
    s\x20can\x20be\x20retrieved\x20through\x20the\n\x20`google.longrunning.O\
    perations`\x20interface.\n\x20`Operation.metadata`\x20contains\x20`Opera\
    tionMetadata`\x20(metadata).\n\x20`Operation.response`\x20contains\x20`A\
    syncBatchAnnotateImagesResponse`\x20(results).\n\n\x20This\x20service\
    \x20will\x20write\x20image\x20annotation\x20outputs\x20to\x20json\x20fil\
    es\x20in\x20customer\n\x20GCS\x20bucket,\x20each\x20json\x20file\x20cont\
    aining\x20BatchAnnotateImagesResponse\x20proto.\n\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03b\x06\x1e\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03b\x1f>\n\
    \x0c\n\x05\x06\0\x02\x02\x03\x12\x03bIe\n\r\n\x05\x06\0\x02\x02\x04\x12\
    \x04c\x04n\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04c\x04n\
    \x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03o\x04D\n\x0f\n\x08\x06\0\x02\
    \x02\x04\x9b\x08\0\x12\x03o\x04D\n\r\n\x05\x06\0\x02\x02\x04\x12\x04p\
    \x04s\x06\n\x0f\n\x07\x06\0\x02\x02\x04\x99\x08\x12\x04p\x04s\x06\n\x9b\
    \x03\n\x04\x06\0\x02\x03\x12\x05|\x02\x8e\x01\x03\x1a\x8b\x03\x20Run\x20\
    asynchronous\x20image\x20detection\x20and\x20annotation\x20for\x20a\x20l\
    ist\x20of\x20generic\n\x20files,\x20such\x20as\x20PDF\x20files,\x20which\
    \x20may\x20contain\x20multiple\x20pages\x20and\x20multiple\n\x20images\
    \x20per\x20page.\x20Progress\x20and\x20results\x20can\x20be\x20retrieved\
    \x20through\x20the\n\x20`google.longrunning.Operations`\x20interface.\n\
    \x20`Operation.metadata`\x20contains\x20`OperationMetadata`\x20(metadata\
    ).\n\x20`Operation.response`\x20contains\x20`AsyncBatchAnnotateFilesResp\
    onse`\x20(results).\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03|\x06\x1d\n\
    \x0c\n\x05\x06\0\x02\x03\x02\x12\x03|\x1e<\n\x0c\n\x05\x06\0\x02\x03\x03\
    \x12\x03|Gc\n\x0e\n\x05\x06\0\x02\x03\x04\x12\x05}\x04\x88\x01\x06\n\x12\
    \n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x05}\x04\x88\x01\x06\n\r\n\x05\
    \x06\0\x02\x03\x04\x12\x04\x89\x01\x046\n\x10\n\x08\x06\0\x02\x03\x04\
    \x9b\x08\0\x12\x04\x89\x01\x046\n\x0f\n\x05\x06\0\x02\x03\x04\x12\x06\
    \x8a\x01\x04\x8d\x01\x06\n\x11\n\x07\x06\0\x02\x03\x04\x99\x08\x12\x06\
    \x8a\x01\x04\x8d\x01\x06\n\xcb\x01\n\x02\x04\0\x12\x06\x94\x01\0\xcf\x01\
    \x01\x1a\xbc\x01\x20The\x20type\x20of\x20Google\x20Cloud\x20Vision\x20AP\
    I\x20detection\x20to\x20perform,\x20and\x20the\x20maximum\n\x20number\
    \x20of\x20results\x20to\x20return\x20for\x20that\x20type.\x20Multiple\
    \x20`Feature`\x20objects\x20can\n\x20be\x20specified\x20in\x20the\x20`fe\
    atures`\x20list.\n\n\x0b\n\x03\x04\0\x01\x12\x04\x94\x01\x08\x0f\nJ\n\
    \x04\x04\0\x04\0\x12\x06\x96\x01\x02\xc2\x01\x03\x1a:\x20Type\x20of\x20G\
    oogle\x20Cloud\x20Vision\x20API\x20feature\x20to\x20be\x20extracted.\n\n\
    \r\n\x05\x04\0\x04\0\x01\x12\x04\x96\x01\x07\x0b\n+\n\x06\x04\0\x04\0\
    \x02\0\x12\x04\x98\x01\x04\x19\x1a\x1b\x20Unspecified\x20feature\x20type\
    .\n\n\x0f\n\x07\x04\0\x04\0\x02\0\x01\x12\x04\x98\x01\x04\x14\n\x0f\n\
    \x07\x04\0\x04\0\x02\0\x02\x12\x04\x98\x01\x17\x18\n%\n\x06\x04\0\x04\0\
    \x02\x01\x12\x04\x9b\x01\x04\x17\x1a\x15\x20Run\x20face\x20detection.\n\
    \n\x0f\n\x07\x04\0\x04\0\x02\x01\x01\x12\x04\x9b\x01\x04\x12\n\x0f\n\x07\
    \x04\0\x04\0\x02\x01\x02\x12\x04\x9b\x01\x15\x16\n)\n\x06\x04\0\x04\0\
    \x02\x02\x12\x04\x9e\x01\x04\x1b\x1a\x19\x20Run\x20landmark\x20detection\
    .\n\n\x0f\n\x07\x04\0\x04\0\x02\x02\x01\x12\x04\x9e\x01\x04\x16\n\x0f\n\
    \x07\x04\0\x04\0\x02\x02\x02\x12\x04\x9e\x01\x19\x1a\n%\n\x06\x04\0\x04\
    \0\x02\x03\x12\x04\xa1\x01\x04\x17\x1a\x15\x20Run\x20logo\x20detection.\
    \n\n\x0f\n\x07\x04\0\x04\0\x02\x03\x01\x12\x04\xa1\x01\x04\x12\n\x0f\n\
    \x07\x04\0\x04\0\x02\x03\x02\x12\x04\xa1\x01\x15\x16\n&\n\x06\x04\0\x04\
    \0\x02\x04\x12\x04\xa4\x01\x04\x18\x1a\x16\x20Run\x20label\x20detection.\
    \n\n\x0f\n\x07\x04\0\x04\0\x02\x04\x01\x12\x04\xa4\x01\x04\x13\n\x0f\n\
    \x07\x04\0\x04\0\x02\x04\x02\x12\x04\xa4\x01\x16\x17\n\xd6\x01\n\x06\x04\
    \0\x04\0\x02\x05\x12\x04\xa9\x01\x04\x17\x1a\xc5\x01\x20Run\x20text\x20d\
    etection\x20/\x20optical\x20character\x20recognition\x20(OCR).\x20Text\
    \x20detection\n\x20is\x20optimized\x20for\x20areas\x20of\x20text\x20with\
    in\x20a\x20larger\x20image;\x20if\x20the\x20image\x20is\n\x20a\x20docume\
    nt,\x20use\x20`DOCUMENT_TEXT_DETECTION`\x20instead.\n\n\x0f\n\x07\x04\0\
    \x04\0\x02\x05\x01\x12\x04\xa9\x01\x04\x12\n\x0f\n\x07\x04\0\x04\0\x02\
    \x05\x02\x12\x04\xa9\x01\x15\x16\n\x86\x01\n\x06\x04\0\x04\0\x02\x06\x12\
    \x04\xad\x01\x04!\x1av\x20Run\x20dense\x20text\x20document\x20OCR.\x20Ta\
    kes\x20precedence\x20when\x20both\n\x20`DOCUMENT_TEXT_DETECTION`\x20and\
    \x20`TEXT_DETECTION`\x20are\x20present.\n\n\x0f\n\x07\x04\0\x04\0\x02\
    \x06\x01\x12\x04\xad\x01\x04\x1b\n\x0f\n\x07\x04\0\x04\0\x02\x06\x02\x12\
    \x04\xad\x01\x1e\x20\nW\n\x06\x04\0\x04\0\x02\x07\x12\x04\xb1\x01\x04\
    \x1e\x1aG\x20Run\x20Safe\x20Search\x20to\x20detect\x20potentially\x20uns\
    afe\n\x20or\x20undesirable\x20content.\n\n\x0f\n\x07\x04\0\x04\0\x02\x07\
    \x01\x12\x04\xb1\x01\x04\x19\n\x0f\n\x07\x04\0\x04\0\x02\x07\x02\x12\x04\
    \xb1\x01\x1c\x1d\nZ\n\x06\x04\0\x04\0\x02\x08\x12\x04\xb5\x01\x04\x19\
    \x1aJ\x20Compute\x20a\x20set\x20of\x20image\x20properties,\x20such\x20as\
    \x20the\n\x20image's\x20dominant\x20colors.\n\n\x0f\n\x07\x04\0\x04\0\
    \x02\x08\x01\x12\x04\xb5\x01\x04\x14\n\x0f\n\x07\x04\0\x04\0\x02\x08\x02\
    \x12\x04\xb5\x01\x17\x18\n!\n\x06\x04\0\x04\0\x02\t\x12\x04\xb8\x01\x04\
    \x13\x1a\x11\x20Run\x20crop\x20hints.\n\n\x0f\n\x07\x04\0\x04\0\x02\t\
    \x01\x12\x04\xb8\x01\x04\x0e\n\x0f\n\x07\x04\0\x04\0\x02\t\x02\x12\x04\
    \xb8\x01\x11\x12\n$\n\x06\x04\0\x04\0\x02\n\x12\x04\xbb\x01\x04\x17\x1a\
    \x14\x20Run\x20web\x20detection.\n\n\x0f\n\x07\x04\0\x04\0\x02\n\x01\x12\
    \x04\xbb\x01\x04\x11\n\x0f\n\x07\x04\0\x04\0\x02\n\x02\x12\x04\xbb\x01\
    \x14\x16\n%\n\x06\x04\0\x04\0\x02\x0b\x12\x04\xbe\x01\x04\x18\x1a\x15\
    \x20Run\x20Product\x20Search.\n\n\x0f\n\x07\x04\0\x04\0\x02\x0b\x01\x12\
    \x04\xbe\x01\x04\x12\n\x0f\n\x07\x04\0\x04\0\x02\x0b\x02\x12\x04\xbe\x01\
    \x15\x17\n5\n\x06\x04\0\x04\0\x02\x0c\x12\x04\xc1\x01\x04\x1d\x1a%\x20Ru\
    n\x20localizer\x20for\x20object\x20detection.\n\n\x0f\n\x07\x04\0\x04\0\
    \x02\x0c\x01\x12\x04\xc1\x01\x04\x17\n\x0f\n\x07\x04\0\x04\0\x02\x0c\x02\
    \x12\x04\xc1\x01\x1a\x1c\n!\n\x04\x04\0\x02\0\x12\x04\xc5\x01\x02\x10\
    \x1a\x13\x20The\x20feature\x20type.\n\n\r\n\x05\x04\0\x02\0\x06\x12\x04\
    \xc5\x01\x02\x06\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xc5\x01\x07\x0b\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\xc5\x01\x0e\x0f\n\x88\x01\n\x04\x04\0\x02\
    \x01\x12\x04\xc9\x01\x02\x18\x1az\x20Maximum\x20number\x20of\x20results\
    \x20of\x20this\x20type.\x20Does\x20not\x20apply\x20to\n\x20`TEXT_DETECTI\
    ON`,\x20`DOCUMENT_TEXT_DETECTION`,\x20or\x20`CROP_HINTS`.\n\n\r\n\x05\
    \x04\0\x02\x01\x05\x12\x04\xc9\x01\x02\x07\n\r\n\x05\x04\0\x02\x01\x01\
    \x12\x04\xc9\x01\x08\x13\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xc9\x01\x16\
    \x17\n\x7f\n\x04\x04\0\x02\x02\x12\x04\xce\x01\x02\x13\x1aq\x20Model\x20\
    to\x20use\x20for\x20the\x20feature.\n\x20Supported\x20values:\x20\"built\
    in/stable\"\x20(the\x20default\x20if\x20unset)\x20and\n\x20\"builtin/lat\
    est\".\n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xce\x01\x02\x08\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\xce\x01\t\x0e\n\r\n\x05\x04\0\x02\x02\x03\x12\
    \x04\xce\x01\x11\x12\nW\n\x02\x04\x01\x12\x06\xd2\x01\0\xed\x01\x01\x1aI\
    \x20External\x20image\x20source\x20(Google\x20Cloud\x20Storage\x20or\x20\
    web\x20URL\x20image\x20location).\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xd2\
    \x01\x08\x13\n\x8d\x02\n\x04\x04\x01\x02\0\x12\x04\xd9\x01\x02\x1b\x1a\
    \xfe\x01\x20**Use\x20`image_uri`\x20instead.**\n\n\x20The\x20Google\x20C\
    loud\x20Storage\x20\x20URI\x20of\x20the\x20form\n\x20`gs://bucket_name/o\
    bject_name`.\x20Object\x20versioning\x20is\x20not\x20supported.\x20See\n\
    \x20[Google\x20Cloud\x20Storage\x20Request\n\x20URIs](https://cloud.goog\
    le.com/storage/docs/reference-uris)\x20for\x20more\x20info.\n\n\r\n\x05\
    \x04\x01\x02\0\x05\x12\x04\xd9\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xd9\x01\t\x16\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xd9\x01\x19\
    \x1a\n\xb3\x06\n\x04\x04\x01\x02\x01\x12\x04\xec\x01\x02\x17\x1a\xa4\x06\
    \x20The\x20URI\x20of\x20the\x20source\x20image.\x20Can\x20be\x20either:\
    \n\n\x201.\x20A\x20Google\x20Cloud\x20Storage\x20URI\x20of\x20the\x20for\
    m\n\x20\x20\x20\x20`gs://bucket_name/object_name`.\x20Object\x20versioni\
    ng\x20is\x20not\x20supported.\x20See\n\x20\x20\x20\x20[Google\x20Cloud\
    \x20Storage\x20Request\n\x20\x20\x20\x20URIs](https://cloud.google.com/s\
    torage/docs/reference-uris)\x20for\x20more\n\x20\x20\x20\x20info.\n\n\
    \x202.\x20A\x20publicly-accessible\x20image\x20HTTP/HTTPS\x20URL.\x20Whe\
    n\x20fetching\x20images\x20from\n\x20\x20\x20\x20HTTP/HTTPS\x20URLs,\x20\
    Google\x20cannot\x20guarantee\x20that\x20the\x20request\x20will\x20be\n\
    \x20\x20\x20\x20completed.\x20Your\x20request\x20may\x20fail\x20if\x20th\
    e\x20specified\x20host\x20denies\x20the\n\x20\x20\x20\x20request\x20(e.g\
    .\x20due\x20to\x20request\x20throttling\x20or\x20DOS\x20prevention),\x20\
    or\x20if\x20Google\n\x20\x20\x20\x20throttles\x20requests\x20to\x20the\
    \x20site\x20for\x20abuse\x20prevention.\x20You\x20should\x20not\n\x20\
    \x20\x20\x20depend\x20on\x20externally-hosted\x20images\x20for\x20produc\
    tion\x20applications.\n\n\x20When\x20both\x20`gcs_image_uri`\x20and\x20`\
    image_uri`\x20are\x20specified,\x20`image_uri`\x20takes\n\x20precedence.\
    \n\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xec\x01\x02\x08\n\r\n\x05\x04\
    \x01\x02\x01\x01\x12\x04\xec\x01\t\x12\n\r\n\x05\x04\x01\x02\x01\x03\x12\
    \x04\xec\x01\x15\x16\nK\n\x02\x04\x02\x12\x06\xf0\x01\0\xfa\x01\x01\x1a=\
    \x20Client\x20image\x20to\x20perform\x20Google\x20Cloud\x20Vision\x20API\
    \x20tasks\x20over.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xf0\x01\x08\r\n\xbd\
    \x01\n\x04\x04\x02\x02\0\x12\x04\xf4\x01\x02\x14\x1a\xae\x01\x20Image\
    \x20content,\x20represented\x20as\x20a\x20stream\x20of\x20bytes.\n\x20No\
    te:\x20As\x20with\x20all\x20`bytes`\x20fields,\x20protobuffers\x20use\
    \x20a\x20pure\x20binary\n\x20representation,\x20whereas\x20JSON\x20repre\
    sentations\x20use\x20base64.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xf4\
    \x01\x02\x07\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xf4\x01\x08\x0f\n\r\n\
    \x05\x04\x02\x02\0\x03\x12\x04\xf4\x01\x12\x13\n\xe3\x01\n\x04\x04\x02\
    \x02\x01\x12\x04\xf9\x01\x02\x19\x1a\xd4\x01\x20Google\x20Cloud\x20Stora\
    ge\x20image\x20location,\x20or\x20publicly-accessible\x20image\n\x20URL.\
    \x20If\x20both\x20`content`\x20and\x20`source`\x20are\x20provided\x20for\
    \x20an\x20image,\x20`content`\n\x20takes\x20precedence\x20and\x20is\x20u\
    sed\x20to\x20perform\x20the\x20image\x20annotation\x20request.\n\n\r\n\
    \x05\x04\x02\x02\x01\x06\x12\x04\xf9\x01\x02\r\n\r\n\x05\x04\x02\x02\x01\
    \x01\x12\x04\xf9\x01\x0e\x14\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xf9\
    \x01\x17\x18\n\x8a\x01\n\x02\x05\0\x12\x06\xfe\x01\0\x90\x02\x01\x1a|\
    \x20A\x20bucketized\x20representation\x20of\x20likelihood,\x20which\x20i\
    s\x20intended\x20to\x20give\x20clients\n\x20highly\x20stable\x20results\
    \x20across\x20model\x20upgrades.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xfe\x01\
    \x05\x0f\n#\n\x04\x05\0\x02\0\x12\x04\x80\x02\x02\x0e\x1a\x15\x20Unknown\
    \x20likelihood.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x80\x02\x02\t\n\r\n\
    \x05\x05\0\x02\0\x02\x12\x04\x80\x02\x0c\r\n$\n\x04\x05\0\x02\x01\x12\
    \x04\x83\x02\x02\x14\x1a\x16\x20It\x20is\x20very\x20unlikely.\n\n\r\n\
    \x05\x05\0\x02\x01\x01\x12\x04\x83\x02\x02\x0f\n\r\n\x05\x05\0\x02\x01\
    \x02\x12\x04\x83\x02\x12\x13\n\x1f\n\x04\x05\0\x02\x02\x12\x04\x86\x02\
    \x02\x0f\x1a\x11\x20It\x20is\x20unlikely.\n\n\r\n\x05\x05\0\x02\x02\x01\
    \x12\x04\x86\x02\x02\n\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\x86\x02\r\x0e\
    \n\x1f\n\x04\x05\0\x02\x03\x12\x04\x89\x02\x02\x0f\x1a\x11\x20It\x20is\
    \x20possible.\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\x89\x02\x02\n\n\r\n\
    \x05\x05\0\x02\x03\x02\x12\x04\x89\x02\r\x0e\n\x1d\n\x04\x05\0\x02\x04\
    \x12\x04\x8c\x02\x02\r\x1a\x0f\x20It\x20is\x20likely.\n\n\r\n\x05\x05\0\
    \x02\x04\x01\x12\x04\x8c\x02\x02\x08\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\
    \x8c\x02\x0b\x0c\n\"\n\x04\x05\0\x02\x05\x12\x04\x8f\x02\x02\x12\x1a\x14\
    \x20It\x20is\x20very\x20likely.\n\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\
    \x8f\x02\x02\r\n\r\n\x05\x05\0\x02\x05\x02\x12\x04\x8f\x02\x10\x11\nP\n\
    \x02\x04\x03\x12\x06\x93\x02\0\xc8\x03\x01\x1aB\x20A\x20face\x20annotati\
    on\x20object\x20contains\x20the\x20results\x20of\x20face\x20detection.\n\
    \n\x0b\n\x03\x04\x03\x01\x12\x04\x93\x02\x08\x16\nI\n\x04\x04\x03\x03\0\
    \x12\x06\x95\x02\x02\x8a\x03\x03\x1a9\x20A\x20face-specific\x20landmark\
    \x20(for\x20example,\x20a\x20face\x20feature).\n\n\r\n\x05\x04\x03\x03\0\
    \x01\x12\x04\x95\x02\n\x12\n\xec\x01\n\x06\x04\x03\x03\0\x04\0\x12\x06\
    \x9a\x02\x04\x83\x03\x05\x1a\xd9\x01\x20Face\x20landmark\x20(feature)\
    \x20type.\n\x20Left\x20and\x20right\x20are\x20defined\x20from\x20the\x20\
    vantage\x20of\x20the\x20viewer\x20of\x20the\x20image\n\x20without\x20con\
    sidering\x20mirror\x20projections\x20typical\x20of\x20photos.\x20So,\x20\
    `LEFT_EYE`,\n\x20typically,\x20is\x20the\x20person's\x20right\x20eye.\n\
    \n\x0f\n\x07\x04\x03\x03\0\x04\0\x01\x12\x04\x9a\x02\t\r\nI\n\x08\x04\
    \x03\x03\0\x04\0\x02\0\x12\x04\x9c\x02\x06\x1b\x1a7\x20Unknown\x20face\
    \x20landmark\x20detected.\x20Should\x20not\x20be\x20filled.\n\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\0\x01\x12\x04\x9c\x02\x06\x16\n\x11\n\t\x04\x03\
    \x03\0\x04\0\x02\0\x02\x12\x04\x9c\x02\x19\x1a\n\x1d\n\x08\x04\x03\x03\0\
    \x04\0\x02\x01\x12\x04\x9f\x02\x06\x13\x1a\x0b\x20Left\x20eye.\n\n\x11\n\
    \t\x04\x03\x03\0\x04\0\x02\x01\x01\x12\x04\x9f\x02\x06\x0e\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x01\x02\x12\x04\x9f\x02\x11\x12\n\x1e\n\x08\x04\x03\
    \x03\0\x04\0\x02\x02\x12\x04\xa2\x02\x06\x14\x1a\x0c\x20Right\x20eye.\n\
    \n\x11\n\t\x04\x03\x03\0\x04\0\x02\x02\x01\x12\x04\xa2\x02\x06\x0f\n\x11\
    \n\t\x04\x03\x03\0\x04\0\x02\x02\x02\x12\x04\xa2\x02\x12\x13\n)\n\x08\
    \x04\x03\x03\0\x04\0\x02\x03\x12\x04\xa5\x02\x06\x1f\x1a\x17\x20Left\x20\
    of\x20left\x20eyebrow.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x03\x01\x12\
    \x04\xa5\x02\x06\x1a\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x03\x02\x12\x04\
    \xa5\x02\x1d\x1e\n*\n\x08\x04\x03\x03\0\x04\0\x02\x04\x12\x04\xa8\x02\
    \x06\x20\x1a\x18\x20Right\x20of\x20left\x20eyebrow.\n\n\x11\n\t\x04\x03\
    \x03\0\x04\0\x02\x04\x01\x12\x04\xa8\x02\x06\x1b\n\x11\n\t\x04\x03\x03\0\
    \x04\0\x02\x04\x02\x12\x04\xa8\x02\x1e\x1f\n*\n\x08\x04\x03\x03\0\x04\0\
    \x02\x05\x12\x04\xab\x02\x06\x20\x1a\x18\x20Left\x20of\x20right\x20eyebr\
    ow.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x05\x01\x12\x04\xab\x02\x06\x1b\
    \n\x11\n\t\x04\x03\x03\0\x04\0\x02\x05\x02\x12\x04\xab\x02\x1e\x1f\n+\n\
    \x08\x04\x03\x03\0\x04\0\x02\x06\x12\x04\xae\x02\x06!\x1a\x19\x20Right\
    \x20of\x20right\x20eyebrow.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x06\x01\
    \x12\x04\xae\x02\x06\x1c\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x06\x02\x12\
    \x04\xae\x02\x1f\x20\n*\n\x08\x04\x03\x03\0\x04\0\x02\x07\x12\x04\xb1\
    \x02\x06\x20\x1a\x18\x20Midpoint\x20between\x20eyes.\n\n\x11\n\t\x04\x03\
    \x03\0\x04\0\x02\x07\x01\x12\x04\xb1\x02\x06\x1b\n\x11\n\t\x04\x03\x03\0\
    \x04\0\x02\x07\x02\x12\x04\xb1\x02\x1e\x1f\n\x1d\n\x08\x04\x03\x03\0\x04\
    \0\x02\x08\x12\x04\xb4\x02\x06\x13\x1a\x0b\x20Nose\x20tip.\n\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\x08\x01\x12\x04\xb4\x02\x06\x0e\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x08\x02\x12\x04\xb4\x02\x11\x12\n\x1e\n\x08\x04\x03\
    \x03\0\x04\0\x02\t\x12\x04\xb7\x02\x06\x14\x1a\x0c\x20Upper\x20lip.\n\n\
    \x11\n\t\x04\x03\x03\0\x04\0\x02\t\x01\x12\x04\xb7\x02\x06\x0f\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\t\x02\x12\x04\xb7\x02\x12\x13\n\x1e\n\x08\x04\
    \x03\x03\0\x04\0\x02\n\x12\x04\xba\x02\x06\x15\x1a\x0c\x20Lower\x20lip.\
    \n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\n\x01\x12\x04\xba\x02\x06\x0f\n\x11\
    \n\t\x04\x03\x03\0\x04\0\x02\n\x02\x12\x04\xba\x02\x12\x14\n\x1f\n\x08\
    \x04\x03\x03\0\x04\0\x02\x0b\x12\x04\xbd\x02\x06\x16\x1a\r\x20Mouth\x20l\
    eft.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x0b\x01\x12\x04\xbd\x02\x06\x10\
    \n\x11\n\t\x04\x03\x03\0\x04\0\x02\x0b\x02\x12\x04\xbd\x02\x13\x15\n\x20\
    \n\x08\x04\x03\x03\0\x04\0\x02\x0c\x12\x04\xc0\x02\x06\x17\x1a\x0e\x20Mo\
    uth\x20right.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x0c\x01\x12\x04\xc0\
    \x02\x06\x11\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x0c\x02\x12\x04\xc0\x02\
    \x14\x16\n!\n\x08\x04\x03\x03\0\x04\0\x02\r\x12\x04\xc3\x02\x06\x18\x1a\
    \x0f\x20Mouth\x20center.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\r\x01\x12\
    \x04\xc3\x02\x06\x12\n\x11\n\t\x04\x03\x03\0\x04\0\x02\r\x02\x12\x04\xc3\
    \x02\x15\x17\n'\n\x08\x04\x03\x03\0\x04\0\x02\x0e\x12\x04\xc6\x02\x06\
    \x1d\x1a\x15\x20Nose,\x20bottom\x20right.\n\n\x11\n\t\x04\x03\x03\0\x04\
    \0\x02\x0e\x01\x12\x04\xc6\x02\x06\x17\n\x11\n\t\x04\x03\x03\0\x04\0\x02\
    \x0e\x02\x12\x04\xc6\x02\x1a\x1c\n&\n\x08\x04\x03\x03\0\x04\0\x02\x0f\
    \x12\x04\xc9\x02\x06\x1c\x1a\x14\x20Nose,\x20bottom\x20left.\n\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\x0f\x01\x12\x04\xc9\x02\x06\x16\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x0f\x02\x12\x04\xc9\x02\x19\x1b\n(\n\x08\x04\x03\
    \x03\0\x04\0\x02\x10\x12\x04\xcc\x02\x06\x1e\x1a\x16\x20Nose,\x20bottom\
    \x20center.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x10\x01\x12\x04\xcc\x02\
    \x06\x18\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x10\x02\x12\x04\xcc\x02\x1b\
    \x1d\n+\n\x08\x04\x03\x03\0\x04\0\x02\x11\x12\x04\xcf\x02\x06!\x1a\x19\
    \x20Left\x20eye,\x20top\x20boundary.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\
    \x11\x01\x12\x04\xcf\x02\x06\x1b\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x11\
    \x02\x12\x04\xcf\x02\x1e\x20\n+\n\x08\x04\x03\x03\0\x04\0\x02\x12\x12\
    \x04\xd2\x02\x06!\x1a\x19\x20Left\x20eye,\x20right\x20corner.\n\n\x11\n\
    \t\x04\x03\x03\0\x04\0\x02\x12\x01\x12\x04\xd2\x02\x06\x1b\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x12\x02\x12\x04\xd2\x02\x1e\x20\n.\n\x08\x04\x03\
    \x03\0\x04\0\x02\x13\x12\x04\xd5\x02\x06$\x1a\x1c\x20Left\x20eye,\x20bot\
    tom\x20boundary.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x13\x01\x12\x04\xd5\
    \x02\x06\x1e\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x13\x02\x12\x04\xd5\x02!#\
    \n*\n\x08\x04\x03\x03\0\x04\0\x02\x14\x12\x04\xd8\x02\x06\x20\x1a\x18\
    \x20Left\x20eye,\x20left\x20corner.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\
    \x14\x01\x12\x04\xd8\x02\x06\x1a\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x14\
    \x02\x12\x04\xd8\x02\x1d\x1f\n,\n\x08\x04\x03\x03\0\x04\0\x02\x15\x12\
    \x04\xdb\x02\x06\"\x1a\x1a\x20Right\x20eye,\x20top\x20boundary.\n\n\x11\
    \n\t\x04\x03\x03\0\x04\0\x02\x15\x01\x12\x04\xdb\x02\x06\x1c\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\x15\x02\x12\x04\xdb\x02\x1f!\n,\n\x08\x04\x03\
    \x03\0\x04\0\x02\x16\x12\x04\xde\x02\x06\"\x1a\x1a\x20Right\x20eye,\x20r\
    ight\x20corner.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x16\x01\x12\x04\xde\
    \x02\x06\x1c\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x16\x02\x12\x04\xde\x02\
    \x1f!\n/\n\x08\x04\x03\x03\0\x04\0\x02\x17\x12\x04\xe1\x02\x06%\x1a\x1d\
    \x20Right\x20eye,\x20bottom\x20boundary.\n\n\x11\n\t\x04\x03\x03\0\x04\0\
    \x02\x17\x01\x12\x04\xe1\x02\x06\x1f\n\x11\n\t\x04\x03\x03\0\x04\0\x02\
    \x17\x02\x12\x04\xe1\x02\"$\n+\n\x08\x04\x03\x03\0\x04\0\x02\x18\x12\x04\
    \xe4\x02\x06!\x1a\x19\x20Right\x20eye,\x20left\x20corner.\n\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\x18\x01\x12\x04\xe4\x02\x06\x1b\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x18\x02\x12\x04\xe4\x02\x1e\x20\n1\n\x08\x04\x03\
    \x03\0\x04\0\x02\x19\x12\x04\xe7\x02\x06'\x1a\x1f\x20Left\x20eyebrow,\
    \x20upper\x20midpoint.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x19\x01\x12\
    \x04\xe7\x02\x06!\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x19\x02\x12\x04\xe7\
    \x02$&\n2\n\x08\x04\x03\x03\0\x04\0\x02\x1a\x12\x04\xea\x02\x06(\x1a\x20\
    \x20Right\x20eyebrow,\x20upper\x20midpoint.\n\n\x11\n\t\x04\x03\x03\0\
    \x04\0\x02\x1a\x01\x12\x04\xea\x02\x06\"\n\x11\n\t\x04\x03\x03\0\x04\0\
    \x02\x1a\x02\x12\x04\xea\x02%'\n%\n\x08\x04\x03\x03\0\x04\0\x02\x1b\x12\
    \x04\xed\x02\x06\x1c\x1a\x13\x20Left\x20ear\x20tragion.\n\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x1b\x01\x12\x04\xed\x02\x06\x16\n\x11\n\t\x04\x03\
    \x03\0\x04\0\x02\x1b\x02\x12\x04\xed\x02\x19\x1b\n&\n\x08\x04\x03\x03\0\
    \x04\0\x02\x1c\x12\x04\xf0\x02\x06\x1d\x1a\x14\x20Right\x20ear\x20tragio\
    n.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x1c\x01\x12\x04\xf0\x02\x06\x17\n\
    \x11\n\t\x04\x03\x03\0\x04\0\x02\x1c\x02\x12\x04\xf0\x02\x1a\x1c\n#\n\
    \x08\x04\x03\x03\0\x04\0\x02\x1d\x12\x04\xf3\x02\x06\x1a\x1a\x11\x20Left\
    \x20eye\x20pupil.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x1d\x01\x12\x04\
    \xf3\x02\x06\x14\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x1d\x02\x12\x04\xf3\
    \x02\x17\x19\n$\n\x08\x04\x03\x03\0\x04\0\x02\x1e\x12\x04\xf6\x02\x06\
    \x1b\x1a\x12\x20Right\x20eye\x20pupil.\n\n\x11\n\t\x04\x03\x03\0\x04\0\
    \x02\x1e\x01\x12\x04\xf6\x02\x06\x15\n\x11\n\t\x04\x03\x03\0\x04\0\x02\
    \x1e\x02\x12\x04\xf6\x02\x18\x1a\n&\n\x08\x04\x03\x03\0\x04\0\x02\x1f\
    \x12\x04\xf9\x02\x06\x1d\x1a\x14\x20Forehead\x20glabella.\n\n\x11\n\t\
    \x04\x03\x03\0\x04\0\x02\x1f\x01\x12\x04\xf9\x02\x06\x17\n\x11\n\t\x04\
    \x03\x03\0\x04\0\x02\x1f\x02\x12\x04\xf9\x02\x1a\x1c\n\"\n\x08\x04\x03\
    \x03\0\x04\0\x02\x20\x12\x04\xfc\x02\x06\x19\x1a\x10\x20Chin\x20gnathion\
    .\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\x20\x01\x12\x04\xfc\x02\x06\x13\n\
    \x11\n\t\x04\x03\x03\0\x04\0\x02\x20\x02\x12\x04\xfc\x02\x16\x18\n%\n\
    \x08\x04\x03\x03\0\x04\0\x02!\x12\x04\xff\x02\x06\x1c\x1a\x13\x20Chin\
    \x20left\x20gonion.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02!\x01\x12\x04\xff\
    \x02\x06\x16\n\x11\n\t\x04\x03\x03\0\x04\0\x02!\x02\x12\x04\xff\x02\x19\
    \x1b\n&\n\x08\x04\x03\x03\0\x04\0\x02\"\x12\x04\x82\x03\x06\x1d\x1a\x14\
    \x20Chin\x20right\x20gonion.\n\n\x11\n\t\x04\x03\x03\0\x04\0\x02\"\x01\
    \x12\x04\x82\x03\x06\x17\n\x11\n\t\x04\x03\x03\0\x04\0\x02\"\x02\x12\x04\
    \x82\x03\x1a\x1c\n%\n\x06\x04\x03\x03\0\x02\0\x12\x04\x86\x03\x04\x12\
    \x1a\x15\x20Face\x20landmark\x20type.\n\n\x0f\n\x07\x04\x03\x03\0\x02\0\
    \x06\x12\x04\x86\x03\x04\x08\n\x0f\n\x07\x04\x03\x03\0\x02\0\x01\x12\x04\
    \x86\x03\t\r\n\x0f\n\x07\x04\x03\x03\0\x02\0\x03\x12\x04\x86\x03\x10\x11\
    \n)\n\x06\x04\x03\x03\0\x02\x01\x12\x04\x89\x03\x04\x1a\x1a\x19\x20Face\
    \x20landmark\x20position.\n\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x06\x12\
    \x04\x89\x03\x04\x0c\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x04\x89\
    \x03\r\x15\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x04\x89\x03\x18\x19\
    \n\xb7\x03\n\x04\x04\x03\x02\0\x12\x04\x93\x03\x02!\x1a\xa8\x03\x20The\
    \x20bounding\x20polygon\x20around\x20the\x20face.\x20The\x20coordinates\
    \x20of\x20the\x20bounding\x20box\n\x20are\x20in\x20the\x20original\x20im\
    age's\x20scale.\n\x20The\x20bounding\x20box\x20is\x20computed\x20to\x20\
    \"frame\"\x20the\x20face\x20in\x20accordance\x20with\x20human\n\x20expec\
    tations.\x20It\x20is\x20based\x20on\x20the\x20landmarker\x20results.\n\
    \x20Note\x20that\x20one\x20or\x20more\x20x\x20and/or\x20y\x20coordinates\
    \x20may\x20not\x20be\x20generated\x20in\x20the\n\x20`BoundingPoly`\x20(t\
    he\x20polygon\x20will\x20be\x20unbounded)\x20if\x20only\x20a\x20partial\
    \x20face\n\x20appears\x20in\x20the\x20image\x20to\x20be\x20annotated.\n\
    \n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x93\x03\x02\x0e\n\r\n\x05\x04\x03\
    \x02\0\x01\x12\x04\x93\x03\x0f\x1c\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\
    \x93\x03\x1f\x20\n\x8b\x03\n\x04\x04\x03\x02\x01\x12\x04\x9b\x03\x02$\
    \x1a\xfc\x02\x20The\x20`fd_bounding_poly`\x20bounding\x20polygon\x20is\
    \x20tighter\x20than\x20the\n\x20`boundingPoly`,\x20and\x20encloses\x20on\
    ly\x20the\x20skin\x20part\x20of\x20the\x20face.\x20Typically,\x20it\n\
    \x20is\x20used\x20to\x20eliminate\x20the\x20face\x20from\x20any\x20image\
    \x20analysis\x20that\x20detects\x20the\n\x20\"amount\x20of\x20skin\"\x20\
    visible\x20in\x20an\x20image.\x20It\x20is\x20not\x20based\x20on\x20the\n\
    \x20landmarker\x20results,\x20only\x20on\x20the\x20initial\x20face\x20de\
    tection,\x20hence\n\x20the\x20<code>fd</code>\x20(face\x20detection)\x20\
    prefix.\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x9b\x03\x02\x0e\n\r\n\
    \x05\x04\x03\x02\x01\x01\x12\x04\x9b\x03\x0f\x1f\n\r\n\x05\x04\x03\x02\
    \x01\x03\x12\x04\x9b\x03\"#\n(\n\x04\x04\x03\x02\x02\x12\x04\x9e\x03\x02\
    \"\x1a\x1a\x20Detected\x20face\x20landmarks.\n\n\r\n\x05\x04\x03\x02\x02\
    \x04\x12\x04\x9e\x03\x02\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\x9e\x03\
    \x0b\x13\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x9e\x03\x14\x1d\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\x9e\x03\x20!\n\xc5\x01\n\x04\x04\x03\x02\
    \x03\x12\x04\xa3\x03\x02\x17\x1a\xb6\x01\x20Roll\x20angle,\x20which\x20i\
    ndicates\x20the\x20amount\x20of\x20clockwise/anti-clockwise\x20rotation\
    \n\x20of\x20the\x20face\x20relative\x20to\x20the\x20image\x20vertical\
    \x20about\x20the\x20axis\x20perpendicular\x20to\n\x20the\x20face.\x20Ran\
    ge\x20[-180,180].\n\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\xa3\x03\x02\
    \x07\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xa3\x03\x08\x12\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\xa3\x03\x15\x16\n\xb1\x01\n\x04\x04\x03\x02\x04\
    \x12\x04\xa8\x03\x02\x16\x1a\xa2\x01\x20Yaw\x20angle,\x20which\x20indica\
    tes\x20the\x20leftward/rightward\x20angle\x20that\x20the\x20face\x20is\n\
    \x20pointing\x20relative\x20to\x20the\x20vertical\x20plane\x20perpendicu\
    lar\x20to\x20the\x20image.\x20Range\n\x20[-180,180].\n\n\r\n\x05\x04\x03\
    \x02\x04\x05\x12\x04\xa8\x03\x02\x07\n\r\n\x05\x04\x03\x02\x04\x01\x12\
    \x04\xa8\x03\x08\x11\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xa8\x03\x14\
    \x15\n\xa0\x01\n\x04\x04\x03\x02\x05\x12\x04\xac\x03\x02\x17\x1a\x91\x01\
    \x20Pitch\x20angle,\x20which\x20indicates\x20the\x20upwards/downwards\
    \x20angle\x20that\x20the\x20face\x20is\n\x20pointing\x20relative\x20to\
    \x20the\x20image's\x20horizontal\x20plane.\x20Range\x20[-180,180].\n\n\r\
    \n\x05\x04\x03\x02\x05\x05\x12\x04\xac\x03\x02\x07\n\r\n\x05\x04\x03\x02\
    \x05\x01\x12\x04\xac\x03\x08\x12\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\
    \xac\x03\x15\x16\n3\n\x04\x04\x03\x02\x06\x12\x04\xaf\x03\x02!\x1a%\x20D\
    etection\x20confidence.\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x03\x02\
    \x06\x05\x12\x04\xaf\x03\x02\x07\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\
    \xaf\x03\x08\x1c\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xaf\x03\x1f\x20\n\
    :\n\x04\x04\x03\x02\x07\x12\x04\xb2\x03\x02#\x1a,\x20Face\x20landmarking\
    \x20confidence.\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x03\x02\x07\x05\
    \x12\x04\xb2\x03\x02\x07\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\xb2\x03\
    \x08\x1e\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\xb2\x03!\"\n\x1f\n\x04\
    \x04\x03\x02\x08\x12\x04\xb5\x03\x02\x20\x1a\x11\x20Joy\x20likelihood.\n\
    \n\r\n\x05\x04\x03\x02\x08\x06\x12\x04\xb5\x03\x02\x0c\n\r\n\x05\x04\x03\
    \x02\x08\x01\x12\x04\xb5\x03\r\x1b\n\r\n\x05\x04\x03\x02\x08\x03\x12\x04\
    \xb5\x03\x1e\x1f\n\"\n\x04\x04\x03\x02\t\x12\x04\xb8\x03\x02$\x1a\x14\
    \x20Sorrow\x20likelihood.\n\n\r\n\x05\x04\x03\x02\t\x06\x12\x04\xb8\x03\
    \x02\x0c\n\r\n\x05\x04\x03\x02\t\x01\x12\x04\xb8\x03\r\x1e\n\r\n\x05\x04\
    \x03\x02\t\x03\x12\x04\xb8\x03!#\n!\n\x04\x04\x03\x02\n\x12\x04\xbb\x03\
    \x02#\x1a\x13\x20Anger\x20likelihood.\n\n\r\n\x05\x04\x03\x02\n\x06\x12\
    \x04\xbb\x03\x02\x0c\n\r\n\x05\x04\x03\x02\n\x01\x12\x04\xbb\x03\r\x1d\n\
    \r\n\x05\x04\x03\x02\n\x03\x12\x04\xbb\x03\x20\"\n$\n\x04\x04\x03\x02\
    \x0b\x12\x04\xbe\x03\x02&\x1a\x16\x20Surprise\x20likelihood.\n\n\r\n\x05\
    \x04\x03\x02\x0b\x06\x12\x04\xbe\x03\x02\x0c\n\r\n\x05\x04\x03\x02\x0b\
    \x01\x12\x04\xbe\x03\r\x20\n\r\n\x05\x04\x03\x02\x0b\x03\x12\x04\xbe\x03\
    #%\n)\n\x04\x04\x03\x02\x0c\x12\x04\xc1\x03\x02+\x1a\x1b\x20Under-expose\
    d\x20likelihood.\n\n\r\n\x05\x04\x03\x02\x0c\x06\x12\x04\xc1\x03\x02\x0c\
    \n\r\n\x05\x04\x03\x02\x0c\x01\x12\x04\xc1\x03\r%\n\r\n\x05\x04\x03\x02\
    \x0c\x03\x12\x04\xc1\x03(*\n#\n\x04\x04\x03\x02\r\x12\x04\xc4\x03\x02%\
    \x1a\x15\x20Blurred\x20likelihood.\n\n\r\n\x05\x04\x03\x02\r\x06\x12\x04\
    \xc4\x03\x02\x0c\n\r\n\x05\x04\x03\x02\r\x01\x12\x04\xc4\x03\r\x1f\n\r\n\
    \x05\x04\x03\x02\r\x03\x12\x04\xc4\x03\"$\n$\n\x04\x04\x03\x02\x0e\x12\
    \x04\xc7\x03\x02&\x1a\x16\x20Headwear\x20likelihood.\n\n\r\n\x05\x04\x03\
    \x02\x0e\x06\x12\x04\xc7\x03\x02\x0c\n\r\n\x05\x04\x03\x02\x0e\x01\x12\
    \x04\xc7\x03\r\x20\n\r\n\x05\x04\x03\x02\x0e\x03\x12\x04\xc7\x03#%\n5\n\
    \x02\x04\x04\x12\x06\xcb\x03\0\xce\x03\x01\x1a'\x20Detected\x20entity\
    \x20location\x20information.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xcb\x03\
    \x08\x14\n.\n\x04\x04\x04\x02\0\x12\x04\xcd\x03\x02!\x1a\x20\x20lat/long\
    \x20location\x20coordinates.\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xcd\
    \x03\x02\x14\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xcd\x03\x15\x1c\n\r\n\
    \x05\x04\x04\x02\0\x03\x12\x04\xcd\x03\x1f\x20\nI\n\x02\x04\x05\x12\x06\
    \xd1\x03\0\xda\x03\x01\x1a;\x20A\x20`Property`\x20consists\x20of\x20a\
    \x20user-supplied\x20name/value\x20pair.\n\n\x0b\n\x03\x04\x05\x01\x12\
    \x04\xd1\x03\x08\x10\n%\n\x04\x04\x05\x02\0\x12\x04\xd3\x03\x02\x12\x1a\
    \x17\x20Name\x20of\x20the\x20property.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\
    \x04\xd3\x03\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xd3\x03\t\r\n\r\
    \n\x05\x04\x05\x02\0\x03\x12\x04\xd3\x03\x10\x11\n&\n\x04\x04\x05\x02\
    \x01\x12\x04\xd6\x03\x02\x13\x1a\x18\x20Value\x20of\x20the\x20property.\
    \n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xd6\x03\x02\x08\n\r\n\x05\x04\
    \x05\x02\x01\x01\x12\x04\xd6\x03\t\x0e\n\r\n\x05\x04\x05\x02\x01\x03\x12\
    \x04\xd6\x03\x11\x12\n,\n\x04\x04\x05\x02\x02\x12\x04\xd9\x03\x02\x1a\
    \x1a\x1e\x20Value\x20of\x20numeric\x20properties.\n\n\r\n\x05\x04\x05\
    \x02\x02\x05\x12\x04\xd9\x03\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\
    \x04\xd9\x03\t\x15\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xd9\x03\x18\x19\
    \n0\n\x02\x04\x06\x12\x06\xdd\x03\0\x89\x04\x01\x1a\"\x20Set\x20of\x20de\
    tected\x20entity\x20features.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xdd\x03\
    \x08\x18\n\x96\x01\n\x04\x04\x06\x02\0\x12\x04\xe1\x03\x02\x11\x1a\x87\
    \x01\x20Opaque\x20entity\x20ID.\x20Some\x20IDs\x20may\x20be\x20available\
    \x20in\n\x20[Google\x20Knowledge\x20Graph\x20Search\n\x20API](https://de\
    velopers.google.com/knowledge-graph/).\n\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\xe1\x03\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xe1\x03\t\x0c\n\
    \r\n\x05\x04\x06\x02\0\x03\x12\x04\xe1\x03\x0f\x10\ni\n\x04\x04\x06\x02\
    \x01\x12\x04\xe5\x03\x02\x14\x1a[\x20The\x20language\x20code\x20for\x20t\
    he\x20locale\x20in\x20which\x20the\x20entity\x20textual\n\x20`descriptio\
    n`\x20is\x20expressed.\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xe5\x03\
    \x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xe5\x03\t\x0f\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xe5\x03\x12\x13\nO\n\x04\x04\x06\x02\x02\
    \x12\x04\xe8\x03\x02\x19\x1aA\x20Entity\x20textual\x20description,\x20ex\
    pressed\x20in\x20its\x20`locale`\x20language.\n\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\xe8\x03\x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \xe8\x03\t\x14\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xe8\x03\x17\x18\n:\
    \n\x04\x04\x06\x02\x03\x12\x04\xeb\x03\x02\x12\x1a,\x20Overall\x20score\
    \x20of\x20the\x20result.\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x06\x02\
    \x03\x05\x12\x04\xeb\x03\x02\x07\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\
    \xeb\x03\x08\r\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xeb\x03\x10\x11\n\
    \x92\x02\n\x04\x04\x06\x02\x04\x12\x04\xf2\x03\x02+\x1a\x83\x02\x20**Dep\
    recated.\x20Use\x20`score`\x20instead.**\n\x20The\x20accuracy\x20of\x20t\
    he\x20entity\x20detection\x20in\x20an\x20image.\n\x20For\x20example,\x20\
    for\x20an\x20image\x20in\x20which\x20the\x20\"Eiffel\x20Tower\"\x20entit\
    y\x20is\x20detected,\n\x20this\x20field\x20represents\x20the\x20confiden\
    ce\x20that\x20there\x20is\x20a\x20tower\x20in\x20the\x20query\n\x20image\
    .\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xf2\x03\
    \x02\x07\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xf2\x03\x08\x12\n\r\n\x05\
    \x04\x06\x02\x04\x03\x12\x04\xf2\x03\x15\x16\n\r\n\x05\x04\x06\x02\x04\
    \x08\x12\x04\xf2\x03\x17*\n\x0e\n\x06\x04\x06\x02\x04\x08\x03\x12\x04\
    \xf2\x03\x18)\n\xe6\x02\n\x04\x04\x06\x02\x05\x12\x04\xf9\x03\x02\x17\
    \x1a\xd7\x02\x20The\x20relevancy\x20of\x20the\x20ICA\x20(Image\x20Conten\
    t\x20Annotation)\x20label\x20to\x20the\n\x20image.\x20For\x20example,\
    \x20the\x20relevancy\x20of\x20\"tower\"\x20is\x20likely\x20higher\x20to\
    \x20an\x20image\n\x20containing\x20the\x20detected\x20\"Eiffel\x20Tower\
    \"\x20than\x20to\x20an\x20image\x20containing\x20a\n\x20detected\x20dist\
    ant\x20towering\x20building,\x20even\x20though\x20the\x20confidence\x20t\
    hat\n\x20there\x20is\x20a\x20tower\x20in\x20each\x20image\x20may\x20be\
    \x20the\x20same.\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x06\x02\x05\x05\
    \x12\x04\xf9\x03\x02\x07\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xf9\x03\
    \x08\x12\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xf9\x03\x15\x16\nh\n\x04\
    \x04\x06\x02\x06\x12\x04\xfd\x03\x02!\x1aZ\x20Image\x20region\x20to\x20w\
    hich\x20this\x20entity\x20belongs.\x20Not\x20produced\n\x20for\x20`LABEL\
    _DETECTION`\x20features.\n\n\r\n\x05\x04\x06\x02\x06\x06\x12\x04\xfd\x03\
    \x02\x0e\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\xfd\x03\x0f\x1c\n\r\n\x05\
    \x04\x06\x02\x06\x03\x12\x04\xfd\x03\x1f\x20\n\xce\x02\n\x04\x04\x06\x02\
    \x07\x12\x04\x84\x04\x02&\x1a\xbf\x02\x20The\x20location\x20information\
    \x20for\x20the\x20detected\x20entity.\x20Multiple\n\x20`LocationInfo`\
    \x20elements\x20can\x20be\x20present\x20because\x20one\x20location\x20ma\
    y\n\x20indicate\x20the\x20location\x20of\x20the\x20scene\x20in\x20the\
    \x20image,\x20and\x20another\x20location\n\x20may\x20indicate\x20the\x20\
    location\x20of\x20the\x20place\x20where\x20the\x20image\x20was\x20taken.\
    \n\x20Location\x20information\x20is\x20usually\x20present\x20for\x20land\
    marks.\n\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\x84\x04\x02\n\n\r\n\x05\
    \x04\x06\x02\x07\x06\x12\x04\x84\x04\x0b\x17\n\r\n\x05\x04\x06\x02\x07\
    \x01\x12\x04\x84\x04\x18!\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\x84\x04$\
    %\n\x91\x01\n\x04\x04\x06\x02\x08\x12\x04\x88\x04\x02#\x1a\x82\x01\x20So\
    me\x20entities\x20may\x20have\x20optional\x20user-supplied\x20`Property`\
    \x20(name/value)\n\x20fields,\x20such\x20a\x20score\x20or\x20string\x20t\
    hat\x20qualifies\x20the\x20entity.\n\n\r\n\x05\x04\x06\x02\x08\x04\x12\
    \x04\x88\x04\x02\n\n\r\n\x05\x04\x06\x02\x08\x06\x12\x04\x88\x04\x0b\x13\
    \n\r\n\x05\x04\x06\x02\x08\x01\x12\x04\x88\x04\x14\x1e\n\r\n\x05\x04\x06\
    \x02\x08\x03\x12\x04\x88\x04!\"\n<\n\x02\x04\x07\x12\x06\x8c\x04\0\x9d\
    \x04\x01\x1a.\x20Set\x20of\x20detected\x20objects\x20with\x20bounding\
    \x20boxes.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x8c\x04\x08!\nF\n\x04\x04\
    \x07\x02\0\x12\x04\x8e\x04\x02\x11\x1a8\x20Object\x20ID\x20that\x20shoul\
    d\x20align\x20with\x20EntityAnnotation\x20mid.\n\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\x8e\x04\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x8e\x04\
    \t\x0c\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x8e\x04\x0f\x10\n\xa4\x01\n\
    \x04\x04\x07\x02\x01\x12\x04\x93\x04\x02\x1b\x1a\x95\x01\x20The\x20BCP-4\
    7\x20language\x20code,\x20such\x20as\x20\"en-US\"\x20or\x20\"sr-Latn\".\
    \x20For\x20more\n\x20information,\x20see\n\x20http://www.unicode.org/rep\
    orts/tr35/#Unicode_locale_identifier.\n\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\x93\x04\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x93\x04\t\
    \x16\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x93\x04\x19\x1a\nG\n\x04\x04\
    \x07\x02\x02\x12\x04\x96\x04\x02\x12\x1a9\x20Object\x20name,\x20expresse\
    d\x20in\x20its\x20`language_code`\x20language.\n\n\r\n\x05\x04\x07\x02\
    \x02\x05\x12\x04\x96\x04\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\
    \x96\x04\t\r\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x96\x04\x10\x11\n2\n\
    \x04\x04\x07\x02\x03\x12\x04\x99\x04\x02\x12\x1a$\x20Score\x20of\x20the\
    \x20result.\x20Range\x20[0,\x201].\n\n\r\n\x05\x04\x07\x02\x03\x05\x12\
    \x04\x99\x04\x02\x07\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\x99\x04\x08\r\
    \n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\x99\x04\x10\x11\nR\n\x04\x04\x07\
    \x02\x04\x12\x04\x9c\x04\x02!\x1aD\x20Image\x20region\x20to\x20which\x20\
    this\x20object\x20belongs.\x20This\x20must\x20be\x20populated.\n\n\r\n\
    \x05\x04\x07\x02\x04\x06\x12\x04\x9c\x04\x02\x0e\n\r\n\x05\x04\x07\x02\
    \x04\x01\x12\x04\x9c\x04\x0f\x1c\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\
    \x9c\x04\x1f\x20\n\xaa\x01\n\x02\x04\x08\x12\x06\xa2\x04\0\xd0\x04\x01\
    \x1a\x9b\x01\x20Set\x20of\x20features\x20pertaining\x20to\x20the\x20imag\
    e,\x20computed\x20by\x20computer\x20vision\n\x20methods\x20over\x20safe-\
    search\x20verticals\x20(for\x20example,\x20adult,\x20spoof,\x20medical,\
    \n\x20violence).\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xa2\x04\x08\x1c\n\xb3\
    \x01\n\x04\x04\x08\x02\0\x12\x04\xa6\x04\x02\x17\x1a\xa4\x01\x20Represen\
    ts\x20the\x20adult\x20content\x20likelihood\x20for\x20the\x20image.\x20A\
    dult\x20content\x20may\n\x20contain\x20elements\x20such\x20as\x20nudity,\
    \x20pornographic\x20images\x20or\x20cartoons,\x20or\n\x20sexual\x20activ\
    ities.\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xa6\x04\x02\x0c\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\xa6\x04\r\x12\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xa6\x04\x15\x16\n\x98\x01\n\x04\x04\x08\x02\x01\x12\x04\xab\x04\x02\
    \x17\x1a\x89\x01\x20Spoof\x20likelihood.\x20The\x20likelihood\x20that\
    \x20an\x20modification\n\x20was\x20made\x20to\x20the\x20image's\x20canon\
    ical\x20version\x20to\x20make\x20it\x20appear\n\x20funny\x20or\x20offens\
    ive.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xab\x04\x02\x0c\n\r\n\x05\
    \x04\x08\x02\x01\x01\x12\x04\xab\x04\r\x12\n\r\n\x05\x04\x08\x02\x01\x03\
    \x12\x04\xab\x04\x15\x16\n8\n\x04\x04\x08\x02\x02\x12\x04\xae\x04\x02\
    \x19\x1a*\x20Likelihood\x20that\x20this\x20is\x20a\x20medical\x20image.\
    \n\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xae\x04\x02\x0c\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\xae\x04\r\x14\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xae\x04\x17\x18\nD\n\x04\x04\x08\x02\x03\x12\x04\xb1\x04\x02\x1a\
    \x1a6\x20Likelihood\x20that\x20this\x20image\x20contains\x20violent\x20c\
    ontent.\n\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\xb1\x04\x02\x0c\n\r\n\
    \x05\x04\x08\x02\x03\x01\x12\x04\xb1\x04\r\x15\n\r\n\x05\x04\x08\x02\x03\
    \x03\x12\x04\xb1\x04\x18\x19\n\xf6\x01\n\x04\x04\x08\x02\x04\x12\x04\xb7\
    \x04\x02\x16\x1a\xe7\x01\x20Likelihood\x20that\x20the\x20request\x20imag\
    e\x20contains\x20racy\x20content.\x20Racy\x20content\x20may\n\x20include\
    \x20(but\x20is\x20not\x20limited\x20to)\x20skimpy\x20or\x20sheer\x20clot\
    hing,\x20strategically\n\x20covered\x20nudity,\x20lewd\x20or\x20provocat\
    ive\x20poses,\x20or\x20close-ups\x20of\x20sensitive\n\x20body\x20areas.\
    \n\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xb7\x04\x02\x0c\n\r\n\x05\x04\
    \x08\x02\x04\x01\x12\x04\xb7\x04\r\x11\n\r\n\x05\x04\x08\x02\x04\x03\x12\
    \x04\xb7\x04\x14\x15\nh\n\x04\x04\x08\x02\x05\x12\x04\xbb\x04\x02\x1e\
    \x1aZ\x20Confidence\x20of\x20adult_score.\x20Range\x20[0,\x201].\x200\
    \x20means\x20not\x20confident,\x201\x20means\n\x20very\x20confident.\n\n\
    \r\n\x05\x04\x08\x02\x05\x05\x12\x04\xbb\x04\x02\x07\n\r\n\x05\x04\x08\
    \x02\x05\x01\x12\x04\xbb\x04\x08\x18\n\r\n\x05\x04\x08\x02\x05\x03\x12\
    \x04\xbb\x04\x1b\x1d\nh\n\x04\x04\x08\x02\x06\x12\x04\xbf\x04\x02\x1e\
    \x1aZ\x20Confidence\x20of\x20spoof_score.\x20Range\x20[0,\x201].\x200\
    \x20means\x20not\x20confident,\x201\x20means\n\x20very\x20confident.\n\n\
    \r\n\x05\x04\x08\x02\x06\x05\x12\x04\xbf\x04\x02\x07\n\r\n\x05\x04\x08\
    \x02\x06\x01\x12\x04\xbf\x04\x08\x18\n\r\n\x05\x04\x08\x02\x06\x03\x12\
    \x04\xbf\x04\x1b\x1d\nj\n\x04\x04\x08\x02\x07\x12\x04\xc3\x04\x02\x20\
    \x1a\\\x20Confidence\x20of\x20medical_score.\x20Range\x20[0,\x201].\x200\
    \x20means\x20not\x20confident,\x201\x20means\n\x20very\x20confident.\n\n\
    \r\n\x05\x04\x08\x02\x07\x05\x12\x04\xc3\x04\x02\x07\n\r\n\x05\x04\x08\
    \x02\x07\x01\x12\x04\xc3\x04\x08\x1a\n\r\n\x05\x04\x08\x02\x07\x03\x12\
    \x04\xc3\x04\x1d\x1f\nk\n\x04\x04\x08\x02\x08\x12\x04\xc7\x04\x02!\x1a]\
    \x20Confidence\x20of\x20violence_score.\x20Range\x20[0,\x201].\x200\x20m\
    eans\x20not\x20confident,\x201\x20means\n\x20very\x20confident.\n\n\r\n\
    \x05\x04\x08\x02\x08\x05\x12\x04\xc7\x04\x02\x07\n\r\n\x05\x04\x08\x02\
    \x08\x01\x12\x04\xc7\x04\x08\x1b\n\r\n\x05\x04\x08\x02\x08\x03\x12\x04\
    \xc7\x04\x1e\x20\ng\n\x04\x04\x08\x02\t\x12\x04\xcb\x04\x02\x1d\x1aY\x20\
    Confidence\x20of\x20racy_score.\x20Range\x20[0,\x201].\x200\x20means\x20\
    not\x20confident,\x201\x20means\x20very\n\x20confident.\n\n\r\n\x05\x04\
    \x08\x02\t\x05\x12\x04\xcb\x04\x02\x07\n\r\n\x05\x04\x08\x02\t\x01\x12\
    \x04\xcb\x04\x08\x17\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\xcb\x04\x1a\x1c\
    \ng\n\x04\x04\x08\x02\n\x12\x04\xcf\x04\x02\x1d\x1aY\x20Confidence\x20of\
    \x20nsfw_score.\x20Range\x20[0,\x201].\x200\x20means\x20not\x20confident\
    ,\x201\x20means\x20very\n\x20confident.\n\n\r\n\x05\x04\x08\x02\n\x05\
    \x12\x04\xcf\x04\x02\x07\n\r\n\x05\x04\x08\x02\n\x01\x12\x04\xcf\x04\x08\
    \x17\n\r\n\x05\x04\x08\x02\n\x03\x12\x04\xcf\x04\x1a\x1c\nC\n\x02\x04\t\
    \x12\x06\xd3\x04\0\xd9\x04\x01\x1a5\x20Rectangle\x20determined\x20by\x20\
    min\x20and\x20max\x20`LatLng`\x20pairs.\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xd3\x04\x08\x13\n\"\n\x04\x04\t\x02\0\x12\x04\xd5\x04\x02%\x1a\x14\x20M\
    in\x20lat/long\x20pair.\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xd5\x04\x02\
    \x14\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd5\x04\x15\x20\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\xd5\x04#$\n\"\n\x04\x04\t\x02\x01\x12\x04\xd8\x04\x02\
    %\x1a\x14\x20Max\x20lat/long\x20pair.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\xd8\x04\x02\x14\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xd8\x04\x15\x20\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xd8\x04#$\n\x87\x01\n\x02\x04\n\x12\
    \x06\xdd\x04\0\xe7\x04\x01\x1ay\x20Color\x20information\x20consists\x20o\
    f\x20RGB\x20channels,\x20score,\x20and\x20the\x20fraction\x20of\n\x20the\
    \x20image\x20that\x20the\x20color\x20occupies\x20in\x20the\x20image.\n\n\
    \x0b\n\x03\x04\n\x01\x12\x04\xdd\x04\x08\x11\n,\n\x04\x04\n\x02\0\x12\
    \x04\xdf\x04\x02\x1e\x1a\x1e\x20RGB\x20components\x20of\x20the\x20color.\
    \n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xdf\x04\x02\x13\n\r\n\x05\x04\n\x02\
    \0\x01\x12\x04\xdf\x04\x14\x19\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xdf\x04\
    \x1c\x1d\nK\n\x04\x04\n\x02\x01\x12\x04\xe2\x04\x02\x12\x1a=\x20Image-sp\
    ecific\x20score\x20for\x20this\x20color.\x20Value\x20in\x20range\x20[0,\
    \x201].\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xe2\x04\x02\x07\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xe2\x04\x08\r\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xe2\x04\x10\x11\n_\n\x04\x04\n\x02\x02\x12\x04\xe6\x04\x02\x1b\x1aQ\
    \x20The\x20fraction\x20of\x20pixels\x20the\x20color\x20occupies\x20in\
    \x20the\x20image.\n\x20Value\x20in\x20range\x20[0,\x201].\n\n\r\n\x05\
    \x04\n\x02\x02\x05\x12\x04\xe6\x04\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\xe6\x04\x08\x16\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xe6\x04\x19\
    \x1a\nF\n\x02\x04\x0b\x12\x06\xea\x04\0\xed\x04\x01\x1a8\x20Set\x20of\
    \x20dominant\x20colors\x20and\x20their\x20corresponding\x20scores.\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\xea\x04\x08\x20\nE\n\x04\x04\x0b\x02\0\
    \x12\x04\xec\x04\x02\x20\x1a7\x20RGB\x20color\x20values\x20with\x20their\
    \x20score\x20and\x20pixel\x20fraction.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\
    \x04\xec\x04\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xec\x04\x0b\x14\n\
    \r\n\x05\x04\x0b\x02\0\x01\x12\x04\xec\x04\x15\x1b\n\r\n\x05\x04\x0b\x02\
    \0\x03\x12\x04\xec\x04\x1e\x1f\nA\n\x02\x04\x0c\x12\x06\xf0\x04\0\xf3\
    \x04\x01\x1a3\x20Stores\x20image\x20properties,\x20such\x20as\x20dominan\
    t\x20colors.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xf0\x04\x08\x17\nC\n\x04\
    \x04\x0c\x02\0\x12\x04\xf2\x04\x02/\x1a5\x20If\x20present,\x20dominant\
    \x20colors\x20completed\x20successfully.\n\n\r\n\x05\x04\x0c\x02\0\x06\
    \x12\x04\xf2\x04\x02\x1a\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xf2\x04\x1b\
    *\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf2\x04-.\n[\n\x02\x04\r\x12\x06\
    \xf6\x04\0\x81\x05\x01\x1aM\x20Single\x20crop\x20hint\x20that\x20is\x20u\
    sed\x20to\x20generate\x20a\x20new\x20crop\x20when\x20serving\x20an\x20im\
    age.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xf6\x04\x08\x10\n\x81\x01\n\x04\x04\
    \r\x02\0\x12\x04\xf9\x04\x02!\x1as\x20The\x20bounding\x20polygon\x20for\
    \x20the\x20crop\x20region.\x20The\x20coordinates\x20of\x20the\x20boundin\
    g\n\x20box\x20are\x20in\x20the\x20original\x20image's\x20scale.\n\n\r\n\
    \x05\x04\r\x02\0\x06\x12\x04\xf9\x04\x02\x0e\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xf9\x04\x0f\x1c\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xf9\x04\x1f\
    \x20\nI\n\x04\x04\r\x02\x01\x12\x04\xfc\x04\x02\x17\x1a;\x20Confidence\
    \x20of\x20this\x20being\x20a\x20salient\x20region.\x20\x20Range\x20[0,\
    \x201].\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xfc\x04\x02\x07\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xfc\x04\x08\x12\n\r\n\x05\x04\r\x02\x01\x03\
    \x12\x04\xfc\x04\x15\x16\nb\n\x04\x04\r\x02\x02\x12\x04\x80\x05\x02\x20\
    \x1aT\x20Fraction\x20of\x20importance\x20of\x20this\x20salient\x20region\
    \x20with\x20respect\x20to\x20the\x20original\n\x20image.\n\n\r\n\x05\x04\
    \r\x02\x02\x05\x12\x04\x80\x05\x02\x07\n\r\n\x05\x04\r\x02\x02\x01\x12\
    \x04\x80\x05\x08\x1b\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x80\x05\x1e\x1f\
    \nZ\n\x02\x04\x0e\x12\x06\x84\x05\0\x87\x05\x01\x1aL\x20Set\x20of\x20cro\
    p\x20hints\x20that\x20are\x20used\x20to\x20generate\x20new\x20crops\x20w\
    hen\x20serving\x20images.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x84\x05\x08\
    \x1b\n\"\n\x04\x04\x0e\x02\0\x12\x04\x86\x05\x02#\x1a\x14\x20Crop\x20hin\
    t\x20results.\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x86\x05\x02\n\n\r\n\
    \x05\x04\x0e\x02\0\x06\x12\x04\x86\x05\x0b\x13\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\x86\x05\x14\x1e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x86\x05\
    !\"\n=\n\x02\x04\x0f\x12\x06\x8a\x05\0\x92\x05\x01\x1a/\x20Parameters\
    \x20for\x20crop\x20hints\x20annotation\x20request.\n\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\x8a\x05\x08\x17\n\x82\x03\n\x04\x04\x0f\x02\0\x12\x04\x91\
    \x05\x02#\x1a\xf3\x02\x20Aspect\x20ratios\x20in\x20floats,\x20representi\
    ng\x20the\x20ratio\x20of\x20the\x20width\x20to\x20the\x20height\n\x20of\
    \x20the\x20image.\x20For\x20example,\x20if\x20the\x20desired\x20aspect\
    \x20ratio\x20is\x204/3,\x20the\n\x20corresponding\x20float\x20value\x20s\
    hould\x20be\x201.33333.\x20\x20If\x20not\x20specified,\x20the\n\x20best\
    \x20possible\x20crop\x20is\x20returned.\x20The\x20number\x20of\x20provid\
    ed\x20aspect\x20ratios\x20is\n\x20limited\x20to\x20a\x20maximum\x20of\
    \x2016;\x20any\x20aspect\x20ratios\x20provided\x20after\x20the\x2016th\
    \x20are\n\x20ignored.\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x91\x05\x02\
    \n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x91\x05\x0b\x10\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\x91\x05\x11\x1e\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \x91\x05!\"\n5\n\x02\x04\x10\x12\x06\x95\x05\0\x98\x05\x01\x1a'\x20Param\
    eters\x20for\x20web\x20detection\x20request.\n\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\x95\x05\x08\x1a\nY\n\x04\x04\x10\x02\0\x12\x04\x97\x05\x02\x1f\
    \x1aK\x20Whether\x20to\x20include\x20results\x20derived\x20from\x20the\
    \x20geo\x20information\x20in\x20the\x20image.\n\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\x97\x05\x02\x06\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x97\x05\
    \x07\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x97\x05\x1d\x1e\nA\n\x02\
    \x04\x11\x12\x06\x9b\x05\0\xb1\x05\x01\x1a3\x20Image\x20context\x20and/o\
    r\x20feature-specific\x20parameters.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \x9b\x05\x08\x14\n\x19\n\x04\x04\x11\x02\0\x12\x04\x9d\x05\x02\x20\x1a\
    \x0b\x20Not\x20used.\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x9d\x05\x02\r\
    \n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x9d\x05\x0e\x1b\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\x9d\x05\x1e\x1f\n\xbb\x04\n\x04\x04\x11\x02\x01\x12\
    \x04\xa7\x05\x02%\x1a\xac\x04\x20List\x20of\x20languages\x20to\x20use\
    \x20for\x20TEXT_DETECTION.\x20In\x20most\x20cases,\x20an\x20empty\x20val\
    ue\n\x20yields\x20the\x20best\x20results\x20since\x20it\x20enables\x20au\
    tomatic\x20language\x20detection.\x20For\n\x20languages\x20based\x20on\
    \x20the\x20Latin\x20alphabet,\x20setting\x20`language_hints`\x20is\x20no\
    t\n\x20needed.\x20In\x20rare\x20cases,\x20when\x20the\x20language\x20of\
    \x20the\x20text\x20in\x20the\x20image\x20is\x20known,\n\x20setting\x20a\
    \x20hint\x20will\x20help\x20get\x20better\x20results\x20(although\x20it\
    \x20will\x20be\x20a\n\x20significant\x20hindrance\x20if\x20the\x20hint\
    \x20is\x20wrong).\x20Text\x20detection\x20returns\x20an\n\x20error\x20if\
    \x20one\x20or\x20more\x20of\x20the\x20specified\x20languages\x20is\x20no\
    t\x20one\x20of\x20the\n\x20[supported\x20languages](/vision/docs/languag\
    es).\n\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xa7\x05\x02\n\n\r\n\x05\x04\
    \x11\x02\x01\x05\x12\x04\xa7\x05\x0b\x11\n\r\n\x05\x04\x11\x02\x01\x01\
    \x12\x04\xa7\x05\x12\x20\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xa7\x05#$\
    \n=\n\x04\x04\x11\x02\x02\x12\x04\xaa\x05\x02(\x1a/\x20Parameters\x20for\
    \x20crop\x20hints\x20annotation\x20request.\n\n\r\n\x05\x04\x11\x02\x02\
    \x06\x12\x04\xaa\x05\x02\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xaa\
    \x05\x12#\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xaa\x05&'\n.\n\x04\x04\
    \x11\x02\x03\x12\x04\xad\x05\x020\x1a\x20\x20Parameters\x20for\x20produc\
    t\x20search.\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\xad\x05\x02\x15\n\r\
    \n\x05\x04\x11\x02\x03\x01\x12\x04\xad\x05\x16+\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\xad\x05./\n-\n\x04\x04\x11\x02\x04\x12\x04\xb0\x05\x02.\
    \x1a\x1f\x20Parameters\x20for\x20web\x20detection.\n\n\r\n\x05\x04\x11\
    \x02\x04\x06\x12\x04\xb0\x05\x02\x14\n\r\n\x05\x04\x11\x02\x04\x01\x12\
    \x04\xb0\x05\x15)\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xb0\x05,-\n\x9e\
    \x01\n\x02\x04\x12\x12\x06\xb5\x05\0\xbe\x05\x01\x1a\x8f\x01\x20Request\
    \x20for\x20performing\x20Google\x20Cloud\x20Vision\x20API\x20tasks\x20ov\
    er\x20a\x20user-provided\n\x20image,\x20with\x20user-requested\x20featur\
    es,\x20and\x20with\x20context\x20information.\n\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xb5\x05\x08\x1c\n*\n\x04\x04\x12\x02\0\x12\x04\xb7\x05\x02\x12\
    \x1a\x1c\x20The\x20image\x20to\x20be\x20processed.\n\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xb7\x05\x02\x07\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xb7\x05\x08\r\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb7\x05\x10\x11\n#\n\
    \x04\x04\x12\x02\x01\x12\x04\xba\x05\x02\x20\x1a\x15\x20Requested\x20fea\
    tures.\n\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xba\x05\x02\n\n\r\n\x05\
    \x04\x12\x02\x01\x06\x12\x04\xba\x05\x0b\x12\n\r\n\x05\x04\x12\x02\x01\
    \x01\x12\x04\xba\x05\x13\x1b\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xba\
    \x05\x1e\x1f\n@\n\x04\x04\x12\x02\x02\x12\x04\xbd\x05\x02!\x1a2\x20Addit\
    ional\x20context\x20that\x20may\x20accompany\x20the\x20image.\n\n\r\n\
    \x05\x04\x12\x02\x02\x06\x12\x04\xbd\x05\x02\x0e\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xbd\x05\x0f\x1c\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\
    \xbd\x05\x1f\x20\n\x82\x01\n\x02\x04\x13\x12\x06\xc2\x05\0\xc9\x05\x01\
    \x1at\x20If\x20an\x20image\x20was\x20produced\x20from\x20a\x20file\x20(e\
    .g.\x20a\x20PDF),\x20this\x20message\x20gives\n\x20information\x20about\
    \x20the\x20source\x20of\x20that\x20image.\n\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xc2\x05\x08\x1e\n>\n\x04\x04\x13\x02\0\x12\x04\xc4\x05\x02\x11\x1a0\
    \x20The\x20URI\x20of\x20the\x20file\x20used\x20to\x20produce\x20the\x20i\
    mage.\n\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xc4\x05\x02\x08\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\xc4\x05\t\x0c\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\xc4\x05\x0f\x10\n{\n\x04\x04\x13\x02\x01\x12\x04\xc8\x05\x02\x18\
    \x1am\x20If\x20the\x20file\x20was\x20a\x20PDF\x20or\x20TIFF,\x20this\x20\
    field\x20gives\x20the\x20page\x20number\x20within\n\x20the\x20file\x20us\
    ed\x20to\x20produce\x20the\x20image.\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\
    \x04\xc8\x05\x02\x07\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xc8\x05\x08\
    \x13\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xc8\x05\x16\x17\n8\n\x02\x04\
    \x14\x12\x06\xcc\x05\0\xfd\x05\x01\x1a*\x20Response\x20to\x20an\x20image\
    \x20annotation\x20request.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xcc\x05\x08\
    \x1d\nF\n\x04\x04\x14\x02\0\x12\x04\xce\x05\x02/\x1a8\x20If\x20present,\
    \x20face\x20detection\x20has\x20completed\x20successfully.\n\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xce\x05\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\
    \x04\xce\x05\x0b\x19\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xce\x05\x1a*\n\
    \r\n\x05\x04\x14\x02\0\x03\x12\x04\xce\x05-.\nJ\n\x04\x04\x14\x02\x01\
    \x12\x04\xd1\x05\x025\x1a<\x20If\x20present,\x20landmark\x20detection\
    \x20has\x20completed\x20successfully.\n\n\r\n\x05\x04\x14\x02\x01\x04\
    \x12\x04\xd1\x05\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xd1\x05\x0b\
    \x1b\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xd1\x05\x1c0\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xd1\x0534\nF\n\x04\x04\x14\x02\x02\x12\x04\xd4\
    \x05\x021\x1a8\x20If\x20present,\x20logo\x20detection\x20has\x20complete\
    d\x20successfully.\n\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xd4\x05\x02\n\
    \n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xd4\x05\x0b\x1b\n\r\n\x05\x04\x14\
    \x02\x02\x01\x12\x04\xd4\x05\x1c,\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \xd4\x05/0\nG\n\x04\x04\x14\x02\x03\x12\x04\xd7\x05\x022\x1a9\x20If\x20p\
    resent,\x20label\x20detection\x20has\x20completed\x20successfully.\n\n\r\
    \n\x05\x04\x14\x02\x03\x04\x12\x04\xd7\x05\x02\n\n\r\n\x05\x04\x14\x02\
    \x03\x06\x12\x04\xd7\x05\x0b\x1b\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\
    \xd7\x05\x1c-\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xd7\x0501\n\x87\x01\
    \n\x04\x04\x14\x02\x04\x12\x04\xdb\x05\x02G\x1ay\x20If\x20present,\x20lo\
    calized\x20object\x20detection\x20has\x20completed\x20successfully.\n\
    \x20This\x20will\x20be\x20sorted\x20descending\x20by\x20confidence\x20sc\
    ore.\n\n\r\n\x05\x04\x14\x02\x04\x04\x12\x04\xdb\x05\x02\n\n\r\n\x05\x04\
    \x14\x02\x04\x06\x12\x04\xdb\x05\x0b$\n\r\n\x05\x04\x14\x02\x04\x01\x12\
    \x04\xdb\x05%A\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xdb\x05DF\nL\n\x04\
    \x04\x14\x02\x05\x12\x04\xde\x05\x021\x1a>\x20If\x20present,\x20text\x20\
    (OCR)\x20detection\x20has\x20completed\x20successfully.\n\n\r\n\x05\x04\
    \x14\x02\x05\x04\x12\x04\xde\x05\x02\n\n\r\n\x05\x04\x14\x02\x05\x06\x12\
    \x04\xde\x05\x0b\x1b\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xde\x05\x1c,\
    \n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xde\x05/0\n\xbe\x01\n\x04\x04\x14\
    \x02\x06\x12\x04\xe4\x05\x02+\x1a\xaf\x01\x20If\x20present,\x20text\x20(\
    OCR)\x20detection\x20or\x20document\x20(OCR)\x20text\x20detection\x20has\
    \n\x20completed\x20successfully.\n\x20This\x20annotation\x20provides\x20\
    the\x20structural\x20hierarchy\x20for\x20the\x20OCR\x20detected\n\x20tex\
    t.\n\n\r\n\x05\x04\x14\x02\x06\x06\x12\x04\xe4\x05\x02\x10\n\r\n\x05\x04\
    \x14\x02\x06\x01\x12\x04\xe4\x05\x11%\n\r\n\x05\x04\x14\x02\x06\x03\x12\
    \x04\xe4\x05(*\nN\n\x04\x04\x14\x02\x07\x12\x04\xe7\x05\x022\x1a@\x20If\
    \x20present,\x20safe-search\x20annotation\x20has\x20completed\x20success\
    fully.\n\n\r\n\x05\x04\x14\x02\x07\x06\x12\x04\xe7\x05\x02\x16\n\r\n\x05\
    \x04\x14\x02\x07\x01\x12\x04\xe7\x05\x17-\n\r\n\x05\x04\x14\x02\x07\x03\
    \x12\x04\xe7\x0501\nI\n\x04\x04\x14\x02\x08\x12\x04\xea\x05\x022\x1a;\
    \x20If\x20present,\x20image\x20properties\x20were\x20extracted\x20succes\
    sfully.\n\n\r\n\x05\x04\x14\x02\x08\x06\x12\x04\xea\x05\x02\x11\n\r\n\
    \x05\x04\x14\x02\x08\x01\x12\x04\xea\x05\x12-\n\r\n\x05\x04\x14\x02\x08\
    \x03\x12\x04\xea\x0501\nC\n\x04\x04\x14\x02\t\x12\x04\xed\x05\x021\x1a5\
    \x20If\x20present,\x20crop\x20hints\x20have\x20completed\x20successfully\
    .\n\n\r\n\x05\x04\x14\x02\t\x06\x12\x04\xed\x05\x02\x15\n\r\n\x05\x04\
    \x14\x02\t\x01\x12\x04\xed\x05\x16+\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\
    \xed\x05.0\nE\n\x04\x04\x14\x02\n\x12\x04\xf0\x05\x02\"\x1a7\x20If\x20pr\
    esent,\x20web\x20detection\x20has\x20completed\x20successfully.\n\n\r\n\
    \x05\x04\x14\x02\n\x06\x12\x04\xf0\x05\x02\x0e\n\r\n\x05\x04\x14\x02\n\
    \x01\x12\x04\xf0\x05\x0f\x1c\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\xf0\x05\
    \x1f!\nF\n\x04\x04\x14\x02\x0b\x12\x04\xf3\x05\x023\x1a8\x20If\x20presen\
    t,\x20product\x20search\x20has\x20completed\x20successfully.\n\n\r\n\x05\
    \x04\x14\x02\x0b\x06\x12\x04\xf3\x05\x02\x16\n\r\n\x05\x04\x14\x02\x0b\
    \x01\x12\x04\xf3\x05\x17-\n\r\n\x05\x04\x14\x02\x0b\x03\x12\x04\xf3\x050\
    2\n\xa8\x01\n\x04\x04\x14\x02\x0c\x12\x04\xf8\x05\x02\x1e\x1a\x99\x01\
    \x20If\x20set,\x20represents\x20the\x20error\x20message\x20for\x20the\
    \x20operation.\n\x20Note\x20that\x20filled-in\x20image\x20annotations\
    \x20are\x20guaranteed\x20to\x20be\n\x20correct,\x20even\x20when\x20`erro\
    r`\x20is\x20set.\n\n\r\n\x05\x04\x14\x02\x0c\x06\x12\x04\xf8\x05\x02\x13\
    \n\r\n\x05\x04\x14\x02\x0c\x01\x12\x04\xf8\x05\x14\x19\n\r\n\x05\x04\x14\
    \x02\x0c\x03\x12\x04\xf8\x05\x1c\x1d\nh\n\x04\x04\x14\x02\r\x12\x04\xfc\
    \x05\x02&\x1aZ\x20If\x20present,\x20contextual\x20information\x20is\x20n\
    eeded\x20to\x20understand\x20where\x20this\x20image\n\x20comes\x20from.\
    \n\n\r\n\x05\x04\x14\x02\r\x06\x12\x04\xfc\x05\x02\x18\n\r\n\x05\x04\x14\
    \x02\r\x01\x12\x04\xfc\x05\x19\x20\n\r\n\x05\x04\x14\x02\r\x03\x12\x04\
    \xfc\x05#%\nZ\n\x02\x04\x15\x12\x06\x80\x06\0\x91\x06\x01\x1aL\x20Multip\
    le\x20image\x20annotation\x20requests\x20are\x20batched\x20into\x20a\x20\
    single\x20service\x20call.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\x80\x06\x08\
    \"\nN\n\x04\x04\x15\x02\0\x12\x04\x82\x06\x02V\x1a@\x20Required.\x20Indi\
    vidual\x20image\x20annotation\x20requests\x20for\x20this\x20batch.\n\n\r\
    \n\x05\x04\x15\x02\0\x04\x12\x04\x82\x06\x02\n\n\r\n\x05\x04\x15\x02\0\
    \x06\x12\x04\x82\x06\x0b\x1f\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x82\x06\
    \x20(\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x82\x06+,\n\r\n\x05\x04\x15\
    \x02\0\x08\x12\x04\x82\x06-U\n\x10\n\x08\x04\x15\x02\0\x08\x9c\x08\0\x12\
    \x04\x82\x06.T\n\xfb\x02\n\x04\x04\x15\x02\x01\x12\x04\x90\x06\x02\x14\
    \x1a\xec\x02\x20Optional.\x20Target\x20project\x20and\x20location\x20to\
    \x20make\x20a\x20call.\n\n\x20Format:\x20`projects/{project-id}/location\
    s/{location-id}`.\n\n\x20If\x20no\x20parent\x20is\x20specified,\x20a\x20\
    region\x20will\x20be\x20chosen\x20automatically.\n\n\x20Supported\x20loc\
    ation-ids:\n\x20\x20\x20\x20\x20`us`:\x20USA\x20country\x20only,\n\x20\
    \x20\x20\x20\x20`asia`:\x20East\x20asia\x20areas,\x20like\x20Japan,\x20T\
    aiwan,\n\x20\x20\x20\x20\x20`eu`:\x20The\x20European\x20Union.\n\n\x20Ex\
    ample:\x20`projects/project-A/locations/eu`.\n\n\r\n\x05\x04\x15\x02\x01\
    \x05\x12\x04\x90\x06\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x90\
    \x06\t\x0f\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x90\x06\x12\x13\n=\n\
    \x02\x04\x16\x12\x06\x94\x06\0\x97\x06\x01\x1a/\x20Response\x20to\x20a\
    \x20batch\x20image\x20annotation\x20request.\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\x94\x06\x08#\nS\n\x04\x04\x16\x02\0\x12\x04\x96\x06\x02/\x1aE\
    \x20Individual\x20responses\x20to\x20image\x20annotation\x20requests\x20\
    within\x20the\x20batch.\n\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x96\x06\
    \x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x96\x06\x0b\x20\n\r\n\x05\x04\
    \x16\x02\0\x01\x12\x04\x96\x06!*\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x96\
    \x06-.\nT\n\x02\x04\x17\x12\x06\x9a\x06\0\xb3\x06\x01\x1aF\x20A\x20reque\
    st\x20to\x20annotate\x20one\x20single\x20file,\x20e.g.\x20a\x20PDF,\x20T\
    IFF\x20or\x20GIF\x20file.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\x9a\x06\x08\
    \x1b\n;\n\x04\x04\x17\x02\0\x12\x04\x9c\x06\x02\x1f\x1a-\x20Required.\
    \x20Information\x20about\x20the\x20input\x20file.\n\n\r\n\x05\x04\x17\
    \x02\0\x06\x12\x04\x9c\x06\x02\r\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x9c\
    \x06\x0e\x1a\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x9c\x06\x1d\x1e\n-\n\
    \x04\x04\x17\x02\x01\x12\x04\x9f\x06\x02\x20\x1a\x1f\x20Required.\x20Req\
    uested\x20features.\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\x9f\x06\x02\
    \n\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\x9f\x06\x0b\x12\n\r\n\x05\x04\
    \x17\x02\x01\x01\x12\x04\x9f\x06\x13\x1b\n\r\n\x05\x04\x17\x02\x01\x03\
    \x12\x04\x9f\x06\x1e\x1f\nO\n\x04\x04\x17\x02\x02\x12\x04\xa2\x06\x02!\
    \x1aA\x20Additional\x20context\x20that\x20may\x20accompany\x20the\x20ima\
    ge(s)\x20in\x20the\x20file.\n\n\r\n\x05\x04\x17\x02\x02\x06\x12\x04\xa2\
    \x06\x02\x0e\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xa2\x06\x0f\x1c\n\r\n\
    \x05\x04\x17\x02\x02\x03\x12\x04\xa2\x06\x1f\x20\n\x88\x04\n\x04\x04\x17\
    \x02\x03\x12\x04\xb2\x06\x02\x1b\x1a\xf9\x03\x20Pages\x20of\x20the\x20fi\
    le\x20to\x20perform\x20image\x20annotation.\n\n\x20Pages\x20starts\x20fr\
    om\x201,\x20we\x20assume\x20the\x20first\x20page\x20of\x20the\x20file\
    \x20is\x20page\x201.\n\x20At\x20most\x205\x20pages\x20are\x20supported\
    \x20per\x20request.\x20Pages\x20can\x20be\x20negative.\n\n\x20Page\x201\
    \x20means\x20the\x20first\x20page.\n\x20Page\x202\x20means\x20the\x20sec\
    ond\x20page.\n\x20Page\x20-1\x20means\x20the\x20last\x20page.\n\x20Page\
    \x20-2\x20means\x20the\x20second\x20to\x20the\x20last\x20page.\n\n\x20If\
    \x20the\x20file\x20is\x20GIF\x20instead\x20of\x20PDF\x20or\x20TIFF,\x20p\
    age\x20refers\x20to\x20GIF\x20frames.\n\n\x20If\x20this\x20field\x20is\
    \x20empty,\x20by\x20default\x20the\x20service\x20performs\x20image\x20an\
    notation\n\x20for\x20the\x20first\x205\x20pages\x20of\x20the\x20file.\n\
    \n\r\n\x05\x04\x17\x02\x03\x04\x12\x04\xb2\x06\x02\n\n\r\n\x05\x04\x17\
    \x02\x03\x05\x12\x04\xb2\x06\x0b\x10\n\r\n\x05\x04\x17\x02\x03\x01\x12\
    \x04\xb2\x06\x11\x16\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xb2\x06\x19\
    \x1a\n\x93\x01\n\x02\x04\x18\x12\x06\xb7\x06\0\xc5\x06\x01\x1a\x84\x01\
    \x20Response\x20to\x20a\x20single\x20file\x20annotation\x20request.\x20A\
    \x20file\x20may\x20contain\x20one\x20or\x20more\n\x20images,\x20which\
    \x20individually\x20have\x20their\x20own\x20responses.\n\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xb7\x06\x08\x1c\nP\n\x04\x04\x18\x02\0\x12\x04\xb9\x06\
    \x02\x1f\x1aB\x20Information\x20about\x20the\x20file\x20for\x20which\x20\
    this\x20response\x20is\x20generated.\n\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\xb9\x06\x02\r\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb9\x06\x0e\x1a\n\
    \r\n\x05\x04\x18\x02\0\x03\x12\x04\xb9\x06\x1d\x1e\n|\n\x04\x04\x18\x02\
    \x01\x12\x04\xbd\x06\x02/\x1an\x20Individual\x20responses\x20to\x20image\
    s\x20found\x20within\x20the\x20file.\x20This\x20field\x20will\x20be\n\
    \x20empty\x20if\x20the\x20`error`\x20field\x20is\x20set.\n\n\r\n\x05\x04\
    \x18\x02\x01\x04\x12\x04\xbd\x06\x02\n\n\r\n\x05\x04\x18\x02\x01\x06\x12\
    \x04\xbd\x06\x0b\x20\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xbd\x06!*\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\xbd\x06-.\nG\n\x04\x04\x18\x02\x02\
    \x12\x04\xc0\x06\x02\x18\x1a9\x20This\x20field\x20gives\x20the\x20total\
    \x20number\x20of\x20pages\x20in\x20the\x20file.\n\n\r\n\x05\x04\x18\x02\
    \x02\x05\x12\x04\xc0\x06\x02\x07\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\
    \xc0\x06\x08\x13\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xc0\x06\x16\x17\n\
    \x81\x01\n\x04\x04\x18\x02\x03\x12\x04\xc4\x06\x02\x1e\x1as\x20If\x20set\
    ,\x20represents\x20the\x20error\x20message\x20for\x20the\x20failed\x20re\
    quest.\x20The\n\x20`responses`\x20field\x20will\x20not\x20be\x20set\x20i\
    n\x20this\x20case.\n\n\r\n\x05\x04\x18\x02\x03\x06\x12\x04\xc4\x06\x02\
    \x13\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xc4\x06\x14\x19\n\r\n\x05\x04\
    \x18\x02\x03\x03\x12\x04\xc4\x06\x1c\x1d\nV\n\x02\x04\x19\x12\x06\xc8\
    \x06\0\xda\x06\x01\x1aH\x20A\x20list\x20of\x20requests\x20to\x20annotate\
    \x20files\x20using\x20the\x20BatchAnnotateFiles\x20API.\n\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\xc8\x06\x08!\n\x91\x01\n\x04\x04\x19\x02\0\x12\x04\
    \xcb\x06\x02U\x1a\x82\x01\x20Required.\x20The\x20list\x20of\x20file\x20a\
    nnotation\x20requests.\x20Right\x20now\x20we\x20support\x20only\x20one\n\
    \x20AnnotateFileRequest\x20in\x20BatchAnnotateFilesRequest.\n\n\r\n\x05\
    \x04\x19\x02\0\x04\x12\x04\xcb\x06\x02\n\n\r\n\x05\x04\x19\x02\0\x06\x12\
    \x04\xcb\x06\x0b\x1e\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xcb\x06\x1f'\n\
    \r\n\x05\x04\x19\x02\0\x03\x12\x04\xcb\x06*+\n\r\n\x05\x04\x19\x02\0\x08\
    \x12\x04\xcb\x06,T\n\x10\n\x08\x04\x19\x02\0\x08\x9c\x08\0\x12\x04\xcb\
    \x06-S\n\xfb\x02\n\x04\x04\x19\x02\x01\x12\x04\xd9\x06\x02\x14\x1a\xec\
    \x02\x20Optional.\x20Target\x20project\x20and\x20location\x20to\x20make\
    \x20a\x20call.\n\n\x20Format:\x20`projects/{project-id}/locations/{locat\
    ion-id}`.\n\n\x20If\x20no\x20parent\x20is\x20specified,\x20a\x20region\
    \x20will\x20be\x20chosen\x20automatically.\n\n\x20Supported\x20location-\
    ids:\n\x20\x20\x20\x20\x20`us`:\x20USA\x20country\x20only,\n\x20\x20\x20\
    \x20\x20`asia`:\x20East\x20asia\x20areas,\x20like\x20Japan,\x20Taiwan,\n\
    \x20\x20\x20\x20\x20`eu`:\x20The\x20European\x20Union.\n\n\x20Example:\
    \x20`projects/project-A/locations/eu`.\n\n\r\n\x05\x04\x19\x02\x01\x05\
    \x12\x04\xd9\x06\x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd9\x06\t\
    \x0f\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd9\x06\x12\x13\n4\n\x02\x04\
    \x1a\x12\x06\xdd\x06\0\xe1\x06\x01\x1a&\x20A\x20list\x20of\x20file\x20an\
    notation\x20responses.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xdd\x06\x08\"\n\
    \x8d\x01\n\x04\x04\x1a\x02\0\x12\x04\xe0\x06\x02.\x1a\x7f\x20The\x20list\
    \x20of\x20file\x20annotation\x20responses,\x20each\x20response\x20corres\
    ponding\x20to\x20each\n\x20AnnotateFileRequest\x20in\x20BatchAnnotateFil\
    esRequest.\n\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xe0\x06\x02\n\n\r\n\x05\
    \x04\x1a\x02\0\x06\x12\x04\xe0\x06\x0b\x1f\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\xe0\x06\x20)\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xe0\x06,-\n3\n\
    \x02\x04\x1b\x12\x06\xe4\x06\0\xf0\x06\x01\x1a%\x20An\x20offline\x20file\
    \x20annotation\x20request.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe4\x06\x08\
    \x20\n;\n\x04\x04\x1b\x02\0\x12\x04\xe6\x06\x02\x1f\x1a-\x20Required.\
    \x20Information\x20about\x20the\x20input\x20file.\n\n\r\n\x05\x04\x1b\
    \x02\0\x06\x12\x04\xe6\x06\x02\r\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe6\
    \x06\x0e\x1a\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe6\x06\x1d\x1e\n-\n\
    \x04\x04\x1b\x02\x01\x12\x04\xe9\x06\x02\x20\x1a\x1f\x20Required.\x20Req\
    uested\x20features.\n\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xe9\x06\x02\
    \n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xe9\x06\x0b\x12\n\r\n\x05\x04\
    \x1b\x02\x01\x01\x12\x04\xe9\x06\x13\x1b\n\r\n\x05\x04\x1b\x02\x01\x03\
    \x12\x04\xe9\x06\x1e\x1f\nO\n\x04\x04\x1b\x02\x02\x12\x04\xec\x06\x02!\
    \x1aA\x20Additional\x20context\x20that\x20may\x20accompany\x20the\x20ima\
    ge(s)\x20in\x20the\x20file.\n\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\xec\
    \x06\x02\x0e\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xec\x06\x0f\x1c\n\r\n\
    \x05\x04\x1b\x02\x02\x03\x12\x04\xec\x06\x1f\x20\nQ\n\x04\x04\x1b\x02\
    \x03\x12\x04\xef\x06\x02!\x1aC\x20Required.\x20The\x20desired\x20output\
    \x20location\x20and\x20metadata\x20(e.g.\x20format).\n\n\r\n\x05\x04\x1b\
    \x02\x03\x06\x12\x04\xef\x06\x02\x0e\n\r\n\x05\x04\x1b\x02\x03\x01\x12\
    \x04\xef\x06\x0f\x1c\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xef\x06\x1f\
    \x20\nJ\n\x02\x04\x1c\x12\x06\xf3\x06\0\xf6\x06\x01\x1a<\x20The\x20respo\
    nse\x20for\x20a\x20single\x20offline\x20file\x20annotation\x20request.\n\
    \n\x0b\n\x03\x04\x1c\x01\x12\x04\xf3\x06\x08!\nO\n\x04\x04\x1c\x02\0\x12\
    \x04\xf5\x06\x02!\x1aA\x20The\x20output\x20location\x20and\x20metadata\
    \x20from\x20AsyncAnnotateFileRequest.\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\
    \x04\xf5\x06\x02\x0e\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf5\x06\x0f\x1c\
    \n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf5\x06\x1f\x20\nH\n\x02\x04\x1d\
    \x12\x06\xf9\x06\0\x8d\x07\x01\x1a:\x20Request\x20for\x20async\x20image\
    \x20annotation\x20for\x20a\x20list\x20of\x20images.\n\n\x0b\n\x03\x04\
    \x1d\x01\x12\x04\xf9\x06\x08'\nN\n\x04\x04\x1d\x02\0\x12\x04\xfb\x06\x02\
    V\x1a@\x20Required.\x20Individual\x20image\x20annotation\x20requests\x20\
    for\x20this\x20batch.\n\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xfb\x06\x02\
    \n\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xfb\x06\x0b\x1f\n\r\n\x05\x04\x1d\
    \x02\0\x01\x12\x04\xfb\x06\x20(\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xfb\
    \x06+,\n\r\n\x05\x04\x1d\x02\0\x08\x12\x04\xfb\x06-U\n\x10\n\x08\x04\x1d\
    \x02\0\x08\x9c\x08\0\x12\x04\xfb\x06.T\nQ\n\x04\x04\x1d\x02\x01\x12\x04\
    \xfe\x06\x02J\x1aC\x20Required.\x20The\x20desired\x20output\x20location\
    \x20and\x20metadata\x20(e.g.\x20format).\n\n\r\n\x05\x04\x1d\x02\x01\x06\
    \x12\x04\xfe\x06\x02\x0e\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xfe\x06\
    \x0f\x1c\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xfe\x06\x1f\x20\n\r\n\x05\
    \x04\x1d\x02\x01\x08\x12\x04\xfe\x06!I\n\x10\n\x08\x04\x1d\x02\x01\x08\
    \x9c\x08\0\x12\x04\xfe\x06\"H\n\xfb\x02\n\x04\x04\x1d\x02\x02\x12\x04\
    \x8c\x07\x02\x14\x1a\xec\x02\x20Optional.\x20Target\x20project\x20and\
    \x20location\x20to\x20make\x20a\x20call.\n\n\x20Format:\x20`projects/{pr\
    oject-id}/locations/{location-id}`.\n\n\x20If\x20no\x20parent\x20is\x20s\
    pecified,\x20a\x20region\x20will\x20be\x20chosen\x20automatically.\n\n\
    \x20Supported\x20location-ids:\n\x20\x20\x20\x20\x20`us`:\x20USA\x20coun\
    try\x20only,\n\x20\x20\x20\x20\x20`asia`:\x20East\x20asia\x20areas,\x20l\
    ike\x20Japan,\x20Taiwan,\n\x20\x20\x20\x20\x20`eu`:\x20The\x20European\
    \x20Union.\n\n\x20Example:\x20`projects/project-A/locations/eu`.\n\n\r\n\
    \x05\x04\x1d\x02\x02\x05\x12\x04\x8c\x07\x02\x08\n\r\n\x05\x04\x1d\x02\
    \x02\x01\x12\x04\x8c\x07\t\x0f\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x8c\
    \x07\x12\x13\nD\n\x02\x04\x1e\x12\x06\x90\x07\0\x93\x07\x01\x1a6\x20Resp\
    onse\x20to\x20an\x20async\x20batch\x20image\x20annotation\x20request.\n\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\x90\x07\x08(\nV\n\x04\x04\x1e\x02\0\x12\
    \x04\x92\x07\x02!\x1aH\x20The\x20output\x20location\x20and\x20metadata\
    \x20from\x20AsyncBatchAnnotateImagesRequest.\n\n\r\n\x05\x04\x1e\x02\0\
    \x06\x12\x04\x92\x07\x02\x0e\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x92\x07\
    \x0f\x1c\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x92\x07\x1f\x20\n`\n\x02\
    \x04\x1f\x12\x06\x97\x07\0\xa8\x07\x01\x1aR\x20Multiple\x20async\x20file\
    \x20annotation\x20requests\x20are\x20batched\x20into\x20a\x20single\x20s\
    ervice\n\x20call.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\x97\x07\x08&\nS\n\
    \x04\x04\x1f\x02\0\x12\x04\x99\x07\x02Z\x1aE\x20Required.\x20Individual\
    \x20async\x20file\x20annotation\x20requests\x20for\x20this\x20batch.\n\n\
    \r\n\x05\x04\x1f\x02\0\x04\x12\x04\x99\x07\x02\n\n\r\n\x05\x04\x1f\x02\0\
    \x06\x12\x04\x99\x07\x0b#\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x99\x07$,\
    \n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x99\x07/0\n\r\n\x05\x04\x1f\x02\0\
    \x08\x12\x04\x99\x071Y\n\x10\n\x08\x04\x1f\x02\0\x08\x9c\x08\0\x12\x04\
    \x99\x072X\n\xfb\x02\n\x04\x04\x1f\x02\x01\x12\x04\xa7\x07\x02\x14\x1a\
    \xec\x02\x20Optional.\x20Target\x20project\x20and\x20location\x20to\x20m\
    ake\x20a\x20call.\n\n\x20Format:\x20`projects/{project-id}/locations/{lo\
    cation-id}`.\n\n\x20If\x20no\x20parent\x20is\x20specified,\x20a\x20regio\
    n\x20will\x20be\x20chosen\x20automatically.\n\n\x20Supported\x20location\
    -ids:\n\x20\x20\x20\x20\x20`us`:\x20USA\x20country\x20only,\n\x20\x20\
    \x20\x20\x20`asia`:\x20East\x20asia\x20areas,\x20like\x20Japan,\x20Taiwa\
    n,\n\x20\x20\x20\x20\x20`eu`:\x20The\x20European\x20Union.\n\n\x20Exampl\
    e:\x20`projects/project-A/locations/eu`.\n\n\r\n\x05\x04\x1f\x02\x01\x05\
    \x12\x04\xa7\x07\x02\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xa7\x07\t\
    \x0f\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xa7\x07\x12\x13\nC\n\x02\x04\
    \x20\x12\x06\xab\x07\0\xaf\x07\x01\x1a5\x20Response\x20to\x20an\x20async\
    \x20batch\x20file\x20annotation\x20request.\n\n\x0b\n\x03\x04\x20\x01\
    \x12\x04\xab\x07\x08'\no\n\x04\x04\x20\x02\0\x12\x04\xae\x07\x023\x1aa\
    \x20The\x20list\x20of\x20file\x20annotation\x20responses,\x20one\x20for\
    \x20each\x20request\x20in\n\x20AsyncBatchAnnotateFilesRequest.\n\n\r\n\
    \x05\x04\x20\x02\0\x04\x12\x04\xae\x07\x02\n\n\r\n\x05\x04\x20\x02\0\x06\
    \x12\x04\xae\x07\x0b$\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xae\x07%.\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\xae\x0712\n8\n\x02\x04!\x12\x06\xb2\x07\
    \0\xc1\x07\x01\x1a*\x20The\x20desired\x20input\x20location\x20and\x20met\
    adata.\n\n\x0b\n\x03\x04!\x01\x12\x04\xb2\x07\x08\x13\nI\n\x04\x04!\x02\
    \0\x12\x04\xb4\x07\x02\x1b\x1a;\x20The\x20Google\x20Cloud\x20Storage\x20\
    location\x20to\x20read\x20the\x20input\x20from.\n\n\r\n\x05\x04!\x02\0\
    \x06\x12\x04\xb4\x07\x02\x0b\n\r\n\x05\x04!\x02\0\x01\x12\x04\xb4\x07\
    \x0c\x16\n\r\n\x05\x04!\x02\0\x03\x12\x04\xb4\x07\x19\x1a\n\xb8\x02\n\
    \x04\x04!\x02\x01\x12\x04\xbc\x07\x02\x14\x1a\xa9\x02\x20File\x20content\
    ,\x20represented\x20as\x20a\x20stream\x20of\x20bytes.\n\x20Note:\x20As\
    \x20with\x20all\x20`bytes`\x20fields,\x20protobuffers\x20use\x20a\x20pur\
    e\x20binary\n\x20representation,\x20whereas\x20JSON\x20representations\
    \x20use\x20base64.\n\n\x20Currently,\x20this\x20field\x20only\x20works\
    \x20for\x20BatchAnnotateFiles\x20requests.\x20It\x20does\n\x20not\x20wor\
    k\x20for\x20AsyncBatchAnnotateFiles\x20requests.\n\n\r\n\x05\x04!\x02\
    \x01\x05\x12\x04\xbc\x07\x02\x07\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xbc\
    \x07\x08\x0f\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xbc\x07\x12\x13\n\x92\
    \x01\n\x04\x04!\x02\x02\x12\x04\xc0\x07\x02\x17\x1a\x83\x01\x20The\x20ty\
    pe\x20of\x20the\x20file.\x20Currently\x20only\x20\"application/pdf\",\
    \x20\"image/tiff\"\x20and\n\x20\"image/gif\"\x20are\x20supported.\x20Wil\
    dcards\x20are\x20not\x20supported.\n\n\r\n\x05\x04!\x02\x02\x05\x12\x04\
    \xc0\x07\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xc0\x07\t\x12\n\r\n\
    \x05\x04!\x02\x02\x03\x12\x04\xc0\x07\x15\x16\n9\n\x02\x04\"\x12\x06\xc4\
    \x07\0\xd4\x07\x01\x1a+\x20The\x20desired\x20output\x20location\x20and\
    \x20metadata.\n\n\x0b\n\x03\x04\"\x01\x12\x04\xc4\x07\x08\x14\nL\n\x04\
    \x04\"\x02\0\x12\x04\xc6\x07\x02%\x1a>\x20The\x20Google\x20Cloud\x20Stor\
    age\x20location\x20to\x20write\x20the\x20output(s)\x20to.\n\n\r\n\x05\
    \x04\"\x02\0\x06\x12\x04\xc6\x07\x02\x10\n\r\n\x05\x04\"\x02\0\x01\x12\
    \x04\xc6\x07\x11\x20\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xc6\x07#$\n\x8e\
    \x04\n\x04\x04\"\x02\x01\x12\x04\xd3\x07\x02\x17\x1a\xff\x03\x20The\x20m\
    ax\x20number\x20of\x20response\x20protos\x20to\x20put\x20into\x20each\
    \x20output\x20JSON\x20file\x20on\n\x20Google\x20Cloud\x20Storage.\n\x20T\
    he\x20valid\x20range\x20is\x20[1,\x20100].\x20If\x20not\x20specified,\
    \x20the\x20default\x20value\x20is\x2020.\n\n\x20For\x20example,\x20for\
    \x20one\x20pdf\x20file\x20with\x20100\x20pages,\x20100\x20response\x20pr\
    otos\x20will\n\x20be\x20generated.\x20If\x20`batch_size`\x20=\x2020,\x20\
    then\x205\x20json\x20files\x20each\n\x20containing\x2020\x20response\x20\
    protos\x20will\x20be\x20written\x20under\x20the\x20prefix\n\x20`gcs_dest\
    ination`.`uri`.\n\n\x20Currently,\x20batch_size\x20only\x20applies\x20to\
    \x20GcsDestination,\x20with\x20potential\x20future\n\x20support\x20for\
    \x20other\x20output\x20configurations.\n\n\r\n\x05\x04\"\x02\x01\x05\x12\
    \x04\xd3\x07\x02\x07\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xd3\x07\x08\x12\
    \n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xd3\x07\x15\x16\nT\n\x02\x04#\x12\
    \x06\xd7\x07\0\xdb\x07\x01\x1aF\x20The\x20Google\x20Cloud\x20Storage\x20\
    location\x20where\x20the\x20input\x20will\x20be\x20read\x20from.\n\n\x0b\
    \n\x03\x04#\x01\x12\x04\xd7\x07\x08\x11\n\x96\x01\n\x04\x04#\x02\0\x12\
    \x04\xda\x07\x02\x11\x1a\x87\x01\x20Google\x20Cloud\x20Storage\x20URI\
    \x20for\x20the\x20input\x20file.\x20This\x20must\x20only\x20be\x20a\n\
    \x20Google\x20Cloud\x20Storage\x20object.\x20Wildcards\x20are\x20not\x20\
    currently\x20supported.\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\xda\x07\x02\
    \x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\xda\x07\t\x0c\n\r\n\x05\x04#\x02\0\
    \x03\x12\x04\xda\x07\x0f\x10\nV\n\x02\x04$\x12\x06\xde\x07\0\xf6\x07\x01\
    \x1aH\x20The\x20Google\x20Cloud\x20Storage\x20location\x20where\x20the\
    \x20output\x20will\x20be\x20written\x20to.\n\n\x0b\n\x03\x04$\x01\x12\
    \x04\xde\x07\x08\x16\n\xc9\x08\n\x04\x04$\x02\0\x12\x04\xf5\x07\x02\x11\
    \x1a\xba\x08\x20Google\x20Cloud\x20Storage\x20URI\x20prefix\x20where\x20\
    the\x20results\x20will\x20be\x20stored.\x20Results\n\x20will\x20be\x20in\
    \x20JSON\x20format\x20and\x20preceded\x20by\x20its\x20corresponding\x20i\
    nput\x20URI\x20prefix.\n\x20This\x20field\x20can\x20either\x20represent\
    \x20a\x20gcs\x20file\x20prefix\x20or\x20gcs\x20directory.\x20In\n\x20eit\
    her\x20case,\x20the\x20uri\x20should\x20be\x20unique\x20because\x20in\
    \x20order\x20to\x20get\x20all\x20of\x20the\n\x20output\x20files,\x20you\
    \x20will\x20need\x20to\x20do\x20a\x20wildcard\x20gcs\x20search\x20on\x20\
    the\x20uri\x20prefix\n\x20you\x20provide.\n\n\x20Examples:\n\n\x20*\x20\
    \x20\x20\x20File\x20Prefix:\x20gs://bucket-name/here/filenameprefix\x20\
    \x20\x20The\x20output\x20files\n\x20will\x20be\x20created\x20in\x20gs://\
    bucket-name/here/\x20and\x20the\x20names\x20of\x20the\n\x20output\x20fil\
    es\x20will\x20begin\x20with\x20\"filenameprefix\".\n\n\x20*\x20\x20\x20\
    \x20Directory\x20Prefix:\x20gs://bucket-name/some/location/\x20\x20\x20T\
    he\x20output\x20files\n\x20will\x20be\x20created\x20in\x20gs://bucket-na\
    me/some/location/\x20and\x20the\x20names\x20of\x20the\n\x20output\x20fil\
    es\x20could\x20be\x20anything\x20because\x20there\x20was\x20no\x20filena\
    me\x20prefix\n\x20specified.\n\n\x20If\x20multiple\x20outputs,\x20each\
    \x20response\x20is\x20still\x20AnnotateFileResponse,\x20each\x20of\n\x20\
    which\x20contains\x20some\x20subset\x20of\x20the\x20full\x20list\x20of\
    \x20AnnotateImageResponse.\n\x20Multiple\x20outputs\x20can\x20happen\x20\
    if,\x20for\x20example,\x20the\x20output\x20JSON\x20is\x20too\x20large\n\
    \x20and\x20overflows\x20into\x20multiple\x20sharded\x20files.\n\n\r\n\
    \x05\x04$\x02\0\x05\x12\x04\xf5\x07\x02\x08\n\r\n\x05\x04$\x02\0\x01\x12\
    \x04\xf5\x07\t\x0c\n\r\n\x05\x04$\x02\0\x03\x12\x04\xf5\x07\x0f\x10\nH\n\
    \x02\x04%\x12\x06\xf9\x07\0\x94\x08\x01\x1a:\x20Contains\x20metadata\x20\
    for\x20the\x20BatchAnnotateImages\x20operation.\n\n\x0b\n\x03\x04%\x01\
    \x12\x04\xf9\x07\x08\x19\n)\n\x04\x04%\x04\0\x12\x06\xfb\x07\x02\x8a\x08\
    \x03\x1a\x19\x20Batch\x20operation\x20states.\n\n\r\n\x05\x04%\x04\0\x01\
    \x12\x04\xfb\x07\x07\x0c\n\x1a\n\x06\x04%\x04\0\x02\0\x12\x04\xfd\x07\
    \x04\x1a\x1a\n\x20Invalid.\n\n\x0f\n\x07\x04%\x04\0\x02\0\x01\x12\x04\
    \xfd\x07\x04\x15\n\x0f\n\x07\x04%\x04\0\x02\0\x02\x12\x04\xfd\x07\x18\
    \x19\n&\n\x06\x04%\x04\0\x02\x01\x12\x04\x80\x08\x04\x10\x1a\x16\x20Requ\
    est\x20is\x20received.\n\n\x0f\n\x07\x04%\x04\0\x02\x01\x01\x12\x04\x80\
    \x08\x04\x0b\n\x0f\n\x07\x04%\x04\0\x02\x01\x02\x12\x04\x80\x08\x0e\x0f\
    \n6\n\x06\x04%\x04\0\x02\x02\x12\x04\x83\x08\x04\x10\x1a&\x20Request\x20\
    is\x20actively\x20being\x20processed.\n\n\x0f\n\x07\x04%\x04\0\x02\x02\
    \x01\x12\x04\x83\x08\x04\x0b\n\x0f\n\x07\x04%\x04\0\x02\x02\x02\x12\x04\
    \x83\x08\x0e\x0f\n/\n\x06\x04%\x04\0\x02\x03\x12\x04\x86\x08\x04\r\x1a\
    \x1f\x20The\x20batch\x20processing\x20is\x20done.\n\n\x0f\n\x07\x04%\x04\
    \0\x02\x03\x01\x12\x04\x86\x08\x04\x08\n\x0f\n\x07\x04%\x04\0\x02\x03\
    \x02\x12\x04\x86\x08\x0b\x0c\n5\n\x06\x04%\x04\0\x02\x04\x12\x04\x89\x08\
    \x04\x12\x1a%\x20The\x20batch\x20processing\x20was\x20cancelled.\n\n\x0f\
    \n\x07\x04%\x04\0\x02\x04\x01\x12\x04\x89\x08\x04\r\n\x0f\n\x07\x04%\x04\
    \0\x02\x04\x02\x12\x04\x89\x08\x10\x11\n5\n\x04\x04%\x02\0\x12\x04\x8d\
    \x08\x02\x12\x1a'\x20Current\x20state\x20of\x20the\x20batch\x20operation\
    .\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\x8d\x08\x02\x07\n\r\n\x05\x04%\x02\
    \0\x01\x12\x04\x8d\x08\x08\r\n\r\n\x05\x04%\x02\0\x03\x12\x04\x8d\x08\
    \x10\x11\n=\n\x04\x04%\x02\x01\x12\x04\x90\x08\x02,\x1a/\x20The\x20time\
    \x20when\x20the\x20batch\x20request\x20was\x20received.\n\n\r\n\x05\x04%\
    \x02\x01\x06\x12\x04\x90\x08\x02\x1b\n\r\n\x05\x04%\x02\x01\x01\x12\x04\
    \x90\x08\x1c'\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x90\x08*+\nD\n\x04\x04%\
    \x02\x02\x12\x04\x93\x08\x02,\x1a6\x20The\x20time\x20when\x20the\x20oper\
    ation\x20result\x20was\x20last\x20updated.\n\n\r\n\x05\x04%\x02\x02\x06\
    \x12\x04\x93\x08\x02\x1b\n\r\n\x05\x04%\x02\x02\x01\x12\x04\x93\x08\x1c'\
    \n\r\n\x05\x04%\x02\x02\x03\x12\x04\x93\x08*+b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
